# バーティカルスライスアーキテクチャ導入ガイド

## 概要

バーティカルスライスアーキテクチャは、機能単位でコードを組織化する方法です。このアプローチでは、関連するコンポーネント、ロジック、型、ユーティリティなどを特定の機能（スライス）ごとにグループ化します。各機能スライスは独立しており、明確に定義された公開APIを持ちます。

## 導入準備

バーティカルスライスアーキテクチャを導入する前に、以下の準備が必要です：

### 1. コードの一貫性確保

- **命名規則の統一**: コンポーネント、フック、型などの命名規則を統一します。

  - コンポーネント: PascalCase (`UserProfile`, `TransactionList`)
  - フック: camelCase + use接頭辞 (`useAuth`, `useTransactions`)
  - 型: PascalCase、接尾辞で役割を明示 (`UserData`, `TransactionProps`)
  - ファイル: コンポーネント/クラス名と一致させる

- **コーディングスタイルの統一**: ESLint、Prettier を使用して、コードスタイルを一貫させます。

### 2. 重複コードの削除

- 共通のユーティリティ関数を特定し、集約します。
- 類似したコンポーネントやロジックを抽出し、再利用可能にします。

### 3. 責任の明確化

- 各機能の境界と責任を明確に定義します。
- 機能間の依存関係を最小化し、明示的にします。

### 4. 型の整理

- グローバルな型定義と機能固有の型定義を区別します。
- 型の階層と関係を明確にします。

## フォルダ構造

バーティカルスライスアーキテクチャでは、以下のようなフォルダ構造を採用します：

```
src/
├── app/                      # Next.jsのルートレイアウトとページ
│   └── ...
├── components/               # 共通UIコンポーネント
│   ├── ui/                   # 基本UI要素
│   └── ...                   # ブリッジコンポーネント (下位互換性用)
├── features/                 # 機能モジュール
│   ├── auth/                 # 認証機能
│   │   ├── components/       # UIコンポーネント
│   │   ├── hooks/            # カスタムフック
│   │   ├── store/            # 状態管理
│   │   ├── types/            # 型定義
│   │   ├── utils/            # ユーティリティ関数
│   │   ├── index.ts          # 公開API
│   │   └── README.md         # 説明ドキュメント
│   ├── transactions/         # 取引機能
│   ├── balance/              # 残高機能
│   └── ...                   # その他の機能
├── lib/                      # 共通ライブラリ・ユーティリティ
│   └── ...
└── shared/                   # 機能間で共有されるコード
    └── ...
```

## 移行パターン

既存のコードベースからバーティカルスライスアーキテクチャへの移行には、以下のパターンを使用します：

### 1. 機能の特定と切り出し

1. 関連するコンポーネント、ロジック、型を特定します。
2. `features/{機能名}/` ディレクトリを作成します。
3. 関連コードを適切なサブディレクトリに移動します。
4. `index.ts` で公開APIを定義します。

### 2. ブリッジコンポーネントの作成

下位互換性を維持するため、元のパスにブリッジコンポーネントを作成します：

```typescript
// src/components/SomeComponent.tsx (ブリッジ)
import { SomeComponent as NewComponent } from "@/features/some-feature/components/SomeComponent";

// 元の場所に残すブリッジコンポーネント
export function SomeComponent(props) {
  // 新しいコンポーネントを使用
  return <NewComponent {...props} />;
}
```

### 3. 依存関係の整理

1. 循環参照を排除します。
2. 機能間の依存関係を最小化します。
3. 共有コードは `shared/` ディレクトリに移動します。

## 例: 認証機能の移行

### 移行前

```
src/
├── components/
│   ├── auth/
│   │   ├── AuthField.tsx
│   │   ├── AuthForm.tsx
│   │   └── LoginForm.tsx
├── hooks/
│   └── useAuthForm.ts
└── types/
    └── auth.d.ts
```

### 移行後

```
src/
├── components/
│   └── auth/                 # 互換性のためのブリッジコンポーネント
│       ├── AuthField.tsx     # -> @/features/auth からインポート
│       ├── AuthForm.tsx      # -> @/features/auth からインポート
│       └── LoginForm.tsx     # -> @/features/auth からインポート
└── features/
    └── auth/
        ├── components/
        │   ├── AuthField/
        │   │   ├── AuthField.tsx
        │   │   └── index.ts
        │   ├── AuthForm/
        │   │   ├── AuthForm.tsx
        │   │   └── index.ts
        │   └── LoginForm/
        │       ├── LoginForm.tsx
        │       └── index.ts
        ├── hooks/
        │   └── useAuthForm.ts
        ├── types/
        │   └── auth.ts
        ├── index.ts          # 公開API
        └── README.md         # 機能の説明
```

## ベストプラクティス

1. **明確な公開API**: 各機能は `index.ts` で明示的に公開するAPIを定義します。
2. **コンポーネントの分割**: UIコンポーネントは、プレゼンテーション（View）と状態・ロジック（Container）で分離します。
3. **テスト可能性**: 各コンポーネントとロジックは独立してテスト可能にします。
4. **文書化**: 各機能には `README.md` を作成し、使い方や責任範囲を説明します。
5. **型の厳密さ**: 型定義を厳密に行い、コンパイル時のエラーチェックを強化します。

## 段階的な移行

バーティカルスライスアーキテクチャへの移行は、一度に行う必要はありません。以下の順序で段階的に進めることができます：

1. 新しい機能から導入する
2. よく変更される機能を移行する
3. 残りの機能を徐々に移行する
4. ブリッジコンポーネントを最終的に削除する（オプション）

## 注意点

- 過剰な抽象化を避け、実用的な粒度でスライスを定義します。
- 機能間の重複よりも、明確な責任分担を優先します。
- API設計は将来の拡張性を考慮して行います。
