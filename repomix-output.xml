This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  pre-commit
docs/
  architecture/
    cline-development-guide.md
    development-guide.md
    neverthrow-migration-guide.md
    neverthrow-progress.md
    overview.md
  design/
    design-guideline.md
  README.md
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      auth/
        [...nextauth]/
          route.ts
    auth/
      forgot-password/
        page.tsx
      login/
        page.tsx
      register/
        page.tsx
      register-success/
        page.tsx
    campaigns/
      [id]/
        page.tsx
      page.tsx
    charge/
      page.tsx
    donate/
      [id]/
        page.tsx
    eco-news/
      [id]/
        page.tsx
      page.tsx
    history/
      [id]/
        page.tsx
      page.tsx
    impact/
      page.tsx
    invite/
      page.tsx
    notifications/
      [id]/
        page.tsx
      page.tsx
    payment/
      page.tsx
    qrcode/
      page.tsx
    settings/
      page.tsx
    splash/
      page.tsx
    transfer/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
    providers.tsx
  components/
    ui/
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      dialog.tsx
      error-display.tsx
      error-message.tsx
      input.tsx
      label.tsx
      loading-spinner.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      select.tsx
      separator.tsx
      switch.tsx
      tabs.tsx
      textarea.tsx
  features/
    auth/
      components/
        AuthField/
          AuthField.tsx
          AuthFieldView.tsx
          index.ts
          LegacyAuthField.tsx
        AuthForm/
          AuthForm.tsx
          index.ts
          LegacyAuthForm.tsx
        LoginForm/
          index.ts
          LoginForm.tsx
          LoginFormContainer.tsx
          LoginFormView.tsx
        LogoutButton/
          index.ts
          LogoutButton.tsx
      hooks/
        index.ts
        useAuthForm.ts
      store/
        auth.slice.ts
      types/
        auth.ts
      utils/
        validation.ts
      index.ts
      README.md
    balance/
      components/
        BalanceCard/
          BalanceCardContainer.tsx
          BalanceCardView.tsx
          index.ts
        BalanceOverview/
          BalanceOverview.tsx
          index.ts
      data/
        user-profile-data.ts
      store/
        balance.slice.ts
      types/
        balance.ts
      index.ts
      README.md
    campaigns/
      components/
        CampaignCard/
          CampaignCard.tsx
          index.ts
        FeaturedCampaign/
          FeaturedCampaignSection.tsx
          index.ts
        NotificationCampaignCard/
          index.ts
          NotificationCampaignCard.tsx
        ReferralCampaignCard/
          index.ts
          ReferralCampaignCard.tsx
      data/
        campaigns-data.ts
      store/
        campaign.slice.ts
      types/
        campaign.ts
      utils/
        campaign-utils.ts
      index.ts
      README.md
    charge/
      components/
        BankTransferSection/
          BankTransferSection.tsx
          index.ts
        ChargeComplete/
          ChargeComplete.tsx
          index.ts
        ChargeConfirm/
          ChargeConfirm.tsx
          index.ts
        ChargeInput/
          AmountInput.tsx
          BankTransferInput.tsx
          ChargeInputContainer.tsx
          ChargeInputForm.tsx
          index.ts
      types/
        charge.ts
      index.ts
      README.md
    donation/
      components/
        DonateComplete/
          DonateComplete.tsx
          index.ts
        DonateConfirm/
          DonateConfirm.tsx
          index.ts
        DonateInput/
          AmountSelector.tsx
          DonateInputContainer.tsx
          DonateInputForm.tsx
          index.ts
          ProjectInfo.tsx
      data/
        projects-data.ts
      types/
        donation.ts
      utils/
        project-converter.ts
      index.ts
      README.md
    eco-impact/
      components/
        CompactEcoImpact/
          CompactEcoImpact.tsx
          index.ts
        EcoContributionSummary/
          EcoContributionSummary.tsx
          index.ts
        EcoImpact/
          EcoImpactDisplay.tsx
          index.ts
        NewsAndProjects/
          index.ts
          NewsAndProjects.tsx
        RecommendedAction/
          index.ts
          RecommendedAction.tsx
        TransactionEcoImpact/
          index.ts
          TransactionEcoImpact.tsx
      data/
        eco-impact-data.ts
        recommended-actions-data.ts
      hooks/
        useEcoImpact.ts
      store/
        eco-impact.slice.ts
      types/
        eco-impact.ts
      utils/
        calculations.ts
      index.ts
      README.md
    eco-news/
      components/
        NewsDetail/
          index.ts
          NewsDetail.tsx
          RelatedNews.tsx
        NewsDetailPage/
          index.ts
          NewsDetailPage.tsx
        NewsList/
          index.ts
          NewsList.tsx
        NewsPage/
          index.ts
          NewsPage.tsx
      data/
        eco-news-data.ts
        news-data.ts
      hooks/
        useNewsFilter.ts
      types/
        eco-news.ts
      index.ts
      README.md
    invite/
      components/
        InviteCard/
          index.ts
          InviteCard.tsx
        QRCodeDisplay/
          index.ts
          QRCodeDisplay.tsx
        SocialShareButtons/
          index.ts
          SocialShareButtons.tsx
      types/
        invite.ts
      index.ts
      README.md
    layout/
      components/
        AppFooter/
          AppFooter.tsx
          index.ts
        AppHeader/
          AppHeader.tsx
          index.ts
        AuthLayout/
          AuthLayout.tsx
          index.ts
        PageContainer/
          index.ts
          PageContainer.tsx
      index.ts
      README.md
    notifications/
      components/
        NotificationBadge/
          index.ts
          NotificationBadge.tsx
        NotificationItem/
          index.ts
          NotificationItem.tsx
        NotificationList/
          index.ts
          NotificationList.tsx
      data/
        notifications-data.ts
      store/
        notification.slice.ts
      types/
        notification.ts
      index.ts
      README.md
    payment/
      components/
        PaymentMethodSelector/
          index.ts
          PaymentMethodSelector.tsx
          PaymentMethodSelectorContainer.tsx
        PaymentOptions/
          index.ts
          PaymentOptions.tsx
        PaymentSummary/
          index.ts
          PaymentSummary.tsx
        ProductInfo/
          index.ts
          ProductInfo.tsx
      data/
        payment-data.ts
      store/
        payment.slice.ts
      types/
        payment.ts
      index.ts
      README.md
    qrcode/
      components/
        BarCodeDisplay/
          BarCodeDisplay.tsx
          index.ts
        QRCodeDisplay/
          index.ts
          QRCodeDisplay.tsx
        QRCodeGenerator/
          index.ts
          QRCodeGenerator.tsx
        QRCodePage/
          index.ts
          QRCodePage.tsx
        QRCodeScanner/
          index.ts
          QRCodeScanner.tsx
      hooks/
        index.ts
        useQRCodeGenerator.ts
        useQRCodeScanner.ts
      types/
        qrcode.ts
      utils/
        qrcode-utils.ts
      index.ts
      README.md
    settings/
      components/
        PageHeader/
          index.ts
          PageHeader.tsx
        ProfileCard/
          index.ts
          ProfileCard.tsx
        SettingSection/
          index.ts
          SettingSection.tsx
        tabs/
          EcoTab.tsx
          index.ts
          NotificationsTab.tsx
          PaymentTab.tsx
          ProfileTab.tsx
          SecurityTab.tsx
      types/
        settings.ts
      index.ts
      README.md
    splash/
      components/
        BrandLogo/
          BrandLogo.tsx
          index.ts
        InitializationStatus/
          index.ts
          InitializationStatus.tsx
        SplashScreen/
          index.ts
          SplashScreen.tsx
      hooks/
        index.ts
        useSplashScreen.ts
      types/
        splash.ts
      utils/
        initialization.ts
      index.ts
      README.md
    transactions/
      components/
        RecentTransactions/
          index.ts
          RecentTransactionsContainer.tsx
          RecentTransactionsList.tsx
        TransactionDetail/
          ActionButtons.tsx
          index.ts
          ReceiptDialog.tsx
          TransactionDetailContainer.tsx
          TransactionDetailView.tsx
          TransactionEcoInfo.tsx
          TransactionHeader.tsx
          TransactionInfo.tsx
        TransactionDetailSection/
          index.ts
          TransactionDetailSection.tsx
        TransactionFilters/
          index.ts
          TransactionFilters.tsx
        TransactionItem/
          index.ts
          TransactionItem.tsx
        TransactionList/
          index.ts
          TransactionList.tsx
      data/
        transactions-data.ts
      hooks/
        index.ts
        transactionStyling.tsx
        useTransactionFilters.ts
      store/
        transaction.slice.ts
      types/
        receipt.ts
      index.ts
      README.md
    transfer/
      components/
        RecipientSelector/
          index.ts
          RecipientSelector.tsx
          RecipientSelectorModal.tsx
        SplitForm/
          index.ts
          SplitForm.tsx
        SplitHistoryList/
          index.ts
          SplitHistoryList.tsx
        SuccessMessage/
          index.ts
          SuccessMessage.tsx
        TransferForm/
          index.ts
          TransferForm.tsx
        TransferSplitPage/
          index.ts
          TransferSplitPage.tsx
      data/
        recipients-data.ts
        split-histories-data.ts
      hooks/
        index.ts
        useSplitForm.ts
        useSplitHistory.ts
        useTransferForm.ts
      types/
        transfer.ts
      utils/
        validation.ts
      index.ts
      README.md
  lib/
    business/
      balance.ts
      eco-contribution.ts
      payment.ts
      transaction.ts
    mock-data/
      transactions.ts
    utils/
      eco/
        calculations.ts
        index.ts
        types.ts
      transactions/
        filtering.ts
        index.ts
        styling.ts
        types.ts
        ui.tsx
      balance-utils.ts
      error-utils.ts
      index.ts
      invitation-utils.ts
      result-utils.ts
      validation.ts
    auth-config.ts
    auth.ts
    utils.ts
  services/
    api/
      balance.ts
      base.ts
      transactions.ts
      user.ts
  shared/
    hooks/
      index.ts
      useFormattedCurrency.ts
      useFormValidation.ts
    stores/
      app.slice.ts
    types/
      errors.ts
      transaction.ts
    utils/
      formats.ts
    index.ts
  types/
    next-auth.d.ts
  middleware.ts
.gitignore
components.json
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tailwind.config.js
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".husky/pre-commit">
npx lint-staged
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);

  /* EcoWallet teal theme */
  --color-teal-50: #e6fffa;
  --color-teal-700: #285e61;
  --color-teal-800: #234e52;
  --color-stone-50: #fafaf9;
  --color-stone-100: #f5f5f4;
  --color-stone-300: #d6d3d1;
  --color-stone-500: #78716c;
  --color-stone-600: #57534e;
  --color-stone-800: #292524;
  --color-stone-900: #1c1917;

  --eco-color-primary: var(--color-teal-700);
  --eco-color-primary-hover: var(--color-teal-800);
  --eco-color-secondary: var(--color-stone-600);
  --eco-color-bg-contribution: var(--color-teal-50);
  --eco-color-border-contribution: var(--color-teal-100);
  --eco-color-text-contribution: var(--color-teal-800);
  --eco-color-icon-contribution: var(--color-teal-600);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);

  /* EcoWallet teal theme variables */
  --eco-primary: #285e61;
  /* teal-700 */
  --eco-primary-hover: #234e52;
  /* teal-800 */
  --eco-accent: #e6fffa;
  /* teal-50 */
  --eco-background: #fafaf9;
  /* stone-50 */
  --eco-foreground: #1c1917;
  /* stone-900 */
  --eco-card: #ffffff;
  --eco-card-foreground: #292524;
  /* stone-800 */
  --eco-muted: #f5f5f4;
  /* stone-100 */
  --eco-muted-foreground: #78716c;
  /* stone-500 */
  --eco-border: #d6d3d1;
  /* stone-300 */

  /* 追加: トランジション用変数 */
  --eco-transition-duration: 200ms;
  --eco-transition-timing: ease-in-out;
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);

  /* EcoWallet dark theme variables */
  --eco-primary: #319795;
  /* teal-500 */
  --eco-primary-hover: #2c7a7b;
  /* teal-600 */
  --eco-accent: #234e52;
  /* teal-800 */
  --eco-background: #1c1917;
  /* stone-900 */
  --eco-foreground: #f5f5f4;
  /* stone-100 */
  --eco-card: #292524;
  /* stone-800 */
  --eco-card-foreground: #fafaf9;
  /* stone-50 */
  --eco-muted: #44403c;
  /* stone-700 */
  --eco-muted-foreground: #a8a29e;
  /* stone-400 */
  --eco-border: #57534e;
  /* stone-600 */
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }

  body {
    @apply bg-background text-foreground;
  }
}

/* EcoWallet styles */
.eco-primary {
  @apply bg-teal-700 hover:bg-teal-800 text-white;
}

.eco-card {
  @apply bg-white border-0 shadow-md;
}

.eco-alert {
  @apply bg-teal-50 border-teal-200;
}

/* 追加: 共通ユーティリティクラス */
.eco-contribution-container {
  @apply bg-teal-50 border border-teal-100 rounded-md p-4;
}

.eco-contribution-container-compact {
  @apply bg-teal-50 border border-teal-100 rounded-md p-2;
}

.eco-primary-button {
  @apply bg-teal-700 hover:bg-teal-800 text-white h-10;
}

.eco-transition {
  transition: all var(--eco-transition-duration) var(--eco-transition-timing);
}

.eco-hover-highlight:hover {
  @apply bg-teal-100 border-teal-200;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Eco Wallet - シンプルで環境に優しい決済サービス",
  description: "ペーパーレス決済で環境保護に貢献するエコウォレットサービス",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ja">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/providers.tsx">
"use client";

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";

export function Providers({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  );
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className,
      )}
      {...props}
    />
  );
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className,
      )}
      {...props}
    />
  );
}

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="src/components/ui/avatar.tsx">
"use client";

import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className,
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className,
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span";

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
        eco: "bg-teal-700 text-white shadow-xs hover:bg-teal-800 eco-transition",
      },
      size: {
        default: "h-10 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-lg border py-6 shadow-[0_4px_6px_rgba(0,0,0,0.1)]",
        className,
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className,
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className,
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };
</file>

<file path="src/components/ui/error-message.tsx">
import { AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";

interface ErrorMessageProps {
  message: string | null;
  className?: string;
}

export function ErrorMessage({ message, className }: ErrorMessageProps) {
  if (!message) return null;

  return (
    <div
      className={cn(
        "flex items-start p-3 text-sm bg-red-50 text-red-700 rounded-md border border-red-200",
        className,
      )}
    >
      <AlertCircle className="h-4 w-4 mr-2 mt-0.5 flex-shrink-0" />
      <span>{message}</span>
    </div>
  );
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "@/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className,
      )}
      {...props}
    />
  );
}

export { Label };
</file>

<file path="src/components/ui/loading-spinner.tsx">
import { cn } from "@/lib/utils";

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  className?: string;
  light?: boolean;
}

export function LoadingSpinner({
  size = "md",
  className,
  light = false,
}: LoadingSpinnerProps) {
  const sizeClass = {
    sm: "h-4 w-4 border-2",
    md: "h-6 w-6 border-2",
    lg: "h-8 w-8 border-3",
  };

  return (
    <div
      className={cn(
        "animate-spin rounded-full border-t-transparent",
        light ? "border-white/60" : "border-teal-700/60",
        sizeClass[size],
        className,
      )}
    />
  );
}
</file>

<file path="src/components/ui/progress.tsx">
import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-stone-200",
      className,
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className={cn(
        "h-full w-full flex-1 bg-teal-600 transition-all",
        className?.includes("bg-blue-500") ? "!bg-blue-500" : "",
        className?.includes("bg-green-600") ? "!bg-green-600" : "",
      )}
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="src/components/ui/radio-group.tsx">
"use client";

import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { CircleIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  );
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };
</file>

<file path="src/components/ui/select.tsx">
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1",
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  );
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className,
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className,
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className,
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className,
      )}
      {...props}
    />
  );
}

export { Separator };
</file>

<file path="src/components/ui/switch.tsx">
"use client";

import * as React from "react";
import * as SwitchPrimitive from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0",
        )}
      />
    </SwitchPrimitive.Root>
  );
}

export { Switch };
</file>

<file path="src/components/ui/tabs.tsx">
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  );
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className,
      )}
      {...props}
    />
  );
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  );
}

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/types/next-auth.d.ts">
import "next-auth";
import "next-auth/jwt";

declare module "next-auth" {
  interface User {
    balance: number;
    ecoRank: string;
  }

  interface Session {
    user: {
      id: string;
      balance: number;
      ecoRank: string;
      name?: string;
      email?: string;
      image?: string;
    };
  }
}
declare module "next-auth/jwt" {
  interface JWT {
    balance: number;
    ecoRank: string;
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# docs
docs/generated
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="docs/architecture/cline-development-guide.md">
# Cline開発ガイド - TypeScript特化プロンプトエンジニアリング

## 概要

このガイドは、Eco WalletプロジェクトでCline（AI Coding Agent）を効果的に活用するためのTypeScript特化プロンプトエンジニアリングのベストプラクティスをまとめたものです。

### なぜ言語特化プロンプトが必要か

- Coding Agentは言語ごとのユースケースに最適化されていない
- TypeScript周辺は技術選定で発散しがち
- プログラミング言語間の転移学習は不安定
- ツールの組み合わせで性能が変わる

### プロンプトを書くコツ

- **書きすぎない**（再現性ある範囲で詠唱破棄）
- 執拗に出力例を例示
- 両立条件の矛盾を避ける
- 規模感に合わせて厳しく

## 効果的なプロンプトパターン

### 1. テスト駆動開発（TDD）- 最重要

````markdown
TDD を実施する。コードを生成するときは、それに対応するユニットテストを常に生成する。
コードを追加で修正したとき、`npm test` がパスすることを常に確認する。

```ts
function add(a: number, b: number) {
  return a + b;
}
test("1+2=3", () => {
  expect(add(1, 2)).toBe(3);
});
```
````

````

**メリット:**
- 自己修復能力
- 高品質なテストがあればエージェントを放置しても完成する

**Eco Wallet適用例:**
```markdown
@/src/features/balance/utils/calculation.ts に残高計算関数を追加。
TDDで実装し、各関数に対応するテストを同じファイルに書く。
````

### 2. コメントによる自己記述

````markdown
各ファイルの冒頭にはコメントで仕様を記述する。

出力例

```ts
/**
 * 2点間のユークリッド距離を計算する
 */
type Point = { x: number; y: number };
export function distance(a: Point, b: Point): number {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}
```
````

````

**メリット:**
- 再修正時のコード解釈で一貫性を保てる

**Eco Wallet適用例:**
```markdown
@/src/features/transfer/utils/split-bill.ts に割り勘計算ロジックを実装。
ファイル冒頭に以下のような仕様コメントを必ず記載：

```ts
/**
 * 割り勘計算ユーティリティ
 * - 金額を人数で均等分割
 * - 端数は主催者が負担
 * - 最小単位は1円
 */
````

````

### 3. In Source Testing

```markdown
vitest で実装と同じファイルにユニットテストを書く。
出力例
```ts
export function distance(a: Point, b: Point): number {...}
if (import.meta.vitest) {
  const {test, expect} = import.meta.vitest;
  test("ユークリッド距離を計算する", () => {
    const result = distance({x: 0, y: 0}, {x: 3, y: 4});
    expect(result).toBe(5);
  });
}
````

````

**メリット:**
- コメント/実装/テストは三位一体
- 欠点: ファイルが肥大化しやすい（800~1000行あたりが限界）

**Eco Wallet適用例:**
```markdown
@/src/features/donation/utils/impact-calculator.ts に環境貢献度計算を実装。
vitestのIn Source Testingを使用：

```ts
export function calculateCO2Reduction(amount: number): number {
  // 実装
}

if (import.meta.vitest) {
  const {test, expect} = import.meta.vitest;
  test("1000円の寄付で10kgのCO2削減", () => {
    expect(calculateCO2Reduction(1000)).toBe(10);
  });
}
````

````

### 4. types.ts にドメイン型を集約

```markdown
src/types.ts にアプリケーション内のドメインモデルを集約する。
その型がどのように使われるかを jsdoc スタイルのコメントで記述
```ts
/**
 * キャッシュのインターフェース抽象
 */
export type AsyncCache<T> = {
  get(): Promise<T | void>;
  has(): Promise<boolean>;
  set(value: T): Promise<void>;
}
````

````

**メリット:**
- 中規模(1000L~): 複数ファイル間の SSoT を型定義とする
- read_file 頻度が下がる。書き換え頻度が（実装と比較して）比較的少ない

**Eco Wallet適用例:**
```markdown
@/src/features/[feature-name]/types/index.ts に各featureのドメイン型を集約。

例: @/src/features/payment/types/index.ts
```ts
/**
 * 決済トランザクションの状態
 * pending: 処理中
 * completed: 完了
 * failed: 失敗
 * cancelled: キャンセル
 */
export type PaymentStatus = 'pending' | 'completed' | 'failed' | 'cancelled';

/**
 * 決済方法
 */
export type PaymentMethod = {
  type: 'balance' | 'campaign' | 'mixed';
  details: PaymentDetails;
};
````

````

### 5. TypeScript + 関数型ドメインモデリング

```markdown
TypeScript で関数型ドメインモデリングを行う。class を使わず関数による実装を優先する。
代数的データでドメインをモデリングする。
出力例
```ts
type FetchResult<T, E> = {
  ok: true;
  data: T
} | {
  ok: false;
  error: E
}
````

````

**メリット:**
- （好みの問題はあるが）状態の発散を抑えるのに不変データ構造が望ましい

**Eco Wallet適用例:**
```markdown
@/src/features/charge/types/charge-result.ts でチャージ結果を代数的データ型で定義：

```ts
export type ChargeResult =
  | { status: 'success'; chargeId: string; amount: number; }
  | { status: 'insufficient_funds'; required: number; available: number; }
  | { status: 'limit_exceeded'; limit: number; requested: number; }
  | { status: 'error'; code: string; message: string; };

// 使用例
export function processCharge(amount: number): ChargeResult {
  // 実装
}
````

````

### 6. ファイル配置規則を明記

```markdown
以下のモノレポの配置規則に従う。

script/
  <task-name>.ts    # タスク
packages/
  <mod-name>/
    examples/
      *.ts          # ユースケース例
    src/
      index.ts      # エントリポイント
      index.test.ts # ファイルに対応するユニットテスト
      types.ts      # 型定義
    test/
      *.test.ts     # インテグレーションテスト
````

**メリット:**

- 中規模以上: タスク毎のエージェントの推測コストを減らす

**Eco Wallet適用例:**

```markdown
Eco Walletのfeatureモジュール構造に従う：

features/[feature-name]/
├── components/ # UIコンポーネント
├── hooks/ # カスタムフック
├── store/ # 状態管理
├── types/ # 型定義（ドメインモデル集約）
├── utils/ # ユーティリティ関数（テスト含む）
├── data/ # モックデータ
├── index.ts # 公開API
└── README.md # 機能の説明
```

### 7. 詳細指示を docs/\*.md に分割

```markdown
(システムプロンプト)
docs/\*.md はこのプロジェクトで必要なドキュメントが置かれている。
ユーザーの指示に基づいて参照する。

(個別プロンプト)
@/docs/react-test-pattern.md を読んで @/src/components/Button.tsx にユニットテストを追加

(docs/react-test-pattern.md)
このドキュメントでは react を @testing-library/react でテストを書く方法を指示する。
以下テストコード例...
```

**メリット:**

- 大規模用(3000L~)
- 理由: 無関係な指示が常に存在すると、次第にすべてを無視するようになっていく
- 欠点: ドキュメントを用意/把握するのがだるい

### 8. カバレッジに基づくテストの自動生成

```markdown
テストカバレッジ100%を目指す。
`*.ts` に対して、`*.test.ts` でユニットテストを書く
.test.ts がない実装に対して、他のテストを参考にテストコードを追加

1. `npx vitest --run --coverage` を実行して、現在のカバレッジを取得
2. 今の状態から最もカバレッジが上がるテストコードを考察してから追加
3. 再度カバレッジを計測して、数値が向上していることを確認

ユーザーが満足するまで、テスト生成を繰り返す
```

**メリット:**

- [Automated Unit Test Improvement using Large Language Models at Meta](https://arxiv.org/abs/2402.09171)
- Clineなら特に工夫なく再現可能

## 個別タスク用プロンプト

### 1. 機械的なマイグレーション

```markdown
@/docs/You-Dont-Need-Lodash-Underscore.md を参考に lodash を削除する。
プロジェクト内の lodash のコードを grep で検索して、それらを置き換える。
置き換えた後に `npm test` を実施して、テストが通っていることを確認する
```

**活用例:**

- lodashの削除
- moment.js → date-fns への移行
- class-based → functional componentsへの移行

### 2. 似たAPIのライブラリに置き換える

```markdown
ライブラリAをライブラリBに置き換えて
```

**置き換え可能な例:**

- **cypress** => **playwright**
- **jest** => **vitest**
- **recoil** => **jotai**
- **Vue** => **Svelte**

90%自動化できる（最後は気合）

### 3. URLを読む能力（MCP）

```markdown
(システムプロンプト)
あなたはURLが与えられた時、以下のコマンドでそのURLの内容をmardownで取得できる
`npx -y @mizchi/readability --format=md <url>`

(個別プロンプト: 1)
https://blog.cloudflare.com/cloudflare-containers-coming-2025/ 読んで

(個別プロンプト: 2)
今読んだ内容を docs/ 以下に要約して保存しておいて
```

## Copilot連携のTIPS

### 1. 型定義ファイルを一時的にPin

- vscodeの `Open Editors` で `Pin` しておくと優先的に参照
- 特に `typescript.d.ts` のようなAPIが膨大なライブラリ

### 2. コメントから書き始める

```typescript
// ExecutionResult を prioty で並び替える関数<TAB>
```

- インラインプロンプトだと思って書く
- Open Editorsの他のタブの内容を見ているので、型定義のPinと相性がいい
- 最終的に消しがち

## アンチパターン（避けるべきこと）

### 1. 型だけで設計

````markdown
Architect モードでは、最初に型シグネチャとそのユースケースで仕様を整理する。
型とそれを使うテストコードをユーザーに提案し、同意後に実装を行う
出力例

```ts
declare function add(a: number, b: number): number;
test("add(1,2) => 3", () => {
  expect(1, 2).toBe(3);
});
```
````

````

**問題点:**
- ほぼ確実に無視される。型だけで抽象的に設計する能力はない
- 「テストと型をそのままに実装だけを修正して」も無視されがち

### 2. 非同期例外処理がヘタクソ

```typescript
async function main() {
  try {
    await init();
    try {
      await run();
    } catch (err) {
      /// ...
    }
  } catch (err) {
    console.error(err)
  }
}
````

**問題点:**

- 思考停止気味に try-catch で握り潰す（Gemini に顕著）
- 大規模で破綻する要因の一つ

### 3. 環境構築が下手

```markdown
(User)
typescript + vite + vitest でセットアップして

(Assistant)
foo.ts が実行できません。
vite-node を入れます。 ts-node を入れます、tsx を入れます。 tsconfig.json を削除してみます。
拡張子を全部 .cjs にします、package.json の `type: module` を削除します。
```

**問題点:**

- 「環境」そのものが一番強力なプロンプトで、ゼロショットは発散
- Cline: 手数が仇になって環境破壊

### 4. モジュールインターフェースが発散

````markdown
モジュール利用者の視点で使いやすくするために export を減らす

```ts
export {
  generateDetailedComplexityReport,
  generateMetricsReport,
  generateModuleComplexityReport,
} from "./core/mod.ts";
```
````

````

**現実:**
- とにかく実装次第に全部 export
- モジュール間の契約が肥大化して破綻

**暫定対応:**
- [tsr](https://github.com/line/tsr) でTreeShake相当でデッドコード検出
- `npx -y tsr src/index.ts test/**/*.ts`

### 5. チェーホフの銃の法則

- 無関係なリソースを読み込んでも、それを使うことに固執する
- 大規模コード + Clineは `ls` や `grep` で見つかること自体がノイズ

### 6. デバッグログ食いすぎ

```typescript
console.log("debug: start process")
for (const item of items) {
  console.log("debug: process item", item);
  // ...
}
console.log("debug: end process")
````

**問題点:**

- 自身が生成したプリントデバッグでコンテキストウィンドウを消費
- 書き散らしたデバッグコードを放置する（Claude 3.x 系に顕著）

## 実践的な開発フロー

### 現時点のベストプラクティス

1. **PoC/プロトタイプのコードの生成**

   - 1ファイル完結の800行以内を目安

2. **自分でリファクタしつつ組み込む**

   - 特にインターフェース設計は自分でやる

3. **失敗パターンをプロンプトに反映**

   - 盆栽

4. **成功するパターンのドキュメント化**
   - 再度参照する用に `docs/*.md` を構築

### LLMの限界を理解する

**LLMはコーディングが下手:**

- 低品質コードで設計破綻して自滅
- リファクタリング指針がない
- 不要コードを判定する能力が低い
- モジュール視点でAPI設計ができない
- ユーザー側でリファクタリングしても元の低品質なコードに書き戻す

## Eco Wallet固有の適用方法

### 1. Feature モジュール向けプロンプト例

```markdown
@/src/features/payment に新しい決済機能を追加。
バーティカルスライスアーキテクチャに従い、以下の構造で実装：

1. types/payment-types.ts に型定義を集約（関数型ドメインモデリング）
2. utils/payment-processor.ts に決済ロジック（In Source Testing使用）
3. components/PaymentForm.tsx にUIコンポーネント
4. hooks/usePayment.ts にカスタムフック
5. index.ts で公開APIを定義

各ファイル冒頭に仕様をコメントで記述。
TDDで実装し、`npm test` が常にパスすることを確認。
```

### 2. 既存コードのリファクタリング

```markdown
@/src/features/transactions のコードをリファクタリング。

1. types/index.ts にドメイン型を集約
2. 巨大なコンポーネントを分割（各ファイル800行以内）
3. classベースの実装を関数型に置き換え
4. In Source Testingでテストを追加
5. 不要なexportを削除（tsrで確認）
```

### 3. マイグレーションタスク

```markdown
@/docs/migration-guides/remove-moment.md を参考に、
プロジェクト全体のmoment.jsをdate-fnsに置き換え。

1. grep でmoment使用箇所を特定
2. 各ファイルを順次置き換え
3. テストが通ることを確認
4. 最終的に moment を package.json から削除
```

## 品質管理

### 1. Lintルールでプロンプトをルールベースに変換

例: 自作カスタムルール do-try

```typescript
// doからはじまる関数は try-catch を必須
try {
  const v = await doGetData();
} catch (_err) {}
// 例外中立: doからはじまる関数のみ try catch 免除
async function doMain() {
  await doXXX();
  await doYYY();
}
```

### 2. コード規模の管理

- ファイルは800-1000行を上限とする
- それ以上になる場合は分割を検討
- In Source Testingを使う場合は特に注意

### 3. テストカバレッジ目標

- 新規コードは100%を目指す
- 既存コードは段階的に改善
- カバレッジベースの自動テスト生成を活用

## プログラミングの変質と今後

### より重要になったスキル

- **テスト駆動開発**で開発高速化
- LLMの得意領域/発達段階を予測する技術
- プロンプトエンジニアリング

### 変わっていないこと

- プログラミングの最終的な難易度/複雑性
- 自然言語 to コードで間違いなく学びやすくなっている

### まとめ

- **今はコストと性能がトレードオフ**

  - 一旦は得意なことを任せる
  - AIが苦手なことは（自動化コストを念頭に）人間がやる

- **エンジニアとして生き残るにはコード生成にスキルを寄せる**

  - 自動化成功の見返りは10xどころではない破壊的なもの

- **自動テスト+プロンプトエンジニアリングが高コスパ**
  - [Prompt Engineering Guide](https://www.promptingguide.ai/)
  - [LLMのプロンプトエンジニアリング - O'Reilly Japan](https://www.oreilly.co.jp/books/9784814401130/)

## リソース

- [TypeScript for Cline（元記事）](https://zenn.dev/mizchi/articles/typescript-for-cline)
- [関数型ドメインモデリング](https://www.amazon.co.jp/dp/4048931164)
- [You Don't Need Lodash/Underscore](https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore)
- [@mizchi/readability](https://github.com/mizchi/readability)
- [tsr - TypeScript Remove](https://github.com/line/tsr)
</file>

<file path="docs/architecture/development-guide.md">
# Eco Wallet 開発ガイド

## 概要

このガイドは、Eco Walletのバーティカルスライスアーキテクチャに基づいた開発方法を説明します。新機能の追加、既存機能の修正、コンポーネントの作成など、開発に必要な情報を提供します。

## アーキテクチャ原則

### 1. バーティカルスライスアーキテクチャ

Eco Walletは機能単位でコードを組織化しています。各機能（feature）は独立したモジュールとして実装され、以下の利点があります：

- **独立性**: 各featureは独立して開発・テスト可能
- **保守性**: 機能ごとに整理されているため、コードの理解と修正が容易
- **再利用性**: 明確な公開APIにより、コンポーネントの再利用が簡単
- **拡張性**: 新機能の追加が既存コードに影響を与えにくい

### 2. 命名規則

- **コンポーネント**: PascalCase (`TransactionList`, `PaymentForm`)
- **フック**: camelCase + use接頭辞 (`useAuth`, `useBalance`)
- **型**: PascalCase、接尾辞で役割を明示 (`UserData`, `TransactionProps`)
- **ファイル**: コンポーネント/クラス名と一致させる
- **定数**: UPPER_SNAKE_CASE (`MAX_AMOUNT`, `DEFAULT_CURRENCY`)
- **関数**: camelCase (`calculateTotal`, `formatDate`)

## 新機能の追加

### 1. Feature モジュールの作成

新しい機能を追加する場合、以下の手順に従います：

```bash
# 新しいfeatureディレクトリを作成
mkdir -p src/features/[feature-name]/{components,hooks,store,types,utils,data}
```

### 2. 必須ファイルの作成

#### index.ts（公開API）

```typescript
// src/features/[feature-name]/index.ts
export { FeatureComponent } from "./components/FeatureComponent";
export { useFeatureHook } from "./hooks/useFeatureHook";
export type { FeatureType } from "./types/feature.types";
```

#### README.md（ドキュメント）

```markdown
# [Feature Name] モジュール

## 概要

この機能の目的と責任範囲を説明

## 主要コンポーネント

- ComponentA: 説明
- ComponentB: 説明

## 使用方法

\`\`\`typescript
import { FeatureComponent } from '@/features/[feature-name]';
\`\`\`
```

### 3. 型定義の作成

```typescript
// src/features/[feature-name]/types/feature.types.ts
export interface FeatureData {
  id: string;
  // その他のプロパティ
}

export interface FeatureProps {
  data: FeatureData;
  onAction?: (id: string) => void;
}
```

### 4. コンポーネントの実装

```typescript
// src/features/[feature-name]/components/FeatureComponent.tsx
import React from 'react';
import { FeatureProps } from '../types/feature.types';

export const FeatureComponent: React.FC<FeatureProps> = ({ data, onAction }) => {
  return (
    <div className="p-4 bg-white rounded-lg shadow">
      {/* コンポーネントの実装 */}
    </div>
  );
};
```

## 既存機能の修正

### 1. 影響範囲の確認

修正前に以下を確認：

- 該当featureの`README.md`を読む
- 公開API（`index.ts`）を確認
- 他のfeatureからの依存を確認

### 2. テストの実行

```bash
# 単体テストの実行
npm run test

# 特定のfeatureのテスト
npm run test -- features/[feature-name]
```

### 3. 型安全性の確保

TypeScriptの型チェックを活用：

```bash
# 型チェックの実行
npm run type-check
```

## 共通パターン

### 1. フックの作成パターン

```typescript
// src/features/[feature-name]/hooks/useFeature.ts
import { useState, useEffect } from "react";
import { FeatureData } from "../types/feature.types";

export const useFeature = (id: string) => {
  const [data, setData] = useState<FeatureData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // データ取得ロジック
  }, [id]);

  return { data, loading, error };
};
```

### 2. ストアの作成パターン

```typescript
// src/features/[feature-name]/store/feature.slice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { FeatureData } from "../types/feature.types";

interface FeatureState {
  items: FeatureData[];
  loading: boolean;
  error: string | null;
}

const initialState: FeatureState = {
  items: [],
  loading: false,
  error: null,
};

export const featureSlice = createSlice({
  name: "feature",
  initialState,
  reducers: {
    setItems: (state, action: PayloadAction<FeatureData[]>) => {
      state.items = action.payload;
    },
    // その他のreducers
  },
});

export const { setItems } = featureSlice.actions;
export default featureSlice.reducer;
```

### 3. ユーティリティ関数のパターン

```typescript
// src/features/[feature-name]/utils/feature-utils.ts
export const formatFeatureData = (data: FeatureData): string => {
  // フォーマットロジック
  return formatted;
};

export const validateFeatureInput = (input: unknown): boolean => {
  // バリデーションロジック
  return isValid;
};
```

## スタイリングガイドライン

### 1. Tailwind CSS の使用

```typescript
// 推奨: Tailwind CSSクラスを使用
<div className="p-4 bg-white rounded-lg shadow-md">

// 避ける: インラインスタイル
<div style={{ padding: '16px', background: 'white' }}>
```

### 2. カラーパレット

デザインガイドラインに従い、以下の色を使用：

- **プライマリ**: `bg-teal-700` (#0F766E)
- **セカンダリ**: `bg-stone-500` (#78716C)
- **アクセント**: `bg-amber-600` (#D97706)
- **成功**: `bg-green-600` (#16A34A)
- **エラー**: `bg-red-600` (#DC2626)

### 3. レスポンシブデザイン

```typescript
<div className="
  w-full
  md:w-1/2     // タブレット以上で半分の幅
  lg:w-1/3     // デスクトップで1/3の幅
">
```

## テスト方針

### 1. 単体テスト

各featureごとにテストを作成：

```typescript
// src/features/[feature-name]/__tests__/FeatureComponent.test.tsx
import { render, screen } from '@testing-library/react';
import { FeatureComponent } from '../components/FeatureComponent';

describe('FeatureComponent', () => {
  it('renders correctly', () => {
    render(<FeatureComponent data={mockData} />);
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });
});
```

### 2. 統合テスト

feature間の連携をテスト：

```typescript
// src/__tests__/integration/feature-integration.test.tsx
import { renderWithProviders } from "@/test/utils";
import { FeatureA } from "@/features/feature-a";
import { FeatureB } from "@/features/feature-b";

describe("Feature Integration", () => {
  it("features work together correctly", () => {
    // テストの実装
  });
});
```

## パフォーマンス最適化

### 1. 遅延読み込み

```typescript
// src/app/[feature]/page.tsx
import dynamic from 'next/dynamic';

const FeatureComponent = dynamic(
  () => import('@/features/[feature-name]').then(mod => mod.FeatureComponent),
  {
    loading: () => <LoadingSpinner />,
    ssr: false // 必要に応じて
  }
);
```

### 2. メモ化

```typescript
// 高コストな計算のメモ化
const expensiveValue = useMemo(() => {
  return calculateExpensiveValue(data);
}, [data]);

// コンポーネントのメモ化
const MemoizedComponent = React.memo(Component);
```

### 3. 画像の最適化

```typescript
import Image from 'next/image';

<Image
  src="/image.jpg"
  alt="Description"
  width={300}
  height={200}
  loading="lazy"
  placeholder="blur"
/>
```

## デバッグとトラブルシューティング

### 1. Redux DevTools

ストアの状態を確認：

```typescript
// ブラウザの拡張機能でRedux DevToolsを使用
// Chrome: Redux DevTools Extension
```

### 2. React Developer Tools

コンポーネントツリーとpropsを確認：

```typescript
// ブラウザの拡張機能でReact Developer Toolsを使用
// Chrome: React Developer Tools
```

### 3. ログの活用

```typescript
// 開発環境でのみログを出力
if (process.env.NODE_ENV === "development") {
  console.log("Debug info:", data);
}
```

## よくある質問

### Q1: 新しいページを追加するには？

```bash
# 1. ページファイルを作成
touch src/app/[page-name]/page.tsx

# 2. 関連するfeatureを作成または既存のものを使用
# 3. ページコンポーネントを実装
```

### Q2: 共通コンポーネントはどこに配置する？

- **UI基本要素**: `src/components/ui/`（Button、Input等）
- **Feature間共有**: `src/shared/components/`
- **Feature固有**: `src/features/[feature-name]/components/`

### Q3: 環境変数の使用方法は？

```typescript
// .env.local
NEXT_PUBLIC_API_URL=https://api.example.com

// 使用方法
const apiUrl = process.env.NEXT_PUBLIC_API_URL;
```

### Q4: エラーハンドリングのベストプラクティスは？

```typescript
try {
  const result = await apiCall();
  return result;
} catch (error) {
  // ユーザーへのフィードバック
  toast.error("エラーが発生しました");

  // 開発環境でのログ
  if (process.env.NODE_ENV === "development") {
    console.error("API Error:", error);
  }

  // エラーの再スロー（必要に応じて）
  throw error;
}
```

## リソース

- [Next.js ドキュメント](https://nextjs.org/docs)
- [Tailwind CSS ドキュメント](https://tailwindcss.com/docs)
- [shadcn/ui コンポーネント](https://ui.shadcn.com/)
- [Redux Toolkit ドキュメント](https://redux-toolkit.js.org/)
- [TypeScript ドキュメント](https://www.typescriptlang.org/docs/)
</file>

<file path="docs/architecture/neverthrow-migration-guide.md">
# Neverthrow導入ガイド

## 1. 概要と目的

### 1.1 背景

Eco Walletプロジェクトでは、現在エラーハンドリングが`string | null`型による単純な実装となっており、以下の課題があります：

- エラーの型安全性が不十分
- エラーハンドリングのパターンが統一されていない
- 例外処理と正常処理の境界が曖昧
- 非同期処理でのエラーハンドリングが複雑

### 1.2 導入目的

**neverthrow**を導入することで、以下の改善を目指します：

- **型安全性の向上**: `Result<T, E>`による明示的なエラー型
- **エラーハンドリングの統一**: 一貫したパターンによる保守性向上
- **関数型プログラミングの利点**: メソッドチェーンによる宣言的なコード
- **非同期処理の改善**: `ResultAsync<T, E>`による堅牢な非同期エラーハンドリング

### 1.3 期待される効果

- **開発効率の向上**: エラーケースの見落とし防止
- **バグの削減**: コンパイル時のエラーハンドリング強制
- **保守性の向上**: 統一されたエラーハンドリングパターン
- **テスタビリティの向上**: エラーケースのテストが容易

## 2. 技術仕様

### 2.1 neverthrowライブラリの基本概念

#### Result型

```typescript
import { Result, ok, err } from "neverthrow";

// 成功の場合
const success: Result<number, string> = ok(42);

// 失敗の場合
const failure: Result<number, string> = err("エラーメッセージ");
```

#### ResultAsync型（非同期処理）

```typescript
import { ResultAsync, okAsync, errAsync } from "neverthrow";

// 非同期処理の成功
const asyncSuccess: ResultAsync<User, ApiError> = okAsync(user);

// 非同期処理の失敗
const asyncFailure: ResultAsync<User, ApiError> = errAsync(apiError);
```

#### 主要メソッド

- `map`: 成功値の変換
- `mapErr`: エラー値の変換
- `andThen`: 成功時の別のResult処理へのチェーン
- `match`: 成功・失敗の両方を処理
- `unwrapOr`: デフォルト値付きの値取得

### 2.2 プロジェクト固有のエラー型設計

#### 共通エラー型の定義

```typescript
// src/shared/types/errors.ts

/**
 * バリデーションエラー
 */
export type ValidationError =
  | {
      type: "INVALID_EMAIL";
      message: string;
      field: "email";
    }
  | {
      type: "INVALID_AMOUNT";
      message: string;
      field: "amount";
      min?: number;
      max?: number;
    }
  | {
      type: "REQUIRED_FIELD";
      message: string;
      field: string;
    }
  | {
      type: "INVALID_FORMAT";
      message: string;
      field: string;
      expected: string;
    };

/**
 * APIエラー
 */
export type ApiError =
  | {
      type: "NETWORK_ERROR";
      message: string;
      cause?: Error;
    }
  | {
      type: "SERVER_ERROR";
      message: string;
      statusCode: number;
      details?: Record<string, unknown>;
    }
  | {
      type: "TIMEOUT_ERROR";
      message: string;
      timeoutMs: number;
    }
  | {
      type: "UNAUTHORIZED";
      message: string;
    }
  | {
      type: "FORBIDDEN";
      message: string;
    };

/**
 * ビジネスロジックエラー
 */
export type BusinessError =
  | {
      type: "INSUFFICIENT_BALANCE";
      message: string;
      required: number;
      available: number;
    }
  | {
      type: "PAYMENT_FAILED";
      message: string;
      reason: string;
    }
  | {
      type: "TRANSACTION_LIMIT_EXCEEDED";
      message: string;
      limit: number;
      attempted: number;
    };

/**
 * 統合エラー型
 */
export type AppError = ValidationError | ApiError | BusinessError;
```

#### エラーハンドリングユーティリティ

```typescript
// src/lib/utils/error-utils.ts
import { AppError } from "@/shared/types/errors";

/**
 * エラーをユーザー向けメッセージに変換
 */
export function getErrorMessage(error: AppError): string {
  switch (error.type) {
    case "INVALID_EMAIL":
      return "有効なメールアドレスを入力してください";
    case "INVALID_AMOUNT":
      return error.message;
    case "REQUIRED_FIELD":
      return `${error.field}は必須項目です`;
    case "NETWORK_ERROR":
      return "ネットワークエラーが発生しました。接続を確認してください。";
    case "SERVER_ERROR":
      return "サーバーエラーが発生しました。しばらく時間をおいて再試行してください。";
    case "INSUFFICIENT_BALANCE":
      return `残高が不足しています。必要額: ¥${error.required.toLocaleString()}、利用可能額: ¥${error.available.toLocaleString()}`;
    default:
      return "エラーが発生しました";
  }
}

/**
 * エラーの重要度を判定
 */
export function getErrorSeverity(
  error: AppError,
): "low" | "medium" | "high" | "critical" {
  switch (error.type) {
    case "INVALID_EMAIL":
    case "INVALID_AMOUNT":
    case "REQUIRED_FIELD":
    case "INVALID_FORMAT":
      return "low";
    case "NETWORK_ERROR":
    case "TIMEOUT_ERROR":
      return "medium";
    case "SERVER_ERROR":
    case "PAYMENT_FAILED":
      return "high";
    case "UNAUTHORIZED":
    case "FORBIDDEN":
      return "critical";
    default:
      return "medium";
  }
}
```

### 2.3 導入パターンとベストプラクティス

#### パターン1: バリデーション関数

```typescript
// Before
export function validateAmount(amount: string): {
  isValid: boolean;
  reason?: string;
} {
  const numAmount = Number(amount);
  if (isNaN(numAmount)) {
    return { isValid: false, reason: "有効な金額を入力してください" };
  }
  return { isValid: true };
}

// After
export function validateAmount(
  amount: string,
): Result<number, ValidationError> {
  const numAmount = Number(amount);
  if (isNaN(numAmount)) {
    return err({
      type: "INVALID_AMOUNT",
      message: "有効な金額を入力してください",
      field: "amount",
    });
  }
  return ok(numAmount);
}
```

#### パターン2: API呼び出し

```typescript
// Before
async function fetchUserBalance(userId: string): Promise<number> {
  try {
    const response = await fetch(`/api/users/${userId}/balance`);
    if (!response.ok) {
      throw new Error("Failed to fetch balance");
    }
    const data = await response.json();
    return data.balance;
  } catch (error) {
    throw error;
  }
}

// After
function fetchUserBalance(userId: string): ResultAsync<number, ApiError> {
  return ResultAsync.fromPromise(
    fetch(`/api/users/${userId}/balance`).then(async (response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      return data.balance;
    }),
    (error) => ({
      type: "NETWORK_ERROR",
      message: "Failed to fetch user balance",
      cause: error instanceof Error ? error : new Error(String(error)),
    }),
  );
}
```

#### パターン3: ビジネスロジック

```typescript
// Before
function processPayment(amount: number, balance: number): boolean {
  if (balance < amount) {
    throw new Error("Insufficient balance");
  }
  // 支払い処理
  return true;
}

// After
function processPayment(
  amount: number,
  balance: number,
): Result<void, BusinessError> {
  if (balance < amount) {
    return err({
      type: "INSUFFICIENT_BALANCE",
      message: "残高が不足しています",
      required: amount,
      available: balance,
    });
  }
  // 支払い処理
  return ok(undefined);
}
```

## 3. 段階的導入計画

### Phase 1: 基盤整備 (推定工数: 2-3日)

#### 3.1.1 パッケージインストール

```bash
npm install neverthrow
```

#### 3.1.2 基盤ファイルの作成

- [ ] `src/shared/types/errors.ts` - エラー型定義
- [ ] `src/lib/utils/error-utils.ts` - エラーハンドリングユーティリティ
- [ ] `src/lib/utils/result-utils.ts` - Result型ユーティリティ

#### 3.1.3 バリデーション関数の改修

- [ ] `src/lib/utils/validation.ts` - 既存関数をResult型に変更
- [ ] 新しいバリデーション関数の追加

#### 3.1.4 成功条件

- [ ] 全てのバリデーション関数がResult型を返す
- [ ] 型エラーが発生しない
- [ ] 既存テストが通る（アダプター関数使用）

### Phase 2: ビジネスロジック層の改修 (推定工数: 5-7日)

#### 3.2.1 API関数の改修

- [ ] `src/services/api/` - 全API関数をResultAsync型に変更
- [ ] `src/services/mock/` - モック関数の対応

#### 3.2.2 ビジネスロジック関数の改修

- [ ] 決済処理関数
- [ ] 残高管理関数
- [ ] トランザクション処理関数

#### 3.2.3 状態管理の改修

- [ ] Zustandストアでのエラーハンドリング統一
- [ ] 非同期アクションの改修

#### 3.2.4 成功条件

- [ ] 全てのAPI関数がResultAsync型を返す
- [ ] エラーハンドリングが統一されている
- [ ] 非同期処理のエラーが適切に処理される

### Phase 3: UI層の改修 (推定工数: 3-5日)

#### 3.3.1 フォームコンポーネントの改修

- [ ] `ChargeInputContainer` - Result型の利用
- [ ] `PaymentMethodSelector` - エラーハンドリング統一
- [ ] その他フォームコンポーネント

#### 3.3.2 エラー表示コンポーネントの統一

- [ ] 統一されたエラー表示コンポーネント作成
- [ ] エラーメッセージの国際化対応

#### 3.3.3 成功条件

- [ ] 全てのフォームでResult型が活用されている
- [ ] エラー表示が統一されている
- [ ] ユーザビリティが向上している

## 4. 実装ガイドライン

### 4.1 コード変換パターン集

#### パターン1: 単純な戻り値変換

```typescript
// Before
function divide(a: number, b: number): number {
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
}

// After
function divide(a: number, b: number): Result<number, string> {
  if (b === 0) {
    return err("Division by zero");
  }
  return ok(a / b);
}
```

#### パターン2: 複数のバリデーション

```typescript
// Before
function validateUser(user: any): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  if (!user.email) errors.push("Email is required");
  if (!user.name) errors.push("Name is required");
  return { isValid: errors.length === 0, errors };
}

// After
import { Result, combine } from "neverthrow";

function validateUser(user: any): Result<User, ValidationError[]> {
  const emailResult = user.email
    ? ok(user.email)
    : err({
        type: "REQUIRED_FIELD",
        message: "Email is required",
        field: "email",
      });

  const nameResult = user.name
    ? ok(user.name)
    : err({
        type: "REQUIRED_FIELD",
        message: "Name is required",
        field: "name",
      });

  return Result.combineWithAllErrors([emailResult, nameResult]).map(
    ([email, name]) => ({ email, name }),
  );
}
```

#### パターン3: 非同期処理のチェーン

```typescript
// Before
async function processUserRegistration(userData: any) {
  try {
    const validatedUser = validateUser(userData);
    const savedUser = await saveUser(validatedUser);
    const emailSent = await sendWelcomeEmail(savedUser.email);
    return { user: savedUser, emailSent };
  } catch (error) {
    throw error;
  }
}

// After
function processUserRegistration(
  userData: any,
): ResultAsync<{ user: User; emailSent: boolean }, AppError> {
  return validateUser(userData)
    .asyncAndThen(saveUser)
    .andThen((user) =>
      sendWelcomeEmail(user.email).map((emailSent) => ({ user, emailSent })),
    );
}
```

### 4.2 移行時のベストプラクティス

#### 4.2.1 段階的移行

- 新しい機能から始める
- 既存機能は安定性を優先
- アダプター関数で互換性を保つ

#### 4.2.2 型安全性の確保

- `any`型の使用を避ける
- エラー型を明示的に定義
- ジェネリクスを活用する

#### 4.2.3 パフォーマンス配慮

- 不要なResultオブジェクトの生成を避ける
- メモ化が必要な場合は適切に実装
- 大量データ処理では注意深く設計

### 4.3 テスト戦略

#### 4.3.1 単体テスト

```typescript
// バリデーション関数のテスト例
describe("validateAmount", () => {
  test("valid amount returns Ok", () => {
    const result = validateAmount("100");
    expect(result.isOk()).toBe(true);
    expect(result.unwrapOr(0)).toBe(100);
  });

  test("invalid amount returns Err", () => {
    const result = validateAmount("invalid");
    expect(result.isErr()).toBe(true);
    expect(result.mapErr((e) => e.type).unwrapErr()).toBe("INVALID_AMOUNT");
  });
});
```

#### 4.3.2 統合テスト

```typescript
// API関数のテスト例
describe("fetchUserBalance", () => {
  test("successful API call returns Ok", async () => {
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ balance: 1000 }),
    });

    const result = await fetchUserBalance("user-123");
    expect(result.isOk()).toBe(true);
    expect(result.unwrapOr(0)).toBe(1000);
  });

  test("failed API call returns Err", async () => {
    mockFetch.mockRejectedValueOnce(new Error("Network error"));

    const result = await fetchUserBalance("user-123");
    expect(result.isErr()).toBe(true);
    expect(result.mapErr((e) => e.type).unwrapErr()).toBe("NETWORK_ERROR");
  });
});
```

## 5. トラブルシューティング

### 5.1 よくある問題と解決策

#### 問題1: 型エラーが頻発する

**原因**: Result型とPromise型の混在
**解決策**: ResultAsyncを適切に使用し、型定義を見直す

#### 問題2: パフォーマンスが低下する

**原因**: 不要なResultオブジェクトの生成
**解決策**: 適切な場所でのResult使用、メモ化の検討

#### 問題3: 既存コードとの統合が困難

**原因**: 移行戦略の不備
**解決策**: アダプター関数の活用、段階的移行の徹底

### 5.2 デバッグ手法

#### Result型のデバッグ

```typescript
// デバッグ用ユーティリティ
function debugResult<T, E>(result: Result<T, E>, label: string): Result<T, E> {
  result.match(
    (value) => console.log(`${label} - Ok:`, value),
    (error) => console.log(`${label} - Err:`, error),
  );
  return result;
}

// 使用例
const result = validateAmount(input)
  .map(debugResult("after validation"))
  .andThen(processAmount)
  .map(debugResult("after processing"));
```

## 6. リファレンス

### 6.1 neverthrow公式ドキュメント

- [GitHub Repository](https://github.com/supermacro/neverthrow)
- [NPM Package](https://www.npmjs.com/package/neverthrow)

### 6.2 関連する型定義

- `Result<T, E>`: 成功時T、失敗時Eの結果型
- `ResultAsync<T, E>`: 非同期版のResult型
- `Ok<T>`: 成功を表すResult型
- `Err<E>`: 失敗を表すResult型

### 6.3 主要メソッド一覧

- `ok(value)`: 成功のResultを作成
- `err(error)`: 失敗のResultを作成
- `map(fn)`: 成功値を変換
- `mapErr(fn)`: エラー値を変換
- `andThen(fn)`: 成功時に別のResultを返す関数を実行
- `match(okFn, errFn)`: 成功・失敗の両方を処理
- `unwrapOr(defaultValue)`: 値を取得（失敗時はデフォルト値）

---

**最終更新**: 2025/01/25
**作成者**: Development Team
**レビュー者**: [未定]
</file>

<file path="docs/architecture/overview.md">
# Eco Wallet アーキテクチャ概要

## バーティカルスライスアーキテクチャ

Eco Walletは、機能単位でコードを組織化するバーティカルスライスアーキテクチャを採用しています。各機能（feature）は独立したモジュールとして実装され、明確に定義された公開APIを持ちます。

## ディレクトリ構造

```
src/
├── app/                      # Next.jsのルートレイアウトとページ
├── components/
│   └── ui/                   # 共通UIコンポーネント（shadcn/ui）
├── features/                 # 機能モジュール（17個）
├── lib/                      # 共通ライブラリ・ユーティリティ
├── services/                 # API・モックサービス
├── shared/                   # 機能間で共有されるコード
└── types/                    # グローバル型定義
```

## Feature モジュール一覧（17個）

### 1. **auth** - 認証機能

- ユーザー認証（ログイン、ログアウト、パスワードリセット）
- 認証フォームコンポーネント
- 認証フックとユーティリティ

### 2. **balance** - 残高表示機能

- 通常残高・キャンペーン残高の表示
- 残高カードコンポーネント
- 残高の状態管理

### 3. **campaigns** - キャンペーン機能

- キャンペーン情報の表示
- キャンペーンカード・バナー
- キャンペーン特典の管理

### 4. **charge** - チャージ機能

- 残高へのチャージ
- 銀行振込・カード決済対応
- チャージフロー（入力→確認→完了）

### 5. **donation** - 寄付機能

- 環境保全プロジェクトへの寄付
- 寄付フロー（選択→入力→確認→完了）
- プロジェクト情報表示

### 6. **eco-impact** - 環境貢献機能

- CO2削減量・環境貢献度の表示
- 環境インパクトの可視化
- 環境貢献サマリー

### 7. **eco-news** - エコニュース機能

- 環境関連ニュースの表示
- ニュース記事の詳細表示
- カテゴリ別フィルタリング

### 8. **invite** - 招待機能

- 友達招待機能
- QRコード・招待リンク生成
- ソーシャルシェア機能

### 9. **layout** - レイアウト共通コンポーネント

- アプリケーション共通レイアウト
- ヘッダー・フッター
- ページコンテナ

### 10. **notifications** - 通知機能

- 通知の表示・管理
- 通知バッジ
- 通知の既読管理

### 11. **payment** - 決済機能

- 店舗での決済処理
- 決済方法の選択
- 決済サマリー表示

### 12. **qrcode** - QRコード機能

- QRコード生成・表示
- QRコード読み取り
- 決済用QRコード管理

### 13. **settings** - 設定機能

- ユーザー設定管理
- プロフィール・通知・セキュリティ設定
- 環境設定（寄付比率など）

### 14. **splash** - スプラッシュ画面機能

- アプリ起動時のスプラッシュ画面
- 初期化処理の表示
- ブランドロゴ表示

### 15. **transactions** - 取引履歴・詳細表示機能

- 取引履歴の表示・フィルタリング
- 取引詳細情報
- レシート表示

### 16. **transfer** - 送金・割り勘機能

- 個人間送金
- 割り勘計算・リクエスト
- 送金履歴管理

### 17. **eco-news** - エコニュース機能

- 環境関連ニュースの配信
- ニュース詳細表示
- カテゴリ管理

## Feature モジュールの構成

各featureモジュールは以下の構造を持ちます：

```
features/[feature-name]/
├── components/       # UIコンポーネント
├── hooks/           # カスタムフック
├── store/           # 状態管理（必要な場合）
├── types/           # 型定義
├── utils/           # ユーティリティ関数
├── data/            # モックデータ（必要な場合）
├── index.ts         # 公開API
└── README.md        # 機能の説明
```

## 設計原則

### 1. **機能の独立性**

- 各featureは独立して動作可能
- 明確な責任範囲
- 最小限の依存関係

### 2. **明確な公開API**

- `index.ts`で公開するコンポーネント・型を明示
- 内部実装の隠蔽
- バージョン管理の容易さ

### 3. **再利用性**

- 共通コンポーネントは`components/ui/`に配置
- 共通ユーティリティは`shared/`に配置
- 型定義の適切な共有

### 4. **テスタビリティ**

- 各コンポーネントは独立してテスト可能
- モックデータの活用
- 副作用の最小化

## 技術スタック

- **フレームワーク**: Next.js 14 (App Router)
- **UI ライブラリ**: React 18
- **スタイリング**: Tailwind CSS
- **コンポーネント**: shadcn/ui
- **状態管理**: Redux Toolkit
- **型定義**: TypeScript
- **アイコン**: Lucide React

## 開発ガイドライン

新しい機能を追加する際は、`docs/architecture/development-guide.md`を参照してください。
</file>

<file path="docs/design/design-guideline.md">
# Eco Wallet デザインガイドライン

## 1. ブランド概要

### 1.1 ブランドの理念

Eco Walletは、「シンプルで環境に優しい決済サービス」として、日常の金融活動を通じて環境保全に貢献できるプラットフォームです。パタゴニアの企業哲学「ビジネスを手段として環境危機に警鐘を鳴らし、解決に向けて実行する」を基盤としています。

### 1.2 ブランドの価値観

- **シンプルさ**: 必要な機能を余計な装飾なく提供
- **機能性**: ユーザーが求める機能を直感的に使える設計
- **環境への配慮**: 全ての機能に環境保全の要素を組み込む
- **透明性**: 取引や環境貢献の詳細を明確に表示
- **持続可能性**: 長期的な環境保全を促進するデザイン

### 1.3 ターゲットユーザー

- 環境保全に関心がある金融サービスユーザー
- アウトドア活動や自然を愛する人々
- シンプルで機能的なデジタルサービスを好む人々
- 自分の消費行動が社会や環境に与える影響を考慮する人々

## 2. ビジュアルデザイン要素

### 2.1 カラーパレット

#### プライマリーカラー

- **ティール (Teal)**: #0F766E
  - 使用場所: ヘッダー背景、主要ボタン、アクセント色
  - 意味: 環境、自然、信頼性を表現

#### セカンダリーカラー

- **ストーン (Stone)**: #78716C
  - 使用場所: テキスト、アイコン、セカンダリー要素
  - 意味: 大地、シンプルさ、安定感を表現

#### アクセントカラー

- **アンバー (Amber)**: #D97706
  - 使用場所: キャンペーン、特典情報
  - 意味: エネルギー、特別感を表現
- **ブルー (Blue)**: #2563EB
  - 使用場所: 入金、増加を示す要素
  - 意味: 信頼性、増加を表現
- **レッド (Red)**: #DC2626
  - 使用場所: エラー、警告、期限切れ情報
  - 意味: 注意喚起、重要性を表現
- **グリーン (Green)**: #16A34A
  - 使用場所: CO2削減など環境指標の表示
  - 意味: 成長、環境保全を表現

#### 背景色

- **ホワイト**: #FFFFFF
  - 使用場所: カード背景、メイン背景
- **ライトストーン**: #F5F5F4
  - 使用場所: ページ背景、セカンダリー背景
- **ライトティール**: #E0F2F1
  - 使用場所: 環境関連情報の背景
- **ライトアンバー**: #FEF3C7
  - 使用場所: キャンペーン情報の背景

### 2.2 タイポグラフィ

#### フォントファミリー

- **ヘッダー**: システムフォント、サンセリフ
- **本文**: システムフォント、サンセリフ

#### フォントサイズ

- **大見出し**: 24px (1.5rem)
- **中見出し**: 20px (1.25rem)
- **小見出し**: 16px (1rem)
- **本文**: 14px (0.875rem)
- **補足テキスト**: 12px (0.75rem)
- **極小テキスト**: 10px (0.625rem)

#### フォントウェイト

- **ボールド**: 700 - 見出しや強調テキスト
- **ミディアム**: 500 - 小見出しやラベル
- **レギュラー**: 400 - 本文やUI要素

### 2.3 アイコン

#### スタイル

- **線の太さ**: 2px
- **角の丸み**: 2px
- **サイズ**: 16px、20px、24px（コンテキストに応じて）

#### 主要アイコン

- **Leaf**: 環境貢献、エコ活動
- **ArrowUp/ArrowDown**: 支払い/入金
- **QrCode**: 決済、支払い
- **CreditCard**: 残高、カード
- **Gift**: 特典、キャンペーン
- **Clock**: 期限、タイムライン
- **Users**: グループ、割り勘
- **Send**: 送金

### 2.4 ロゴとブランドマーク

- **形状**: 山の形状をモチーフにしたシンプルなデザイン
- **カラー**: ティール (#0F766E)
- **最小サイズ**: 高さ32px
- **余白**: ロゴの高さの25%以上の余白を確保

## 3. コンポーネントデザイン

### 3.1 ボタン

#### プライマリーボタン

- **背景色**: ティール (#0F766E)
- **テキスト色**: ホワイト (#FFFFFF)
- **ホバー状態**: ダークティール (#0E6760)
- **サイズ**: 高さ40px、内部パディング左右16px
- **角の丸み**: 6px
- **使用場面**: 主要アクション（確定、送信など）

#### セカンダリーボタン

- **背景色**: 透明
- **ボーダー**: ストーン (#78716C) 1px
- **テキスト色**: ストーン (#78716C)
- **ホバー状態**: ライトストーン背景 (#F5F5F4)
- **使用場面**: 補助的アクション（キャンセル、戻るなど）

#### テキストボタン

- **背景色**: 透明
- **テキスト色**: ティール (#0F766E)
- **ホバー状態**: ライトティール背景 (#E0F2F1)
- **使用場面**: リンク、詳細表示など

#### 環境アクションボタン

- **背景色**: ティール (#0F766E)
- **テキスト色**: ホワイト (#FFFFFF)
- **アイコン**: Leaf
- **使用場面**: 環境に関連するアクション

#### キャンペーンボタン

- **背景色**: アンバー (#D97706)
- **テキスト色**: ホワイト (#FFFFFF)
- **使用場面**: キャンペーン関連アクション

### 3.2 カード

#### 標準カード

- **背景色**: ホワイト (#FFFFFF)
- **ボーダー**: なし
- **シャドウ**: 中程度 (0 4px 6px rgba(0, 0, 0, 0.1))
- **角の丸み**: 8px
- **パディング**: 16px

#### 環境情報カード

- **背景色**: ライトティール (#E0F2F1)
- **ボーダー**: ティール (#0F766E) 1px
- **角の丸み**: 8px

#### キャンペーンカード

- **背景色**: ライトアンバー (#FEF3C7)
- **ボーダー**: アンバー (#D97706) 1px
- **角の丸み**: 8px

### 3.3 フォーム要素

#### 入力フィールド

- **背景色**: ホワイト (#FFFFFF)
- **ボーダー**: ストーン (#78716C) 1px
- **フォーカス状態**: ティール (#0F766E) 2px
- **角の丸み**: 6px
- **高さ**: 40px
- **パディング**: 左右12px

#### スイッチ／トグル

- **オフ状態**: グレー (#D1D5DB)
- **オン状態**: ティール (#0F766E)
- **サイズ**: 幅36px、高さ20px

#### チェックボックス

- **チェック色**: ティール (#0F766E)
- **ボーダー**: ストーン (#78716C) 1px
- **サイズ**: 16px x 16px

#### ラジオボタン

- **選択色**: ティール (#0F766E)
- **ボーダー**: ストーン (#78716C) 1px
- **サイズ**: 16px x 16px

### 3.4 バッジとタグ

#### 環境貢献バッジ

- **背景色**: ライトティール (#E0F2F1)
- **テキスト色**: ダークティール (#0E6760)
- **アイコン**: Leaf
- **角の丸み**: 9999px（完全な丸み）

#### キャンペーンバッジ

- **背景色**: ライトアンバー (#FEF3C7)
- **テキスト色**: ダークアンバー (#B45309)
- **アイコン**: Gift
- **角の丸み**: 9999px（完全な丸み）

#### 警告バッジ

- **背景色**: ライトレッド (#FEE2E2)
- **テキスト色**: ダークレッド (#B91C1C)
- **アイコン**: AlertCircle
- **角の丸み**: 9999px（完全な丸み）

### 3.5 アバター

- **サイズ**: 32px、40px、48px（コンテキストに応じて）
- **形状**: 円形
- **フォールバック背景**: 薄いブランドカラー
- **フォールバックテキスト**: ユーザー名の頭文字

## 4. レイアウトシステム

### 4.1 グリッドシステム

- **コンテナ最大幅**: 768px（モバイルファースト）
- **ガター**: 16px（要素間の間隔）
- **マージン**: 16px（画面端からの余白）

### 4.2 スペーシング

- **xs**: 4px
- **sm**: 8px
- **md**: 16px
- **lg**: 24px
- **xl**: 32px
- **2xl**: 48px

### 4.3 階層構造

- **Z-index 1**: 通常コンテンツ
- **Z-index 10**: 固定ヘッダー、フッター
- **Z-index 100**: モーダル、ポップオーバー
- **Z-index 1000**: 通知、トースト

## 5. 特殊要素デザイン

### 5.1 環境貢献要素

#### 環境インパクト表示

- 森林保全、水資源保全、CO2削減などの指標を視覚的に表示
- プログレスバーで目標達成度を表示
- ティールを基調とした配色
- リーフアイコンを使用

#### 環境貢献サマリー

- 累計寄付額
- 具体的な環境貢献数値（面積、量など）
- バックグラウンド: ライトティール (#E0F2F1)

### 5.2 残高表示要素

#### 通常残高

- **背景色**: ライトストーン (#F5F5F4)
- **アイコン**: CreditCard
- **ラベル**: 「通常残高」

#### キャンペーン残高

- **背景色**: ライトアンバー (#FEF3C7)
- **ボーダー**: アンバー (#D97706) 1px
- **アイコン**: Gift
- **追加情報**: 期限日数、有効期限日、利用条件
- **期限表示**: Clock アイコン + 残り日数

### 5.3 取引履歴要素

#### 入金取引

- **アイコン背景**: ライトブルー (#EFF6FF)
- **アイコン**: ArrowDown
- **アイコン色**: ブルー (#2563EB)
- **金額表示**: 「+¥」でプラス表示
- **金額色**: ブルー (#2563EB)

#### 支払取引

- **アイコン背景**: ライトストーン (#F5F5F4)
- **アイコン**: ArrowUp
- **アイコン色**: ストーン (#78716C)
- **金額表示**: 「-¥」でマイナス表示
- **金額色**: ストーン (#78716C)

#### 特典取引

- **アイコン背景**: ライトアンバー (#FEF3C7)
- **アイコン**: Gift
- **アイコン色**: アンバー (#D97706)
- **金額表示**: 「+¥」でプラス表示
- **金額色**: アンバー (#D97706)
- **追加情報**: キャンペーン名、有効期限

#### 期限切れ取引

- **アイコン背景**: ライトレッド (#FEE2E2)
- **アイコン**: Clock
- **アイコン色**: レッド (#DC2626)
- **金額表示**: 「-¥」でマイナス表示
- **金額色**: レッド (#DC2626)
- **追加情報**: キャンペーン名

#### 複数残高使用表示

- 取引内に折りたたみ式で表示
- 残高タイプごとに使用額を表示
- キャンペーン残高はアンバー色で強調

### 5.4 キャンペーン要素

#### アクティブキャンペーン表示

- **背景**: グラデーション（アンバー）
- **アイコン**: Zap または Gift
- **アクション**: キャンペーン詳細へのリンク
- **表示場所**: ダッシュボード、取引履歴画面

#### キャンペーン詳細

- キャンペーン名
- 期間
- 特典内容
- 条件
- 視覚的な残り時間表示

## 6. 画面別デザインガイドライン

### 6.1 ホーム/ダッシュボード画面

#### ヘッダー

- ブランドロゴ
- アカウントアイコン
- 通知ベル

#### 残高カード

- 総残高を目立つように表示
- チャージボタン
- 主要アクション（支払い、送金、割り勘、カード）へのクイックアクセス

#### 環境インパクト概要

- 環境貢献指標を視覚的に表示
- 目標達成度プログレスバー
- 詳細へのリンク

#### 取引履歴セクション

- 最新3〜4件の取引を表示
- 取引タイプごとに異なるアイコンと色
- 「すべて見る」へのリンク

#### キャンペーン情報

- 最新のキャンペーン情報
- 視覚的に目立つデザイン
- アクションボタン

#### フッターナビゲーション

- ホーム、支払い、環境、取引、アカウントへのリンク
- 現在のページを強調表示

### 6.2 取引履歴画面

#### 残高セクション

- 総残高と残高内訳（通常、キャンペーン別）
- キャンペーン残高には期限表示
- 環境貢献サマリー

#### フィルターオプション

- タブで取引種類をフィルタリング（すべて、入金、支払い、特典、環境貢献）
- 期間、絞り込み機能

#### 取引リスト

- 取引ごとにカード形式で表示
- 取引種類に応じたアイコンと色
- 詳細情報（環境貢献、複数残高使用、キャンペーン）は折りたたみ式
- 「もっと見る」ボタン

#### キャンペーン情報

- アクティブなキャンペーンを強調表示
- キャンペーン詳細へのリンク

### 6.3 チャージ/決済画面

#### 金額入力

- 大きく見やすい入力フィールド
- おすすめ金額のクイックボタン
- 入力額に応じた環境貢献額の表示

#### 支払い方法選択

- 利用可能な残高の表示
- 決済方法の選択肢（Eco Wallet残高、カードなど）
- 環境に優しい決済方法の強調

#### 環境オプション

- 環境保全寄付のオプション（スイッチ）
- 紙のレシート辞退オプション（チェックボックス）
- 選択による環境インパクトの表示

#### 確認セクション

- 金額内訳（小計、環境保全負担金など）
- 合計金額
- 決済確定/キャンセルボタン

### 6.4 環境インパクト詳細画面

#### ヘッダー

- 総貢献額
- シェアボタン

#### データビジュアライゼーション

- 環境指標ごとのプログレスバー
- 目標達成度
- 視覚的に分かりやすいアイコン

#### タブ

- インパクト、プロジェクト、活動履歴の切り替え

#### プロジェクト表示

- プロジェクト画像
- 進捗状況
- 寄付ボタン

#### 活動タイムライン

- 時系列での環境貢献活動
- 活動ごとの環境インパクト詳細

### 6.5 QRコード/バーコード決済画面

#### コード表示

- 大きく見やすいQRコード/バーコード
- 有効期限カウントダウン
- セキュリティコード

#### 環境貢献情報

- 環境保全オプション有効の表示
- 具体的な寄付先プロジェクト

#### 追加機能

- 取引履歴、近くの店舗、ヘルプへのリンク
- 紙のレシート削減メッセージ

### 6.6 アカウント設定/プロフィール画面

#### プロフィールカード

- ユーザーアバター
- 基本情報
- 環境貢献ステータス

#### 設定タブ

- プロフィール、環境設定、通知、支払い、セキュリティ

#### 環境設定セクション

- 環境貢献の優先順位設定
- 寄付比率設定
- 電子レシート設定

### 6.7 送金/分割支払い画面

#### 送金タブ

- 送金先選択
- 金額入力
- メッセージ入力
- 環境保全オプション

#### 割り勘タブ

- タイトル、合計金額入力
- 参加者追加と金額配分
- 均等分割機能
- 送金方法選択

## 7. アクセシビリティガイドライン

### 7.1 色のコントラスト

- テキストと背景のコントラスト比は最低4.5:1以上
- 小さなテキストやアイコンは7:1以上のコントラスト比を推奨

### 7.2 テキストサイズと読みやすさ

- 最小テキストサイズは12px
- 重要な情報は14px以上
- 行間は文字サイズの1.5倍以上

### 7.3 フォーカス状態

- キーボード操作時の明確なフォーカス表示
- フォーカス状態はティール (#0F766E) の2pxボーダー

### 7.4 アイコンとラベル

- アイコン単独ではなく、テキストラベルと併用
- アイコンには適切なalt textを設定

## 8. レスポンシブデザイン

### 8.1 ブレークポイント

- **モバイル**: 320px - 639px
- **タブレット**: 640px - 1023px
- **デスクトップ**: 1024px以上

### 8.2 モバイル対応

- シングルカラムレイアウト
- タッチターゲットは最低44px × 44px
- フッターナビゲーションによる主要機能へのアクセス

### 8.3 タブレット/デスクトップ対応

- マルチカラムレイアウト
- サイドナビゲーション
- ホバー状態の活用

## 9. アニメーションとトランジション

### 9.1 トランジション

- **デュレーション**: 200ms - 300ms
- **イージング**: ease-in-outまたはcubic-bezier(0.4, 0, 0.2, 1)
- **対象要素**: ボタン、スイッチ、タブ、エキスパンダブル要素

### 9.2 フィードバックアニメーション

- ボタンクリック時の軽微なスケール変更
- 送金・決済完了時の成功アニメーション
- エラー時の軽微な振動アニメーション

## 10. 実装ガイドライン

### 10.1 コンポーネントライブラリ

- shadcn/ui コンポーネントの活用
- Tailwind CSSクラスの一貫した使用

### 10.2 アイコンライブラリ

- Lucide React アイコンセットの使用
- アイコンサイズの統一（16px, 20px, 24px）

### 10.3 開発環境

- React + Next.js
- TypeScriptでの型定義
- コンポーネントの再利用性を重視

### 10.4 パフォーマンス考慮事項

- 画像の最適化
- コンポーネントの遅延ロード
- モバイルでのパフォーマンス優先
</file>

<file path="src/app/auth/register-success/page.tsx">
"use client";

import Link from "next/link";
import { Suspense } from "react"; // Suspenseをインポート
import { AuthLayout } from "@/features/layout";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { CheckCircle, Leaf, Mail, ArrowRight } from "lucide-react";
import { useSearchParams } from "next/navigation";

function RegisterSuccessContent() {
  // クエリパラメータからメールアドレスを取得（セキュリティのため短時間しか保持しない）
  const searchParams = useSearchParams();
  const email = searchParams.get("email") || "登録したメールアドレス";

  return (
    <div className="flex flex-col items-center space-y-6">
      <div className="w-20 h-20 bg-teal-50 rounded-full flex items-center justify-center border-2 border-teal-100">
        <CheckCircle className="h-10 w-10 text-teal-700" />
      </div>

      <div className="text-center space-y-2">
        <h2 className="text-xl font-semibold text-stone-800">
          アカウント登録が完了しました
        </h2>
        <p className="text-sm text-stone-600">
          {email} 宛に確認メールを送信しました。
          <br />
          メールに記載されたリンクをクリックして、アカウントを有効化してください。
        </p>
      </div>

      <Card className="border-0 shadow-md bg-stone-50 p-4 w-full">
        <div className="flex items-start space-x-3">
          <Mail className="h-5 w-5 text-stone-600 mt-0.5" />
          <div className="text-sm text-stone-600">
            <p className="font-medium">確認メールが届かない場合：</p>
            <ul className="list-disc list-inside mt-1 text-xs space-y-1">
              <li>迷惑メールフォルダをご確認ください</li>
              <li>
                数分経っても届かない場合は、再度登録を試みるか、サポートまでお問い合わせください
              </li>
            </ul>
          </div>
        </div>
      </Card>

      <div className="bg-teal-50 border border-teal-100 rounded-md p-4 w-full">
        <div className="flex items-start space-x-3">
          <Leaf className="h-5 w-5 text-teal-700 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-teal-800">
              環境貢献の第一歩
            </p>
            <p className="text-xs text-teal-700 mt-1">
              Eco
              Walletへの登録により、ペーパーレス決済を通じて年間約500gの紙資源を節約できます。あなたの環境貢献活動はすでに始まっています。
            </p>
          </div>
        </div>
      </div>

      <Link href="/auth/login" className="w-full">
        <Button className="w-full bg-teal-700 hover:bg-teal-800 text-white">
          ログイン画面へ
          <ArrowRight className="h-4 w-4 ml-2" />
        </Button>
      </Link>

      <div className="text-center text-xs text-stone-500 mt-4">
        お客様の購入ごとに、売上の1%を環境保護団体に寄付しています
      </div>
    </div>
  );
}

// フォールバックコンポーネント（ローディング状態を表示）
function RegisterSuccessLoading() {
  return <div>ロード中...</div>;
}

export default function RegisterSuccessPage() {
  return (
    <AuthLayout title="登録完了" subtitle="シンプルで環境に優しい決済サービス">
      <Suspense fallback={<RegisterSuccessLoading />}>
        <RegisterSuccessContent />
      </Suspense>
    </AuthLayout>
  );
}
</file>

<file path="src/app/impact/page.tsx">
"use client";

import { useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import {
  Leaf,
  TreePine,
  Droplets,
  Globe,
  ArrowRight,
  Calendar,
  Share2,
  Medal,
  Target,
  TrendingUp,
  Info,
  ExternalLink,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { PageContainer } from "@/features/layout/components/PageContainer";

interface ImpactMetric {
  id: string;
  icon: React.ElementType;
  label: string;
  value: string;
  target: string;
  progress: number;
  color: string;
  bgColor: string;
  unit: string;
}

const impactMetrics: ImpactMetric[] = [
  {
    id: "forest",
    icon: TreePine,
    label: "保全された森林",
    value: "5.2",
    target: "10",
    progress: 52,
    color: "text-teal-600",
    bgColor: "bg-teal-50",
    unit: "m²",
  },
  {
    id: "water",
    icon: Droplets,
    label: "浄化された水資源",
    value: "450",
    target: "1,500",
    progress: 30,
    color: "text-blue-600",
    bgColor: "bg-blue-50",
    unit: "L",
  },
  {
    id: "co2",
    icon: Globe,
    label: "CO2削減量",
    value: "25",
    target: "100",
    progress: 25,
    color: "text-green-600",
    bgColor: "bg-green-50",
    unit: "kg",
  },
];

export default function EcoImpactPage() {
  const [selectedPeriod, setSelectedPeriod] = useState("month");

  return (
    <PageContainer>
      <div className="w-full max-w-md mx-auto space-y-4">
        {/* メインカード */}
        <Card className="border-0 shadow-lg bg-white overflow-hidden">
          {/* ヘッダー：グラデーション背景 */}
          <div className="bg-gradient-to-br from-teal-700 to-teal-600 text-white p-6">
            <div className="flex justify-between items-start mb-4">
              <div>
                <h2 className="text-xl font-semibold mb-1">環境インパクト</h2>
                <p className="text-sm text-teal-50">2025年4月の活動状況</p>
              </div>
              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
              >
                <Share2 className="h-4 w-4" />
              </Button>
            </div>

            {/* 統計サマリー */}
            <div className="grid grid-cols-2 gap-4">
              <div className="bg-white/10 backdrop-blur-sm rounded-lg p-3">
                <p className="text-xs text-teal-50 mb-1">総貢献額</p>
                <p className="text-2xl font-bold">¥12,450</p>
              </div>
              <div className="bg-white/10 backdrop-blur-sm rounded-lg p-3">
                <p className="text-xs text-teal-50 mb-1">環境ランク</p>
                <div className="flex items-center gap-1">
                  <Medal className="h-4 w-4 text-amber-300" />
                  <p className="text-lg font-semibold">エコマイスター</p>
                </div>
              </div>
            </div>
          </div>

          <CardContent className="p-0">
            <Tabs defaultValue="impact" className="w-full">
              <TabsList className="grid grid-cols-3 bg-stone-50 rounded-none border-b border-stone-200 h-12">
                <TabsTrigger
                  value="impact"
                  className="text-sm font-medium rounded-none data-[state=active]:bg-white data-[state=active]:border-b-2 data-[state=active]:border-teal-600 data-[state=active]:text-teal-700"
                >
                  インパクト
                </TabsTrigger>
                <TabsTrigger
                  value="projects"
                  className="text-sm font-medium rounded-none data-[state=active]:bg-white data-[state=active]:border-b-2 data-[state=active]:border-teal-600 data-[state=active]:text-teal-700"
                >
                  プロジェクト
                </TabsTrigger>
                <TabsTrigger
                  value="activity"
                  className="text-sm font-medium rounded-none data-[state=active]:bg-white data-[state=active]:border-b-2 data-[state=active]:border-teal-600 data-[state=active]:text-teal-700"
                >
                  活動履歴
                </TabsTrigger>
              </TabsList>

              {/* インパクトタブ */}
              <TabsContent value="impact" className="p-4 space-y-4">
                {/* 期間選択 */}
                <div className="flex gap-2 justify-center">
                  {["week", "month", "year"].map((period) => (
                    <Button
                      key={period}
                      variant={
                        selectedPeriod === period ? "default" : "outline"
                      }
                      size="sm"
                      onClick={() => setSelectedPeriod(period)}
                      className={
                        selectedPeriod === period
                          ? "bg-teal-600 hover:bg-teal-700 text-white"
                          : "border-stone-200 hover:border-stone-300"
                      }
                    >
                      {period === "week" && "週間"}
                      {period === "month" && "月間"}
                      {period === "year" && "年間"}
                    </Button>
                  ))}
                </div>

                {/* 環境指標 */}
                <div className="space-y-3">
                  {impactMetrics.map((metric) => {
                    const Icon = metric.icon;
                    return (
                      <div
                        key={metric.id}
                        className="bg-white rounded-lg border border-stone-100 p-4 hover:border-stone-200 hover:shadow-sm transition-all duration-200"
                      >
                        <div className="flex items-start justify-between mb-3">
                          <div className="flex items-center gap-3">
                            <div className={`${metric.bgColor} p-2 rounded-lg`}>
                              <Icon className={`h-5 w-5 ${metric.color}`} />
                            </div>
                            <div>
                              <h4 className="text-sm font-medium text-stone-800">
                                {metric.label}
                              </h4>
                              <p
                                className={`text-xs ${metric.color} font-medium mt-0.5`}
                              >
                                目標達成率 {metric.progress}%
                              </p>
                            </div>
                          </div>
                          <div className="text-right">
                            <p className="text-xl font-bold text-stone-900">
                              {metric.value}
                              <span className="text-sm font-normal text-stone-500 ml-1">
                                {metric.unit}
                              </span>
                            </p>
                            <p className="text-xs text-stone-500">
                              / {metric.target}
                              {metric.unit}
                            </p>
                          </div>
                        </div>
                        <div className="space-y-1">
                          <Progress
                            value={metric.progress}
                            className={`h-2 bg-stone-100 ${
                              metric.id === "forest"
                                ? ""
                                : metric.id === "water"
                                  ? "bg-blue-500"
                                  : "bg-green-600"
                            }`}
                          />
                          <div className="flex justify-between text-xs">
                            <span className="text-stone-500">0</span>
                            <span className={`${metric.color} font-medium`}>
                              {metric.value}
                              {metric.unit}
                            </span>
                            <span className="text-stone-500">
                              {metric.target}
                              {metric.unit}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>

                {/* 環境貢献の詳細 */}
                <div className="bg-teal-50 border border-teal-100 rounded-lg p-4">
                  <h3 className="text-sm font-medium text-teal-800 mb-3 flex items-center">
                    <Info className="h-4 w-4 mr-2" />
                    あなたの貢献による実際の効果
                  </h3>
                  <div className="space-y-2">
                    <div className="flex items-start gap-2">
                      <div className="mt-0.5 w-5 h-5 rounded-full bg-teal-600 flex items-center justify-center flex-shrink-0">
                        <Leaf className="h-3 w-3 text-white" />
                      </div>
                      <p className="text-xs text-teal-700 leading-relaxed">
                        5.2m²の森林保全により、年間約62kgのCO2を吸収し、10種類の在来種の生息地を守っています
                      </p>
                    </div>
                    <div className="flex items-start gap-2">
                      <div className="mt-0.5 w-5 h-5 rounded-full bg-teal-600 flex items-center justify-center flex-shrink-0">
                        <Leaf className="h-3 w-3 text-white" />
                      </div>
                      <p className="text-xs text-teal-700 leading-relaxed">
                        450Lの水資源浄化は、約225人が1日に使用する飲料水に相当します
                      </p>
                    </div>
                    <div className="flex items-start gap-2">
                      <div className="mt-0.5 w-5 h-5 rounded-full bg-teal-600 flex items-center justify-center flex-shrink-0">
                        <Leaf className="h-3 w-3 text-white" />
                      </div>
                      <p className="text-xs text-teal-700 leading-relaxed">
                        25kgのCO2削減は、ガソリン車で約100km走行時の排出量に相当します
                      </p>
                    </div>
                  </div>
                </div>

                {/* 次のアクション */}
                <div className="bg-amber-50 border border-amber-100 rounded-lg p-4">
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <h3 className="text-sm font-medium text-amber-800 flex items-center mb-1">
                        <Target className="h-4 w-4 mr-2" />
                        目標達成まであと少し！
                      </h3>
                      <p className="text-xs text-amber-700">
                        環境貢献率を1%から3%に増やすと、年間の森林保全面積が約3倍になります
                      </p>
                    </div>
                    <Button
                      size="sm"
                      className="bg-amber-600 hover:bg-amber-700 text-white ml-3"
                    >
                      設定変更
                    </Button>
                  </div>
                </div>
              </TabsContent>

              {/* プロジェクトタブ */}
              <TabsContent value="projects" className="p-4 space-y-4">
                {/* プロジェクトカード */}
                {[
                  {
                    id: 1,
                    title: "山岳環境保全プロジェクト",
                    description: "登山道の整備や森林再生を通じて山岳環境を保全",
                    icon: TreePine,
                    amount: 4500,
                    target: 10000,
                    color: "teal",
                    gradient: "from-teal-600 to-teal-500",
                  },
                  {
                    id: 2,
                    title: "海洋プラスチック削減",
                    description: "海岸清掃と海洋生態系の保護活動",
                    icon: Droplets,
                    amount: 7950,
                    target: 15000,
                    color: "blue",
                    gradient: "from-blue-600 to-blue-500",
                  },
                  {
                    id: 3,
                    title: "都市緑化プロジェクト",
                    description: "都市部の緑地拡大と生物多様性の促進",
                    icon: Leaf,
                    amount: 3200,
                    target: 8000,
                    color: "green",
                    gradient: "from-green-600 to-green-500",
                  },
                ].map((project) => {
                  const Icon = project.icon;
                  const progress = (project.amount / project.target) * 100;

                  return (
                    <div
                      key={project.id}
                      className="bg-white rounded-lg border border-stone-100 overflow-hidden hover:border-stone-200 hover:shadow-md transition-all duration-200"
                    >
                      <div
                        className={`h-32 bg-gradient-to-br ${project.gradient} relative overflow-hidden`}
                      >
                        <div className="absolute inset-0 flex items-center justify-center">
                          <Icon className="h-20 w-20 text-white opacity-20" />
                        </div>
                        <div className="absolute top-3 right-3">
                          <Badge className="bg-white/20 backdrop-blur-sm text-white border-0">
                            進行中
                          </Badge>
                        </div>
                      </div>
                      <div className="p-4">
                        <h3 className="text-sm font-semibold text-stone-800 mb-1">
                          {project.title}
                        </h3>
                        <p className="text-xs text-stone-600 mb-3">
                          {project.description}
                        </p>
                        <div className="space-y-2">
                          <div className="flex justify-between items-center text-xs">
                            <span
                              className={`text-${project.color}-600 font-semibold`}
                            >
                              ¥{project.amount.toLocaleString()}
                            </span>
                            <span className="text-stone-500">
                              目標: ¥{project.target.toLocaleString()}
                            </span>
                          </div>
                          <Progress
                            value={progress}
                            className={`h-1.5 bg-stone-100 ${
                              project.color === "teal"
                                ? ""
                                : project.color === "blue"
                                  ? "bg-blue-500"
                                  : "bg-green-600"
                            }`}
                          />
                          <div className="flex justify-between items-center">
                            <span className="text-xs text-stone-500">
                              達成率 {Math.round(progress)}%
                            </span>
                            <Button
                              variant="ghost"
                              size="sm"
                              className={`text-xs text-${project.color}-600 hover:text-${project.color}-700 hover:bg-${project.color}-50 h-7 px-2`}
                            >
                              詳細 <ExternalLink className="h-3 w-3 ml-1" />
                            </Button>
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}

                <Button
                  variant="outline"
                  className="w-full border-teal-200 text-teal-700 hover:bg-teal-50"
                >
                  すべてのプロジェクトを見る
                  <ArrowRight className="h-4 w-4 ml-2" />
                </Button>
              </TabsContent>

              {/* 活動履歴タブ */}
              <TabsContent value="activity" className="p-4 space-y-4">
                <div className="flex justify-between items-center mb-2">
                  <h3 className="text-sm font-medium text-stone-800">
                    環境貢献活動
                  </h3>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 text-xs text-stone-600"
                  >
                    <Calendar className="h-3 w-3 mr-1" />
                    期間を選択
                  </Button>
                </div>

                {/* タイムライン */}
                <div className="relative">
                  {[
                    {
                      date: "2025/04/19",
                      title: "エコ製品定期プラン",
                      description: "環境に配慮した製品の定期購入",
                      amount: 200,
                      impact: "CO2削減: 3.2kg",
                      type: "eco",
                    },
                    {
                      date: "2025/04/15",
                      title: "レジ袋辞退",
                      description: "5回のレジ袋辞退",
                      impact: "プラスチック削減: 25g",
                      type: "action",
                    },
                    {
                      date: "2025/04/10",
                      title: "オーガニックコットン購入",
                      description: "環境配慮型商品の購入",
                      amount: 150,
                      impact: "森林保全: 0.7m²",
                      type: "eco",
                    },
                    {
                      date: "2025/04/05",
                      title: "リサイクル商品購入",
                      description: "リサイクル素材使用商品",
                      amount: 500,
                      impact: "プラスチック削減: 1.2kg",
                      type: "eco",
                    },
                  ].map((activity, index) => (
                    <div key={index} className="flex gap-3 pb-4">
                      {/* タイムラインライン */}
                      <div className="relative">
                        <div
                          className={`w-10 h-10 rounded-full flex items-center justify-center ${
                            activity.type === "eco"
                              ? "bg-teal-100"
                              : "bg-stone-100"
                          }`}
                        >
                          <Leaf
                            className={`h-5 w-5 ${
                              activity.type === "eco"
                                ? "text-teal-600"
                                : "text-stone-600"
                            }`}
                          />
                        </div>
                        {index < 3 && (
                          <div className="absolute top-10 left-5 w-0.5 h-full bg-stone-200" />
                        )}
                      </div>

                      {/* コンテンツ */}
                      <div className="flex-1">
                        <div className="bg-white rounded-lg border border-stone-100 p-3 hover:border-stone-200 hover:shadow-sm transition-all duration-200">
                          <div className="flex justify-between items-start mb-1">
                            <h4 className="text-sm font-medium text-stone-800">
                              {activity.title}
                            </h4>
                            <span className="text-xs text-stone-500">
                              {activity.date}
                            </span>
                          </div>
                          <p className="text-xs text-stone-600 mb-2">
                            {activity.description}
                          </p>
                          {activity.amount && (
                            <p className="text-sm font-semibold text-teal-600 mb-1">
                              寄付額: ¥{activity.amount}
                            </p>
                          )}
                          <div className="flex items-center gap-1">
                            <TrendingUp className="h-3 w-3 text-green-600" />
                            <span className="text-xs text-green-600 font-medium">
                              {activity.impact}
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>

                <Button
                  variant="outline"
                  className="w-full border-stone-200 hover:bg-stone-50"
                >
                  すべての活動を見る
                </Button>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        {/* ランクアップ促進カード */}
        <Card className="border-0 shadow-md bg-gradient-to-r from-amber-50 to-orange-50">
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="bg-amber-100 p-2 rounded-lg">
                  <Medal className="h-5 w-5 text-amber-600" />
                </div>
                <div>
                  <h3 className="text-sm font-semibold text-stone-800">
                    次のランクまであと少し！
                  </h3>
                  <p className="text-xs text-stone-600">
                    エコチャンピオンまで残り¥2,550
                  </p>
                </div>
              </div>
              <Button
                size="sm"
                variant="ghost"
                className="text-amber-700 hover:text-amber-800 hover:bg-amber-100"
              >
                詳細
                <ArrowRight className="h-3 w-3 ml-1" />
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </PageContainer>
  );
}
</file>

<file path="src/app/qrcode/page.tsx">
import { QRCodePage } from "@/features/qrcode";

export default function QRCodePageRoute() {
  return <QRCodePage />;
}
</file>

<file path="src/app/splash/page.tsx">
import { SplashScreen } from "@/features/splash";

export default function SplashPage() {
  return <SplashScreen />;
}
</file>

<file path="src/components/ui/calendar.tsx">
"use client";

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md",
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100",
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  );
}

export { Calendar };
</file>

<file path="src/components/ui/dialog.tsx">
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};
</file>

<file path="src/components/ui/error-display.tsx">
import React, { useState } from "react";
import {
  AlertCircle,
  AlertTriangle,
  XCircle,
  Info,
  RefreshCw,
  ChevronDown,
  ChevronUp,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { AppError, ErrorSeverity } from "@/shared/types/errors";
import {
  getErrorMessage,
  getErrorSeverity,
  isRetryableError,
  formatValidationErrors,
  logError,
  createErrorContext,
} from "@/lib/utils/error-utils";
import { Button } from "@/components/ui/button";

interface ErrorDisplayProps {
  error: AppError | AppError[] | null;
  className?: string;
  showDetails?: boolean;
  onRetry?: () => void;
  retryLabel?: string;
  userId?: string;
  transactionId?: string;
  variant?: "inline" | "banner" | "modal";
  collapsible?: boolean;
}

interface ErrorItemProps {
  error: AppError;
  showDetails: boolean;
  onRetry?: () => void;
  retryLabel?: string;
  userId?: string;
  transactionId?: string;
  variant: "inline" | "banner" | "modal";
}

const severityConfig: Record<
  ErrorSeverity,
  {
    icon: React.ComponentType<{ className?: string }>;
    bgColor: string;
    textColor: string;
    borderColor: string;
    iconColor: string;
  }
> = {
  low: {
    icon: Info,
    bgColor: "bg-blue-50",
    textColor: "text-blue-700",
    borderColor: "border-blue-200",
    iconColor: "text-blue-500",
  },
  medium: {
    icon: AlertTriangle,
    bgColor: "bg-yellow-50",
    textColor: "text-yellow-700",
    borderColor: "border-yellow-200",
    iconColor: "text-yellow-500",
  },
  high: {
    icon: AlertCircle,
    bgColor: "bg-orange-50",
    textColor: "text-orange-700",
    borderColor: "border-orange-200",
    iconColor: "text-orange-500",
  },
  critical: {
    icon: XCircle,
    bgColor: "bg-red-50",
    textColor: "text-red-700",
    borderColor: "border-red-200",
    iconColor: "text-red-500",
  },
};

const variantStyles = {
  inline: "p-3 text-sm rounded-md",
  banner: "p-4 text-base rounded-lg",
  modal: "p-6 text-base rounded-xl",
};

function ErrorItem({
  error,
  showDetails,
  onRetry,
  retryLabel = "再試行",
  userId,
  transactionId,
  variant,
}: ErrorItemProps) {
  const [detailsExpanded, setDetailsExpanded] = useState(false);
  const severity = getErrorSeverity(error);
  const message = getErrorMessage(error);
  const canRetry = isRetryableError(error);
  const config = severityConfig[severity];
  const Icon = config.icon;

  // エラーをログ出力
  React.useEffect(() => {
    const context = createErrorContext(userId, transactionId);
    logError(error, context);
  }, [error, userId, transactionId]);

  return (
    <div
      className={cn(
        "flex flex-col border",
        config.bgColor,
        config.textColor,
        config.borderColor,
        variantStyles[variant],
      )}
    >
      <div className="flex items-start">
        <Icon
          className={cn(
            "flex-shrink-0 mt-0.5 mr-3",
            variant === "inline" ? "h-4 w-4" : "h-5 w-5",
            config.iconColor,
          )}
        />

        <div className="flex-1 min-w-0">
          <p className="font-medium break-words">{message}</p>

          {showDetails && (
            <button
              onClick={() => setDetailsExpanded(!detailsExpanded)}
              className={cn(
                "flex items-center mt-2 text-xs hover:underline focus:outline-none",
                config.textColor,
              )}
            >
              {detailsExpanded ? (
                <>
                  <ChevronUp className="h-3 w-3 mr-1" />
                  詳細を非表示
                </>
              ) : (
                <>
                  <ChevronDown className="h-3 w-3 mr-1" />
                  詳細を表示
                </>
              )}
            </button>
          )}
        </div>

        {canRetry && onRetry && (
          <Button
            onClick={onRetry}
            variant="outline"
            size={variant === "inline" ? "sm" : "default"}
            className={cn(
              "ml-3 flex-shrink-0",
              variant === "inline" && "h-8 px-3 text-xs",
            )}
          >
            <RefreshCw
              className={cn(
                variant === "inline" ? "h-3 w-3" : "h-4 w-4",
                "mr-1",
              )}
            />
            {retryLabel}
          </Button>
        )}
      </div>

      {showDetails && detailsExpanded && (
        <div
          className={cn(
            "mt-3 pt-3 border-t text-xs space-y-2",
            config.borderColor,
            "bg-white bg-opacity-50 -mx-3 -mb-3 px-3 pb-3 rounded-b-md",
          )}
        >
          <div>
            <span className="font-medium">エラータイプ:</span> {error.type}
          </div>
          <div>
            <span className="font-medium">重要度:</span>{" "}
            {severity.toUpperCase()}
          </div>
          {error.type === "INVALID_AMOUNT" &&
            "min" in error &&
            error.min !== undefined && (
              <div>
                <span className="font-medium">最小値:</span> {error.min}
              </div>
            )}
          {error.type === "INVALID_AMOUNT" &&
            "max" in error &&
            error.max !== undefined && (
              <div>
                <span className="font-medium">最大値:</span> {error.max}
              </div>
            )}
          {error.type === "SERVER_ERROR" && (
            <div>
              <span className="font-medium">ステータスコード:</span>{" "}
              {error.statusCode}
            </div>
          )}
          {error.type === "RATE_LIMIT_EXCEEDED" && error.retryAfter && (
            <div>
              <span className="font-medium">再試行可能時間:</span>{" "}
              {error.retryAfter}秒後
            </div>
          )}
          <div>
            <span className="font-medium">再試行可能:</span>{" "}
            {canRetry ? "はい" : "いいえ"}
          </div>
        </div>
      )}
    </div>
  );
}

export function ErrorDisplay({
  error,
  className,
  showDetails = false,
  onRetry,
  retryLabel = "再試行",
  userId,
  transactionId,
  variant = "inline",
  collapsible = false,
}: ErrorDisplayProps) {
  const [collapsed, setCollapsed] = useState(collapsible);

  if (!error) return null;

  const errors = Array.isArray(error) ? error : [error];
  const hasMultipleErrors = errors.length > 1;

  // 複数のバリデーションエラーの場合は統合メッセージを表示
  if (
    hasMultipleErrors &&
    errors.every((e) =>
      [
        "INVALID_EMAIL",
        "INVALID_AMOUNT",
        "REQUIRED_FIELD",
        "INVALID_FORMAT",
        "INVALID_PASSWORD",
        "PASSWORD_MISMATCH",
        "INVALID_RANGE",
      ].includes(e.type),
    )
  ) {
    const message = formatValidationErrors(errors);
    const severity = "low";
    const config = severityConfig[severity];
    const Icon = config.icon;

    return (
      <div
        className={cn(
          "flex items-start border",
          config.bgColor,
          config.textColor,
          config.borderColor,
          variantStyles[variant],
          className,
        )}
      >
        <Icon
          className={cn(
            "flex-shrink-0 mt-0.5 mr-3",
            variant === "inline" ? "h-4 w-4" : "h-5 w-5",
            config.iconColor,
          )}
        />
        <div className="flex-1 min-w-0">
          <pre className="font-medium whitespace-pre-wrap break-words font-sans">
            {message}
          </pre>
        </div>
      </div>
    );
  }

  if (collapsible && hasMultipleErrors) {
    return (
      <div className={cn("space-y-2", className)}>
        <button
          onClick={() => setCollapsed(!collapsed)}
          className={cn(
            "flex items-center justify-between w-full p-3 text-left border rounded-md",
            "bg-gray-50 text-gray-700 border-gray-200 hover:bg-gray-100 focus:outline-none",
          )}
        >
          <span className="flex items-center">
            <AlertCircle className="h-4 w-4 mr-2 text-gray-500" />
            {errors.length}件のエラーが発生しました
          </span>
          {collapsed ? (
            <ChevronDown className="h-4 w-4" />
          ) : (
            <ChevronUp className="h-4 w-4" />
          )}
        </button>

        {!collapsed && (
          <div className="space-y-2">
            {errors.map((err, index) => (
              <ErrorItem
                key={`${err.type}-${index}`}
                error={err}
                showDetails={showDetails}
                onRetry={index === 0 ? onRetry : undefined} // 最初のエラーにのみ再試行ボタンを表示
                retryLabel={retryLabel}
                userId={userId}
                transactionId={transactionId}
                variant={variant}
              />
            ))}
          </div>
        )}
      </div>
    );
  }

  return (
    <div className={cn("space-y-2", className)}>
      {errors.map((err, index) => (
        <ErrorItem
          key={`${err.type}-${index}`}
          error={err}
          showDetails={showDetails}
          onRetry={hasMultipleErrors && index > 0 ? undefined : onRetry} // 複数エラーの場合は最初のエラーにのみ再試行ボタン
          retryLabel={retryLabel}
          userId={userId}
          transactionId={transactionId}
          variant={variant}
        />
      ))}
    </div>
  );
}

// Backward compatibility - 既存のErrorMessageコンポーネントの機能を保持
interface LegacyErrorMessageProps {
  message: string | null;
  className?: string;
}

export function ErrorMessage({ message, className }: LegacyErrorMessageProps) {
  if (!message) return null;

  return (
    <div
      className={cn(
        "flex items-start p-3 text-sm bg-red-50 text-red-700 rounded-md border border-red-200",
        className,
      )}
    >
      <AlertCircle className="h-4 w-4 mr-2 mt-0.5 flex-shrink-0" />
      <span>{message}</span>
    </div>
  );
}
</file>

<file path="src/components/ui/popover.tsx">
"use client";

import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="src/features/auth/components/AuthField/AuthField.tsx">
"use client";

import { ReactNode } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { AuthFieldProps } from "../../types/auth";

/**
 * 拡張認証フィールドプロパティ
 * 基本的なAuthFieldPropsに追加のプロパティを追加
 */
export interface ExtendedAuthFieldProps extends AuthFieldProps {
  /** 追加の説明テキスト */
  description?: string;
  /** フィールド前のアイコン */
  icon?: ReactNode;
  /** フィールドに関連するアクション（リンクなど） */
  action?: ReactNode;
  /** 必須フラグ */
  required?: boolean;
}

/**
 * 認証フォーム用の入力フィールドコンポーネント
 *
 * ラベル、入力フィールド、エラー表示、説明などを含む
 */
export function AuthField({
  id,
  label,
  type = "text",
  placeholder,
  register,
  errors,
  disabled = false,
  description,
  icon,
  action,
  required = false,
}: ExtendedAuthFieldProps) {
  // エラーメッセージを取得
  const errorMessage = errors[id]?.message as string | undefined;

  return (
    <div className="space-y-2 text-left">
      <div className="flex justify-between">
        <Label
          htmlFor={id}
          className="text-sm font-medium text-stone-800 mb-1 inline-block"
        >
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </Label>
        {action}
      </div>

      <div className="relative">
        {icon && (
          <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-stone-500">
            {icon}
          </div>
        )}

        <Input
          id={id}
          type={type}
          placeholder={placeholder}
          disabled={disabled}
          className={`${
            errorMessage
              ? "border-red-300 ring-red-100"
              : "focus:border-teal-700 focus:ring-teal-100"
          } ${icon ? "pl-10" : ""} h-10 border-stone-300 bg-white`}
          {...register(id)}
        />
      </div>

      {errorMessage && (
        <p className="text-xs text-red-600 mt-1.5">{errorMessage}</p>
      )}
      {description && (
        <p className="text-xs text-stone-500 mt-1.5">{description}</p>
      )}
    </div>
  );
}
</file>

<file path="src/features/auth/components/AuthField/AuthFieldView.tsx">
"use client";

import { ReactNode } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

/**
 * Result型対応認証フィールドプロパティ
 */
export interface AuthFieldViewProps {
  /** フィールドID */
  id: string;
  /** ラベルテキスト */
  label: string;
  /** フィールドタイプ */
  type?: string;
  /** プレースホルダーテキスト */
  placeholder?: string;
  /** 入力値 */
  value: string;
  /** 変更ハンドラー */
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  /** 無効化フラグ */
  disabled?: boolean;
  /** 必須フラグ */
  required?: boolean;
  /** エラーメッセージ */
  error?: string | null;
  /** 追加の説明テキスト */
  description?: string;
  /** フィールド前のアイコン */
  icon?: ReactNode;
  /** フィールドに関連するアクション（リンクなど） */
  action?: ReactNode;
}

/**
 * Result型対応認証フォーム用入力フィールドコンポーネント
 *
 * ラベル、入力フィールド、エラー表示、説明などを含む
 */
export function AuthFieldView({
  id,
  label,
  type = "text",
  placeholder,
  value,
  onChange,
  disabled = false,
  required = false,
  error,
  description,
  icon,
  action,
}: AuthFieldViewProps) {
  return (
    <div className="space-y-2 text-left">
      <div className="flex justify-between">
        <Label
          htmlFor={id}
          className="text-sm font-medium text-stone-800 mb-1 inline-block"
        >
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </Label>
        {action}
      </div>

      <div className="relative">
        {icon && (
          <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-stone-500">
            {icon}
          </div>
        )}

        <Input
          id={id}
          name={id}
          type={type}
          placeholder={placeholder}
          value={value}
          onChange={onChange}
          disabled={disabled}
          className={`${
            error
              ? "border-red-300 ring-red-100"
              : "focus:border-teal-700 focus:ring-teal-100"
          } ${icon ? "pl-10" : ""} h-10 border-stone-300 bg-white`}
        />
      </div>

      {error && <p className="text-xs text-red-600 mt-1.5">{error}</p>}
      {description && (
        <p className="text-xs text-stone-500 mt-1.5">{description}</p>
      )}
    </div>
  );
}
</file>

<file path="src/features/auth/components/AuthField/index.ts">
export { AuthField } from "./AuthField";
export type { ExtendedAuthFieldProps } from "./AuthField";
</file>

<file path="src/features/auth/components/AuthField/LegacyAuthField.tsx">
import { ReactNode } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

interface AuthFieldProps {
  id: string;
  label: string;
  type?: string;
  name: string;
  placeholder?: string;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  required?: boolean;
  error?: string | null;
  description?: string;
  icon?: ReactNode;
  action?: ReactNode;
}

export function AuthField({
  id,
  label,
  type = "text",
  name,
  placeholder,
  value,
  onChange,
  disabled = false,
  required = false,
  error,
  description,
  icon,
  action,
}: AuthFieldProps) {
  return (
    <div className="space-y-2 text-left">
      <div className="flex justify-between">
        <Label
          htmlFor={id}
          className="text-sm font-medium text-stone-800 mb-1 inline-block"
        >
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </Label>
        {action}
      </div>

      <div className="relative">
        {icon && (
          <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-stone-500">
            {icon}
          </div>
        )}

        <Input
          id={id}
          name={name}
          type={type}
          placeholder={placeholder}
          value={value}
          onChange={onChange}
          disabled={disabled}
          required={required}
          className={`${error ? "border-red-300 ring-red-100" : "focus:border-teal-700 focus:ring-teal-100"} ${
            icon ? "pl-10" : ""
          } h-10 border-stone-300 bg-white`}
        />
      </div>

      {error && <p className="text-xs text-red-600 mt-1.5">{error}</p>}
      {description && (
        <p className="text-xs text-stone-500 mt-1.5">{description}</p>
      )}
    </div>
  );
}
</file>

<file path="src/features/auth/components/AuthForm/AuthForm.tsx">
"use client";
import { Button } from "@/components/ui/button";
import { AuthFormProps } from "../../types/auth";

/**
 * 認証フォームコンポーネント
 *
 * ログイン、登録などの共通フォームレイアウトとスタイリングを提供する
 */
export function AuthForm({
  title,
  subtitle,
  children,
  onSubmit,
  submitText,
  isSubmitting,
  error,
  footerLink,
}: AuthFormProps) {
  return (
    <div className="space-y-6 p-1">
      {/* ヘッダー */}
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-bold tracking-tight text-stone-800">
          {title}
        </h1>
        {subtitle && <p className="text-sm text-stone-500">{subtitle}</p>}
      </div>

      {/* フォーム */}
      <form onSubmit={onSubmit} className="space-y-4">
        {children}

        {/* エラーメッセージ */}
        {error && (
          <div className="text-sm bg-red-50 p-3 rounded-md border border-red-100 text-red-600">
            {error}
          </div>
        )}

        {/* 送信ボタン */}
        <Button
          type="submit"
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <>
              <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-white rounded-full"></div>
              処理中...
            </>
          ) : (
            submitText
          )}
        </Button>

        {/* フッターリンク */}
        {footerLink && (
          <div className="text-center text-sm text-stone-500 mt-4">
            {footerLink}
          </div>
        )}
      </form>
    </div>
  );
}
</file>

<file path="src/features/auth/components/AuthForm/index.ts">
export { AuthForm } from "./AuthForm";
</file>

<file path="src/features/auth/components/AuthForm/LegacyAuthForm.tsx">
import { ReactNode, FormEvent } from "react";
import { Button } from "@/components/ui/button";
import { ErrorMessage } from "@/components/ui/error-message";
import { LoadingSpinner } from "@/components/ui/loading-spinner";

interface AuthFormProps {
  children: ReactNode;
  onSubmit: (e: FormEvent) => Promise<void>;
  isLoading: boolean;
  error?: string | null;
  submitLabel: string;
  loadingLabel?: string;
  footer?: ReactNode;
}

export function AuthForm({
  children,
  onSubmit,
  isLoading,
  error,
  submitLabel,
  loadingLabel,
  footer,
}: AuthFormProps) {
  return (
    <form onSubmit={onSubmit} className="space-y-4">
      {children}

      {error && <ErrorMessage message={error} />}

      <Button
        type="submit"
        variant="eco"
        className="w-full h-10 font-medium"
        disabled={isLoading}
      >
        {isLoading ? (
          <div className="flex items-center justify-center">
            <LoadingSpinner size="sm" light className="mr-2" />
            {loadingLabel || "処理中..."}
          </div>
        ) : (
          submitLabel
        )}
      </Button>

      {footer}
    </form>
  );
}
</file>

<file path="src/features/auth/components/LoginForm/LoginFormContainer.tsx">
"use client";

import { useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { signIn } from "next-auth/react";
import {
  validateEmailResult,
  validatePasswordResult,
} from "@/lib/utils/validation";
import { getErrorMessage } from "@/lib/utils/error-utils";
import { ApiError } from "@/shared/types/errors";
import { ok } from "neverthrow";
import { LoginFormView } from "./LoginFormView";

/**
 * ログインフォームコンテナー
 *
 * Result型を使用した型安全なログイン処理を実装
 */
export function LoginFormContainer() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [rememberMe, setRememberMe] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // メールアドレスのバリデーション
  const emailValidationResult = useMemo(() => {
    if (!email) return ok("");
    return validateEmailResult(email);
  }, [email]);

  // パスワードのバリデーション
  const passwordValidationResult = useMemo(() => {
    if (!password) return ok("");
    return validatePasswordResult(password);
  }, [password]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    // バリデーション
    const emailResult = validateEmailResult(email);
    const passwordResult = validatePasswordResult(password);

    if (emailResult.isErr()) {
      setError(getErrorMessage(emailResult.error));
      return;
    }

    if (passwordResult.isErr()) {
      setError(getErrorMessage(passwordResult.error));
      return;
    }

    setIsLoading(true);

    try {
      const result = await signIn("credentials", {
        redirect: false,
        email: emailResult.value,
        password: passwordResult.value,
      });

      if (result?.error) {
        const authError: ApiError = {
          type: "UNAUTHORIZED",
          message: "メールアドレスまたはパスワードが正しくありません",
        };
        setError(getErrorMessage(authError));
        return;
      }

      if (result?.ok) {
        router.push("/");
        router.refresh();
      }
    } catch {
      const authError: ApiError = {
        type: "SERVER_ERROR",
        message: "ログイン処理中にエラーが発生しました",
        statusCode: 500,
      };
      setError(getErrorMessage(authError));
    } finally {
      setIsLoading(false);
    }
  };

  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEmail(e.target.value);
    setError(null);
  };

  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPassword(e.target.value);
    setError(null);
  };

  const handleRememberMeChange = (checked: boolean) => {
    setRememberMe(checked);
  };

  return (
    <LoginFormView
      email={email}
      password={password}
      rememberMe={rememberMe}
      isLoading={isLoading}
      error={error}
      emailError={
        emailValidationResult.isErr() && email.length > 0
          ? getErrorMessage(emailValidationResult.error)
          : null
      }
      passwordError={
        passwordValidationResult.isErr() && password.length > 0
          ? getErrorMessage(passwordValidationResult.error)
          : null
      }
      onEmailChange={handleEmailChange}
      onPasswordChange={handlePasswordChange}
      onRememberMeChange={handleRememberMeChange}
      onSubmit={handleSubmit}
    />
  );
}
</file>

<file path="src/features/auth/components/LoginForm/LoginFormView.tsx">
import Link from "next/link";
import { AuthForm } from "../AuthForm/AuthForm";
import { AuthFieldView } from "../AuthField/AuthFieldView";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Leaf, Mail, Lock } from "lucide-react";
import { Button } from "@/components/ui/button";

interface LoginFormViewProps {
  email: string;
  password: string;
  rememberMe: boolean;
  isLoading: boolean;
  error: string | null;
  emailError: string | null;
  passwordError: string | null;
  onEmailChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onPasswordChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onRememberMeChange: (checked: boolean) => void;
  onSubmit: (e: React.FormEvent) => void;
}

export function LoginFormView({
  email,
  password,
  rememberMe,
  isLoading,
  error,
  emailError,
  passwordError,
  onEmailChange,
  onPasswordChange,
  onRememberMeChange,
  onSubmit,
}: LoginFormViewProps) {
  return (
    <AuthForm
      title="ログイン"
      subtitle="Eco Walletへログインしてください"
      onSubmit={onSubmit}
      submitText="ログイン"
      isSubmitting={isLoading}
      error={error}
      footerLink={
        <>
          <div className="text-center text-sm text-stone-600">
            アカウントをお持ちでない方は
            <Link
              href="/auth/register"
              className="text-teal-700 hover:underline ml-1 font-medium"
            >
              新規登録
            </Link>
          </div>

          <div className="flex items-center py-2">
            <div className="flex-grow h-px bg-stone-200"></div>
            <span className="px-2 text-xs text-stone-500">または</span>
            <div className="flex-grow h-px bg-stone-200"></div>
          </div>

          <Button
            type="button"
            variant="outline"
            className="w-full border-stone-300 h-10 px-4 py-2 hover:bg-stone-50 transition-all shadow-xs"
          >
            <svg
              className="h-5 w-5 mr-2"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                fill="#4285F4"
              />
              <path
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                fill="#34A853"
              />
              <path
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                fill="#FBBC05"
              />
              <path
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                fill="#EA4335"
              />
            </svg>
            Googleでログイン
          </Button>

          <div className="flex items-center pt-3 mt-3 p-3 bg-teal-50 border border-teal-200 rounded-md">
            <Leaf className="h-5 w-5 text-teal-700 mr-2.5 flex-shrink-0" />
            <p className="text-xs text-teal-800">
              環境に優しいサーバーで運用され、取引ごとに環境保護活動に寄付が行われます。
            </p>
          </div>
        </>
      }
    >
      <AuthFieldView
        id="email"
        label="メールアドレス"
        type="email"
        placeholder="your@email.com"
        value={email}
        onChange={onEmailChange}
        disabled={isLoading}
        required
        error={emailError}
        icon={<Mail className="h-4 w-4" />}
      />

      <AuthFieldView
        id="password"
        label="パスワード"
        type="password"
        placeholder="********"
        value={password}
        onChange={onPasswordChange}
        disabled={isLoading}
        required
        error={passwordError}
        icon={<Lock className="h-4 w-4" />}
        action={
          <Link
            href="/auth/forgot-password"
            className="text-xs text-teal-700 hover:underline hover:text-teal-800 font-medium"
          >
            パスワードをお忘れですか？
          </Link>
        }
      />

      <div className="flex items-center space-x-2 text-left mt-1">
        <Checkbox
          id="remember"
          checked={rememberMe}
          onCheckedChange={(checked) => onRememberMeChange(checked as boolean)}
          disabled={isLoading}
          className="text-teal-700 border-stone-400 data-[state=checked]:bg-teal-700"
        />
        <Label
          htmlFor="remember"
          className="text-sm text-stone-700 cursor-pointer"
        >
          ログイン状態を保持する
        </Label>
      </div>
    </AuthForm>
  );
}
</file>

<file path="src/features/auth/components/LogoutButton/index.ts">
export { LogoutButton } from "./LogoutButton";
</file>

<file path="src/features/auth/components/LogoutButton/LogoutButton.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { LogOut } from "lucide-react";
import { signOut } from "next-auth/react";
import { useState } from "react";
import { LogoutButtonProps } from "../../types/auth";

/**
 * ログアウトボタンコンポーネント
 *
 * ログアウト機能を提供するボタン。表示スタイルはプロパティで調整可能
 */
export function LogoutButton({
  label = "ログアウト",
  showIcon = true,
  variant = "ghost",
  className = "text-stone-600",
}: LogoutButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  /**
   * ログアウト処理
   */
  const handleLogout = async () => {
    setIsLoading(true);
    try {
      await signOut({ callbackUrl: "/auth/login" });
    } catch (error) {
      console.error("ログアウト中にエラーが発生しました", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      variant={variant}
      size="sm"
      className={className}
      onClick={handleLogout}
      disabled={isLoading}
    >
      {showIcon && <LogOut className="h-4 w-4 mr-2" />}
      {isLoading ? "ログアウト中..." : label}
    </Button>
  );
}
</file>

<file path="src/features/auth/hooks/index.ts">
export * from "./useAuthForm";
</file>

<file path="src/features/auth/store/auth.slice.ts">
/**
 * 認証状態管理ストア（Result型対応）
 */

import { create } from "zustand";
import { persist } from "zustand/middleware";
import { Result, ResultAsync, ok, err } from "neverthrow";
import { BusinessError, AppError } from "../../../shared/types/errors";
import {
  loginUser,
  registerUser,
  logoutUser,
  fetchUserProfile,
  updateUserProfile,
  type AuthUserData,
  type RegisterUserData,
  type UserProfile,
} from "../../../services/api/user";

/**
 * 認証状態の型定義
 */
export interface AuthState {
  // ユーザー情報
  user: UserProfile | null;
  isAuthenticated: boolean;

  // 状態管理
  isLoading: boolean;
  error: AppError | null;

  // 認証アクション（Result型対応）
  loginAsync: (credentials: AuthUserData) => ResultAsync<void, AppError>;
  registerAsync: (userData: RegisterUserData) => ResultAsync<void, AppError>;
  logoutAsync: () => ResultAsync<void, AppError>;

  // プロフィール管理（Result型対応）
  fetchUserProfileAsync: (userId?: string) => ResultAsync<void, AppError>;
  updateUserProfileAsync: (
    updates: Partial<UserProfile>,
  ) => ResultAsync<void, AppError>;

  // 認証状態チェック（Result型対応）
  checkAuthStatus: () => Result<boolean, BusinessError>;
  validateSession: () => Result<boolean, BusinessError>;

  // ユーティリティ
  clearError: () => void;
  setLoading: (loading: boolean) => void;
  logout: () => void;
}

/**
 * 認証状態管理ストア（Result型対応）
 */
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // 初期状態
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,

      // ログイン処理（API統合）
      loginAsync: (credentials: AuthUserData) => {
        return ResultAsync.fromSafePromise(
          (async () => {
            set({ isLoading: true, error: null });

            const loginResult = await loginUser(credentials);

            if (loginResult.isErr()) {
              const error: AppError = loginResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            // ユーザープロフィールを取得
            const profileResult = await fetchUserProfile();

            if (profileResult.isErr()) {
              const error: AppError = profileResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            const userProfile = profileResult.value;

            set({
              user: userProfile,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });
          })(),
        ).mapErr((error: unknown): AppError => {
          const appError: AppError =
            error && typeof error === "object" && "type" in error
              ? (error as AppError)
              : { type: "NETWORK_ERROR", message: String(error) };

          set({ isLoading: false, error: appError });
          return appError;
        });
      },

      // ユーザー登録処理（API統合）
      registerAsync: (userData: RegisterUserData) => {
        return ResultAsync.fromSafePromise(
          (async () => {
            set({ isLoading: true, error: null });

            const registerResult = await registerUser(userData);

            if (registerResult.isErr()) {
              const error: AppError = registerResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            // 登録後、プロフィール情報を取得
            const profileResult = await fetchUserProfile();

            if (profileResult.isErr()) {
              const error: AppError = profileResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            const userProfile = profileResult.value;

            set({
              user: userProfile,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });
          })(),
        ).mapErr((error: unknown): AppError => {
          const appError: AppError =
            error && typeof error === "object" && "type" in error
              ? (error as AppError)
              : { type: "NETWORK_ERROR", message: String(error) };

          set({ isLoading: false, error: appError });
          return appError;
        });
      },

      // ログアウト処理（API統合）
      logoutAsync: () => {
        return ResultAsync.fromSafePromise(
          (async () => {
            set({ isLoading: true, error: null });

            const logoutResult = await logoutUser();

            if (logoutResult.isErr()) {
              const error: AppError = logoutResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            set({
              user: null,
              isAuthenticated: false,
              isLoading: false,
              error: null,
            });
          })(),
        ).mapErr((error: unknown): AppError => {
          const appError: AppError =
            error && typeof error === "object" && "type" in error
              ? (error as AppError)
              : { type: "NETWORK_ERROR", message: String(error) };

          set({ isLoading: false, error: appError });
          return appError;
        });
      },

      // ユーザープロフィール取得（API統合）
      fetchUserProfileAsync: (userId?: string) => {
        return ResultAsync.fromSafePromise(
          (async () => {
            set({ isLoading: true, error: null });

            const profileResult = await fetchUserProfile(userId);

            if (profileResult.isErr()) {
              const error: AppError = profileResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            const userProfile = profileResult.value;

            set({
              user: userProfile,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });
          })(),
        ).mapErr((error: unknown): AppError => {
          const appError: AppError =
            error && typeof error === "object" && "type" in error
              ? (error as AppError)
              : { type: "NETWORK_ERROR", message: String(error) };

          set({ isLoading: false, error: appError });
          return appError;
        });
      },

      // ユーザープロフィール更新（API統合）
      updateUserProfileAsync: (updates: Partial<UserProfile>) => {
        return ResultAsync.fromSafePromise(
          (async () => {
            set({ isLoading: true, error: null });

            const { user } = get();
            if (!user) {
              throw {
                type: "UNAUTHORIZED",
                message: "ユーザーがログインしていません",
              } as AppError;
            }

            const updateResult = await updateUserProfile(user.id, updates);

            if (updateResult.isErr()) {
              const error: AppError = updateResult.error;
              set({ isLoading: false, error });
              throw error;
            }

            const updatedProfile = updateResult.value;

            set({
              user: updatedProfile,
              isLoading: false,
              error: null,
            });
          })(),
        ).mapErr((error: unknown): AppError => {
          const appError: AppError =
            error && typeof error === "object" && "type" in error
              ? (error as AppError)
              : { type: "NETWORK_ERROR", message: String(error) };

          set({ isLoading: false, error: appError });
          return appError;
        });
      },

      // 認証状態チェック（Result型対応）
      checkAuthStatus: () => {
        try {
          const { user, isAuthenticated } = get();

          if (!isAuthenticated || !user) {
            return ok(false);
          }

          // セッションの有効性をチェック
          const sessionValidation = get().validateSession();
          if (sessionValidation.isErr()) {
            return err(sessionValidation.error);
          }

          return ok(sessionValidation.value);
        } catch (error) {
          return err({
            type: "ACCOUNT_SUSPENDED",
            message: "認証状態の確認に失敗しました",
            reason: String(error),
          });
        }
      },

      // セッション検証（Result型対応）
      validateSession: () => {
        try {
          const { user } = get();

          if (!user) {
            return err({
              type: "ACCOUNT_SUSPENDED",
              message: "ユーザー情報が存在しません",
              reason: "user is null",
            });
          }

          // 基本的なセッション検証
          if (!user.id || !user.email) {
            return err({
              type: "ACCOUNT_SUSPENDED",
              message: "ユーザー情報が不完全です",
              reason: `userId: ${user.id}, email: ${user.email}`,
            });
          }

          return ok(true);
        } catch (error) {
          return err({
            type: "ACCOUNT_SUSPENDED",
            message: "セッション検証中にエラーが発生しました",
            reason: String(error),
          });
        }
      },

      // ローカルログアウト（同期処理）
      logout: () => {
        set({
          user: null,
          isAuthenticated: false,
          error: null,
        });
      },

      // エラーをクリア
      clearError: () => {
        set({ error: null });
      },

      // ローディング状態を設定
      setLoading: (loading: boolean) => {
        set({ isLoading: loading });
      },
    }),
    {
      name: "auth-storage",
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    },
  ),
);

// In Source Testing
if (import.meta.vitest) {
  const { describe, it, expect, beforeEach } = import.meta.vitest;

  describe("AuthStore", () => {
    beforeEach(() => {
      // ストアをリセット
      useAuthStore.setState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,
      });
    });

    describe("checkAuthStatus", () => {
      it("未認証の場合、falseを返す", () => {
        const result = useAuthStore.getState().checkAuthStatus();
        expect(result.isOk()).toBe(true);
        expect(result._unsafeUnwrap()).toBe(false);
      });

      it("認証済みの場合、trueを返す", () => {
        // 認証状態をセット
        useAuthStore.setState({
          user: {
            id: "user_123",
            email: "test@example.com",
            name: "Test User",
            avatarUrl: "/avatar.jpg",
            avatarInitials: "TU",
            ecoRank: "エコマイスター",
            balance: 5000,
            joinDate: "2023-01-01",
          },
          isAuthenticated: true,
        });

        const result = useAuthStore.getState().checkAuthStatus();
        expect(result.isOk()).toBe(true);
        expect(result._unsafeUnwrap()).toBe(true);
      });
    });

    describe("validateSession", () => {
      it("ユーザー情報がない場合、エラーを返す", () => {
        const result = useAuthStore.getState().validateSession();
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("ACCOUNT_SUSPENDED");
      });

      it("有効なユーザー情報がある場合、成功を返す", () => {
        useAuthStore.setState({
          user: {
            id: "user_123",
            email: "test@example.com",
            name: "Test User",
            avatarUrl: "/avatar.jpg",
            avatarInitials: "TU",
            ecoRank: "エコマイスター",
            balance: 5000,
            joinDate: "2023-01-01",
          },
        });

        const result = useAuthStore.getState().validateSession();
        expect(result.isOk()).toBe(true);
        expect(result._unsafeUnwrap()).toBe(true);
      });

      it("不完全なユーザー情報の場合、エラーを返す", () => {
        useAuthStore.setState({
          user: {
            id: "",
            email: "test@example.com",
            name: "Test User",
            avatarUrl: "/avatar.jpg",
            avatarInitials: "TU",
            ecoRank: "エコマイスター",
            balance: 5000,
            joinDate: "2023-01-01",
          },
        });

        const result = useAuthStore.getState().validateSession();
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("ACCOUNT_SUSPENDED");
      });
    });

    describe("logout", () => {
      it("ログアウト時に状態をクリアする", () => {
        // 認証状態をセット
        useAuthStore.setState({
          user: {
            id: "user_123",
            email: "test@example.com",
            name: "Test User",
            avatarUrl: "/avatar.jpg",
            avatarInitials: "TU",
            ecoRank: "エコマイスター",
            balance: 5000,
            joinDate: "2023-01-01",
          },
          isAuthenticated: true,
        });

        useAuthStore.getState().logout();

        const state = useAuthStore.getState();
        expect(state.user).toBeNull();
        expect(state.isAuthenticated).toBe(false);
        expect(state.error).toBeNull();
      });
    });

    describe("clearError", () => {
      it("エラーをクリアする", () => {
        useAuthStore.setState({
          error: {
            type: "NETWORK_ERROR",
            message: "Test error",
          },
        });

        useAuthStore.getState().clearError();

        expect(useAuthStore.getState().error).toBeNull();
      });
    });

    describe("setLoading", () => {
      it("ローディング状態を設定する", () => {
        useAuthStore.getState().setLoading(true);
        expect(useAuthStore.getState().isLoading).toBe(true);

        useAuthStore.getState().setLoading(false);
        expect(useAuthStore.getState().isLoading).toBe(false);
      });
    });
  });
}
</file>

<file path="src/features/auth/types/auth.ts">
/**
 * 認証機能の型定義
 */

import { Session } from "next-auth";
import { FieldErrors, UseFormRegister } from "react-hook-form";

/**
 * ユーザー認証情報の型
 */
export interface AuthUser {
  /** ユーザーID */
  id: string;
  /** 名前 */
  name: string;
  /** メールアドレス */
  email: string;
  /** アバター画像URL */
  image?: string;
  /** エコランク */
  ecoRank?: string;
  /** 認証済みフラグ */
  isVerified?: boolean;
  /** メンバーシップレベル */
  membershipLevel?: string;
}

/**
 * ログインフォームの値型
 */
export interface LoginFormValues {
  /** メールアドレス */
  email: string;
  /** パスワード */
  password: string;
  /** ログイン状態を記憶するか */
  remember?: boolean;
}

/**
 * 登録フォームの値型
 */
export interface RegisterFormValues {
  /** 名前 */
  name: string;
  /** メールアドレス */
  email: string;
  /** パスワード */
  password: string;
  /** パスワード（確認用） */
  passwordConfirm: string;
  /** 利用規約に同意するか */
  termsAccepted: boolean;
}

/**
 * 認証フィールドのプロパティ型
 */
export interface AuthFieldProps {
  /** フィールドID */
  id: string;
  /** ラベルテキスト */
  label: string;
  /** フィールドタイプ */
  type: string;
  /** プレースホルダーテキスト */
  placeholder?: string;
  /** 入力値の表示処理 */
  register: UseFormRegister<Record<string, unknown>>;
  /** バリデーションエラー */
  errors: FieldErrors;
  /** 無効化フラグ */
  disabled?: boolean;
}

/**
 * 認証フォームのプロパティ型
 */
export interface AuthFormProps {
  /** タイトル */
  title: string;
  /** サブタイトル */
  subtitle?: string;
  /** 送信ボタンテキスト */
  submitText: string;
  /** 送信処理中フラグ */
  isSubmitting?: boolean;
  /** エラーメッセージ */
  error?: string | null;
  /** フォーム内容 */
  children: React.ReactNode;
  /** 送信ハンドラー */
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  /** フッターリンク */
  footerLink?: React.ReactNode;
}

/**
 * ログイン状態型
 */
export interface AuthState {
  /** 認証済みフラグ */
  isAuthenticated: boolean;
  /** ユーザー情報 */
  user: AuthUser | null;
  /** セッション情報 */
  session: Session | null;
  /** ローディング状態 */
  loading: boolean;
  /** エラー情報 */
  error: string | null;
}

/**
 * ログアウトボタンのプロパティ型
 */
export interface LogoutButtonProps {
  /** ボタンテキスト */
  label?: string;
  /** アイコンを表示するか */
  showIcon?: boolean;
  /** ボタンバリアント */
  variant?:
    | "link"
    | "ghost"
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | null
    | undefined;
  /** クラス名 */
  className?: string;
}
</file>

<file path="src/features/auth/README.md">
# 認証機能（Auth Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいた認証機能を含みます。

## ディレクトリ構造

```
auth/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── AuthField/             # 認証入力フィールド
│   │   ├── AuthField.tsx       # AuthField実装
│   │   └── index.ts           # 公開API
│   ├── AuthForm/              # 認証フォーム
│   │   ├── AuthForm.tsx        # AuthForm実装
│   │   └── index.ts           # 公開API
│   └── LogoutButton/          # ログアウトボタン
│       ├── LogoutButton.tsx    # LogoutButton実装
│       └── index.ts           # 公開API
├── types/                      # 型定義
│   └── auth.ts                # 認証関連の型定義
├── hooks/                      # カスタムフック（将来追加予定）
├── utils/                      # ユーティリティ関数（将来追加予定）
├── store/                      # 状態管理（将来追加予定）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // コンポーネント
  AuthField,
  AuthForm,
  LogoutButton,

  // 型定義
  AuthUser,
  LoginFormValues,
  RegisterFormValues,
} from "@/features/auth";
```

### コンポーネント例

#### 認証フィールド

```tsx
<AuthField
  id="email"
  label="メールアドレス"
  type="email"
  placeholder="your@email.com"
  register={register}
  errors={errors}
  required
  icon={<AtSign className="h-4 w-4" />}
/>
```

#### 認証フォーム

```tsx
<AuthForm
  title="ログイン"
  subtitle="アカウントにログイン"
  onSubmit={handleSubmit}
  submitText="ログイン"
  isSubmitting={isLoading}
  error={error}
  footerLink={
    <Link href="/auth/register">アカウントをお持ちでない方はこちら</Link>
  }
>
  {formFields}
</AuthForm>
```

#### ログアウトボタン

```tsx
<LogoutButton label="ログアウト" showIcon={true} variant="ghost" />
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. ユーザーの認証処理（ログイン、ログアウト）
2. 認証関連UIコンポーネントの提供（フォーム、入力フィールドなど）
3. 認証状態の管理
4. 認証情報の検証

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 認証ライブラリ: `next-auth`
- フォーム管理: `react-hook-form`
- バリデーション: `zod`

## 拡張予定

今後、以下の機能を追加予定です：

1. カスタムフック（useAuth, useAuthForm）
2. 認証状態管理（auth.slice.ts）
3. ユーザープロファイル管理
4. 権限管理
5. ソーシャルログイン連携
</file>

<file path="src/features/balance/components/BalanceCard/index.ts">
export { BalanceCardContainer } from "./BalanceCardContainer";
export { BalanceCardView } from "./BalanceCardView";
</file>

<file path="src/features/balance/components/BalanceOverview/index.ts">
export { BalanceOverview } from "./BalanceOverview";
</file>

<file path="src/features/balance/data/user-profile-data.ts">
export interface UserProfile {
  id: string;
  name: string;
  email: string;
  avatarUrl: string;
  avatarInitials: string;
  ecoRank: string;
  balance: number;
  joinDate: string;
}

export const userBalanceData: UserProfile = {
  id: "usr_12345",
  name: "山田 太郎",
  email: "eco_user@example.com",
  avatarUrl: "/api/placeholder/100/100",
  avatarInitials: "山田",
  ecoRank: "エコマイスター",
  balance: 8500,
  joinDate: "2024-12-01",
};
</file>

<file path="src/features/balance/types/balance.ts">
/**
 * 残高機能の型定義
 */

/**
 * 残高情報の型
 */
export interface BalanceInfo {
  /** 現在の残高金額 */
  currentBalance: number;

  /** フォーマット済みの残高表示 */
  formattedBalance?: string;

  /** キャンペーンによる残高の合計 */
  campaignTotal: number;

  /** 期限切れ間近の残高があるかどうか */
  hasExpiringBalance: boolean;

  /** 残高履歴 */
  history?: BalanceHistoryItem[];

  /** 最終更新日時 */
  lastUpdated?: string;
}

/**
 * 残高履歴項目の型
 */
export interface BalanceHistoryItem {
  /** 項目ID */
  id: string;

  /** 日時 */
  timestamp: string;

  /** 金額（正: 入金、負: 出金） */
  amount: number;

  /** 残高タイプ（通常/キャンペーン） */
  type: "regular" | "campaign";

  /** キャンペーンID（キャンペーン残高の場合） */
  campaignId?: string;

  /** 有効期限（キャンペーン残高の場合） */
  expiryDate?: string;

  /** 関連取引ID */
  transactionId?: string;

  /** 説明 */
  description?: string;
}

/**
 * キャンペーン残高の型
 */
export interface CampaignBalance {
  /** キャンペーンID */
  campaignId: string;

  /** キャンペーン名 */
  campaignName: string;

  /** 金額 */
  amount: number;

  /** 有効期限 */
  expiryDate: string;

  /** 期限切れまでの残り日数 */
  daysRemaining: number;

  /** 使用制限（特定カテゴリでのみ使用可能など） */
  restrictions?: string[];
}

/**
 * 残高カードビューのプロパティ型
 */
export interface BalanceCardViewProps {
  /** フォーマット済みの残高 */
  formattedBalance: string;

  /** キャンペーン残高の合計 */
  campaignTotal: number;

  /** 期限切れ間近の残高があるかどうか */
  hasExpiringBalance: boolean;
}

/**
 * 残高カードコンテナのプロパティ型
 */
export interface BalanceCardContainerProps {
  /** カスタムCSSクラス */
  className?: string;
}
</file>

<file path="src/features/balance/README.md">
# 残高機能（Balance Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいた残高機能を含みます。

## ディレクトリ構造

```
balance/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── BalanceCard/           # 残高表示カード
│   │   ├── BalanceCardView.tsx    # 表示コンポーネント
│   │   ├── BalanceCardContainer.tsx # コンテナコンポーネント
│   │   └── index.ts           # 公開API
│   └── ... (将来追加予定の他コンポーネント)
├── types/                      # 型定義
│   └── balance.ts              # 残高関連の型定義
├── store/                      # 状態管理
│   └── balance.slice.ts        # 残高状態管理ストア
├── hooks/                      # カスタムフック（将来追加予定）
├── utils/                      # ユーティリティ関数（将来追加予定）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // コンポーネント
  BalanceCardContainer,

  // ストア
  useBalanceStore,

  // 型定義
  BalanceInfo,
  BalanceHistoryItem,
  CampaignBalance,
} from "@/features/balance";
```

### コンポーネント例

#### 残高表示カード

```tsx
<BalanceCardContainer />
```

### ストア例

```tsx
// 残高情報の取得
const balance = useBalanceStore((state) => state.regularBalance);
const campaignBalances = useBalanceStore((state) => state.campaignBalances);

// 合計残高の取得
const totalBalance = useBalanceStore((state) => state.getTotalBalance());

// 残高の更新
const updateBalance = useBalanceStore((state) => state.updateBalance);
updateBalance(newBalance);
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. 残高情報の表示・管理
2. キャンペーン残高の管理
3. 残高に関する状態の一元管理
4. 残高関連コンポーネントの提供

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 共通ユーティリティ: `@/lib/utils/common`
- 状態管理: `zustand`
- アイコン: `lucide-react`

## 拡張予定

今後、以下の機能を追加予定です：

1. 残高履歴表示コンポーネント
2. 残高グラフ表示
3. 残高推移データ分析
4. キャンペーン残高詳細表示
</file>

<file path="src/features/campaigns/components/CampaignCard/CampaignCard.tsx">
"use client";

import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Zap, ChevronRight, Users, Leaf, Gift } from "lucide-react";
import { Campaign } from "../../types/campaign";
import { cn } from "@/lib/utils";

/**
 * キャンペーンカードのプロパティ
 */
export interface CampaignCardProps {
  campaign: Campaign;
  variant?: "featured" | "referral" | "notification";
  className?: string;
  buttonText?: string;
  showButton?: boolean;
}

/**
 * キャンペーン情報を表示するカードコンポーネント
 *
 * @param campaign キャンペーン情報
 * @param variant 表示バリアント
 * @param className 追加のCSSクラス
 * @param buttonText ボタンのテキスト
 * @param showButton ボタン表示フラグ
 */
export function CampaignCard({
  campaign,
  variant = "featured",
  className = "",
  buttonText = "キャンペーン詳細を見る",
  showButton = true,
}: CampaignCardProps) {
  if (!campaign) return null;

  /**
   * キャンペーンタイプに基づいたアイコンを取得
   */
  const getIcon = () => {
    switch (campaign.type) {
      case "eco":
        return <Leaf className="h-5 w-5" />;
      case "referral":
        return <Users className="h-5 w-5" />;
      case "point":
        return <Gift className="h-5 w-5" />;
      default:
        return <Zap className="h-5 w-5" />;
    }
  };

  /**
   * キャンペーンタイプに基づいたグラデーション背景を取得
   */
  const getGradientBg = () => {
    switch (campaign.type) {
      case "eco":
        return "from-teal-100 to-teal-100/70";
      case "referral":
        return "from-blue-50 to-blue-100";
      case "point":
        return "from-amber-100 to-amber-100/70";
      default:
        return "from-amber-100 to-amber-100/70";
    }
  };

  /**
   * キャンペーンタイプに基づいたアイコン背景を取得
   */
  const getIconBg = () => {
    switch (campaign.type) {
      case "eco":
        return "bg-teal-600 text-white";
      case "referral":
        return "bg-blue-600 text-white";
      case "point":
        return "bg-amber-600 text-white";
      default:
        return "bg-amber-600 text-white";
    }
  };

  /**
   * キャンペーンタイプに基づいたボタンスタイルを取得
   */
  const getButtonStyle = () => {
    switch (campaign.type) {
      case "eco":
        return "bg-teal-600 hover:bg-teal-700 text-white";
      case "referral":
        return "bg-blue-600 hover:bg-blue-700 text-white";
      case "point":
        return "bg-amber-600 hover:bg-amber-700 text-white";
      default:
        return "bg-amber-600 hover:bg-amber-700 text-white";
    }
  };

  /**
   * 通知バリアント用の詳細コンテンツを取得
   */
  const getNotificationContent = () => {
    if (variant !== "notification") return null;

    return (
      <div className="bg-amber-100 p-4 rounded-lg mt-3 eco-transition hover:bg-amber-100/80">
        <h3 className="text-sm font-medium text-amber-700 mb-2">
          キャンペーン詳細
        </h3>
        <p className="text-xs text-amber-600">
          {campaign.title}期間中（{campaign.startDate}〜{campaign.endDate}）
          {campaign.pointRate
            ? `にエコ製品を購入すると、購入金額の${campaign.pointRate}%がEcoポイントとして還元されます。`
            : campaign.description}
        </p>
      </div>
    );
  };

  return (
    <Card
      className={cn(
        `border-0 shadow-md bg-gradient-to-r ${getGradientBg()} eco-transition hover:shadow-lg rounded-lg`,
        className,
      )}
    >
      <div className="p-4 flex items-start space-x-3">
        <div className={`p-2 rounded-full ${getIconBg()} eco-transition`}>
          {getIcon()}
        </div>
        <div className="flex-1">
          <h3 className="text-sm font-medium text-stone-800">
            {campaign.title}
          </h3>
          <p className="text-xs text-stone-700 mt-1">
            {campaign.subtitle || campaign.description}
          </p>

          {/* 通知バリアント用の詳細情報 */}
          {getNotificationContent()}

          {showButton && (
            <Link href={`/campaigns/${campaign.id}`}>
              <Button
                className={`mt-3 w-full ${getButtonStyle()} eco-transition h-10 rounded-md font-medium`}
              >
                {buttonText}
                <ChevronRight className="h-4 w-4 ml-1" />
              </Button>
            </Link>
          )}
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/campaigns/components/CampaignCard/index.ts">
export { CampaignCard } from "./CampaignCard";
export type { CampaignCardProps } from "./CampaignCard";
</file>

<file path="src/features/campaigns/components/FeaturedCampaign/FeaturedCampaignSection.tsx">
"use client";

import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Zap, ChevronRight } from "lucide-react";
import { useCampaignStore } from "../../store/campaign.slice";

/**
 * 注目のキャンペーンを表示するセクション
 */
export function FeaturedCampaignSection() {
  const getPopularCampaigns = useCampaignStore(
    (state) => state.getPopularCampaigns,
  );
  const popularCampaigns = getPopularCampaigns();
  const campaign = popularCampaigns.length > 0 ? popularCampaigns[0] : null;

  if (!campaign) return null;

  return (
    <Card className="border-0 shadow-md bg-gradient-to-r from-amber-50 to-amber-100 p-4">
      <div className="flex items-start space-x-3">
        <div className="bg-amber-500 text-white p-2 rounded-full">
          <Zap className="h-5 w-5" />
        </div>
        <div>
          <h3 className="text-sm font-medium text-stone-800">
            アクティブなキャンペーン
          </h3>
          <p className="text-xs text-stone-600 mt-1">
            {campaign.subtitle || campaign.description}
          </p>
          <Link href={`/campaigns/${campaign.id}`}>
            <Button className="mt-3 bg-amber-500 hover:bg-amber-600 text-white w-full">
              キャンペーン詳細を見る
              <ChevronRight className="h-4 w-4 ml-1" />
            </Button>
          </Link>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/campaigns/components/FeaturedCampaign/index.ts">
export { FeaturedCampaignSection } from "./FeaturedCampaignSection";
</file>

<file path="src/features/campaigns/components/NotificationCampaignCard/index.ts">
export { NotificationCampaignCard } from "./NotificationCampaignCard";
export type { NotificationCampaignCardProps } from "./NotificationCampaignCard";
</file>

<file path="src/features/campaigns/components/NotificationCampaignCard/NotificationCampaignCard.tsx">
"use client";

import { useCampaignStore, CampaignCard } from "@/features/campaigns";

interface NotificationCampaignCardProps {
  // オプション：特定のキャンペーンIDを指定できるようにする
  campaignId?: string;
}

export function NotificationCampaignCard({
  campaignId,
}: NotificationCampaignCardProps) {
  const getCampaignById = useCampaignStore((state) => state.getCampaignById);
  const getActiveCampaigns = useCampaignStore(
    (state) => state.getActiveCampaigns,
  );

  // 指定されたIDまたはアクティブなキャンペーンの1つを使用
  const campaign = campaignId
    ? getCampaignById(campaignId)
    : getActiveCampaigns()[0];

  if (!campaign) return null;

  return (
    <CampaignCard
      campaign={campaign}
      variant="notification"
      buttonText="キャンペーン詳細を見る"
      className="p-0 bg-transparent shadow-none border-0"
    />
  );
}

export type { NotificationCampaignCardProps };
</file>

<file path="src/features/campaigns/components/ReferralCampaignCard/index.ts">
export { ReferralCampaignCard } from "./ReferralCampaignCard";
</file>

<file path="src/features/campaigns/components/ReferralCampaignCard/ReferralCampaignCard.tsx">
"use client";

import { useCampaignStore, CampaignCard } from "@/features/campaigns";

export function ReferralCampaignCard() {
  const getCampaignsByType = useCampaignStore(
    (state) => state.getCampaignsByType,
  );
  const referralCampaigns = getCampaignsByType("referral");
  const campaign = referralCampaigns.length > 0 ? referralCampaigns[0] : null;

  if (!campaign) return null;

  return (
    <CampaignCard
      campaign={campaign}
      variant="referral"
      className="mb-6"
      buttonText="キャンペーン詳細を見る"
    />
  );
}
</file>

<file path="src/features/campaigns/data/campaigns-data.ts">
import { Campaign } from "../types/campaign";

/**
 * キャンペーンのモックデータ
 */
export const campaignsData: Campaign[] = [
  {
    id: "camp_1",
    title: "山の日キャンペーン",
    subtitle: "エコ製品購入で20%ポイント還元",
    description:
      "山の日を記念して、環境に優しい製品のご購入でポイント20%還元。あなたの買い物が山岳環境の保全活動を支援します。",
    type: "eco",
    startDate: "2025/05/01",
    endDate: "2025/05/31",
    imageType: "mountain",
    pointRate: 20,
    conditions: [
      "環境に配慮した商品（エコマーク付き）が対象です",
      "1回のお買い物で最大2,000ポイントまで付与されます",
      "キャンペーンポイントの有効期限は2025年6月30日までです",
    ],
    benefitDescription:
      "キャンペーン期間中、対象商品購入額の20%がEcoポイントとして還元されます。獲得したポイントは通常の買い物だけでなく、環境保全プロジェクトへの寄付にも使用できます。",
    steps: [
      "エコマーク付き商品を選ぶ",
      "Eco Walletで決済する",
      "購入額の20%がポイントとして自動付与される",
      "マイページでポイント獲得を確認",
    ],
    relatedItems: [
      {
        title: "オーガニックコットンTシャツ",
        description: "リサイクル素材を使用した環境に優しいTシャツ",
        imageType: "clothing",
      },
      {
        title: "リサイクルフリース",
        description: "ペットボトルから作られたサステナブルなフリース",
        imageType: "clothing",
      },
    ],
    ecoImpact: {
      title: "環境への貢献",
      description:
        "このキャンペーンを通じた購入は、山岳環境の保全活動に直接貢献します。",
      metrics: [
        {
          label: "森林保全面積",
          value: "約2m²",
          icon: "tree",
        },
        {
          label: "CO2削減量",
          value: "約5kg",
          icon: "globe",
        },
      ],
    },
    isActive: true,
    isPopular: true,
    badgeText: "人気",
  },
  {
    id: "camp_2",
    title: "友達紹介プログラム",
    subtitle: "友達を招待して1,000円分のエコポイントをGET",
    description:
      "友達をEco Walletに招待すると、あなたも友達も1,000円分のエコポイントが獲得できます。招待すればするほど、環境保全への貢献も大きくなります。",
    type: "referral",
    startDate: "2025/01/01",
    endDate: "2025/12/31",
    imageType: "people",
    conditions: [
      "友達が新規登録し、1回以上の決済を行うとポイントが付与されます",
      "1人の招待につき1,000ポイント付与されます（上限なし）",
      "紹介ポイントの有効期限は獲得から3ヶ月間です",
    ],
    benefitDescription:
      "友達紹介プログラムを通じて獲得したポイントは、通常のお買い物だけでなく、環境保全活動への寄付にも使用できます。",
    steps: [
      "招待リンクや招待コードを友達に共有する",
      "友達がリンクからアプリをダウンロードし新規登録する",
      "友達が初回決済を完了すると両者にポイント付与",
      "マイページで獲得ポイントを確認",
    ],
    ecoImpact: {
      title: "環境への貢献",
      description:
        "友達紹介で獲得したポイントの一部は、自動的に環境保全活動に寄付されます。",
      metrics: [
        {
          label: "森林保全貢献率",
          value: "5%",
          icon: "tree",
        },
      ],
    },
    isActive: true,
    isPopular: true,
    badgeText: "進行中",
  },
];
</file>

<file path="src/features/campaigns/store/campaign.slice.ts">
import { StateCreator } from "zustand";
import { create } from "zustand";
import { Campaign } from "../types/campaign";
import { campaignsData } from "../data/campaigns-data";
import {
  findCampaignById,
  filterActiveCampaigns,
  filterPopularCampaigns,
  filterCampaignsByType,
} from "../utils/campaign-utils";

/**
 * Campaign スライスの型定義
 */
export interface CampaignSlice {
  // データ
  campaigns: Campaign[];

  // アクション
  setCampaigns: (campaigns: Campaign[]) => void;
  addCampaign: (campaign: Campaign) => void;

  // クエリ
  getCampaignById: (id: string) => Campaign | undefined;
  getActiveCampaigns: () => Campaign[];
  getPopularCampaigns: () => Campaign[];
  getCampaignsByType: (type: string) => Campaign[];
}

/**
 * Campaign スライスの作成関数
 */
export const createCampaignSlice: StateCreator<
  CampaignSlice,
  [],
  [],
  CampaignSlice
> = (set, get) => ({
  // 初期状態
  campaigns: campaignsData,

  // アクション
  setCampaigns: (campaigns) => set({ campaigns }),

  addCampaign: (campaign) =>
    set((state) => ({
      campaigns: [...state.campaigns, campaign],
    })),

  // クエリ - ユーティリティ関数を使用
  getCampaignById: (id) => {
    return findCampaignById(get().campaigns, id);
  },

  getActiveCampaigns: () => {
    return filterActiveCampaigns(get().campaigns);
  },

  getPopularCampaigns: () => {
    return filterPopularCampaigns(get().campaigns);
  },

  getCampaignsByType: (type) => {
    return filterCampaignsByType(get().campaigns, type);
  },
});

/**
 * 単独で使用可能な Campaign ストアフック
 */
export const useCampaignStore = create<CampaignSlice>()((...a) => ({
  ...createCampaignSlice(...a),
}));
</file>

<file path="src/features/campaigns/types/campaign.ts">
/**
 * キャンペーン機能の型定義
 */

/**
 * キャンペーンタイプの型
 */
export type CampaignType = "eco" | "point" | "event" | "referral";

/**
 * キャンペーン情報の型定義
 */
export interface Campaign {
  id: string;
  title: string;
  subtitle?: string;
  description: string;
  type: CampaignType;
  startDate: string;
  endDate: string;
  imageType?: string;
  pointRate?: number; // ポイント還元率（例: 20は20%を意味する）
  conditions: string[];
  benefitDescription: string;
  steps?: string[];
  relatedItems?: {
    title: string;
    description: string;
    imageType?: string;
  }[];
  ecoImpact?: {
    title: string;
    description: string;
    metrics?: Array<{
      label: string;
      value: string;
      icon: string;
    }>;
  };
  isActive: boolean;
  isPopular?: boolean;
  badgeText?: string;
}
</file>

<file path="src/features/campaigns/utils/campaign-utils.ts">
/**
 * キャンペーン関連のユーティリティ関数
 */
import { Campaign } from "../types/campaign";

/**
 * IDでキャンペーンを検索する
 */
export const findCampaignById = (
  campaigns: Campaign[],
  id: string,
): Campaign | undefined => {
  return campaigns.find((campaign) => campaign.id === id);
};

/**
 * アクティブなキャンペーンをフィルタリングする
 */
export const filterActiveCampaigns = (campaigns: Campaign[]): Campaign[] => {
  return campaigns.filter((campaign) => campaign.isActive);
};

/**
 * 人気のキャンペーンをフィルタリングする
 */
export const filterPopularCampaigns = (campaigns: Campaign[]): Campaign[] => {
  return campaigns.filter((campaign) => campaign.isPopular);
};

/**
 * タイプでキャンペーンをフィルタリングする
 */
export const filterCampaignsByType = (
  campaigns: Campaign[],
  type: string,
): Campaign[] => {
  return campaigns.filter((campaign) => campaign.type === type);
};
</file>

<file path="src/features/campaigns/README.md">
# キャンペーン機能（Campaigns Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいたキャンペーン機能を含みます。

## ディレクトリ構造

```
campaigns/
├── README.md                 # このファイル（機能の説明）
├── components/               # UIコンポーネント
│   ├── CampaignCard/         # キャンペーンカードコンポーネント
│   └── FeaturedCampaign/     # 注目キャンペーンコンポーネント
├── data/                     # データソース
│   └── campaigns-data.ts     # キャンペーンのモックデータ
├── store/                    # 状態管理
│   └── campaign.slice.ts     # キャンペーンのZustandスライス
├── types/                    # 型定義
│   └── campaign.ts           # キャンペーンの型
├── utils/                    # ユーティリティ関数
│   └── campaign-utils.ts     # キャンペーン関連のヘルパー関数
└── index.ts                  # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // 型
  Campaign,
  CampaignType,

  // ストア
  useCampaignStore,

  // ユーティリティ関数
  findCampaignById,
  filterActiveCampaigns,
  filterPopularCampaigns,
  filterCampaignsByType,

  // コンポーネント
  CampaignCard,
  FeaturedCampaignSection,
} from "@/features/campaigns";
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. キャンペーン関連データの型定義
2. キャンペーンデータの状態管理
3. キャンペーン情報の表示と操作
4. キャンペーン関連のユーティリティ関数の提供

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- その他の共通ユーティリティ: `@/lib/utils`

## 拡張方法

キャンペーン機能を拡張する際の主なポイント：

1. 新しいキャンペーンタイプを追加する場合は、`types/campaign.ts`の`CampaignType`型を拡張
2. キャンペーンの表示方法を追加する場合は、`components/`ディレクトリに新しいコンポーネントを作成
3. キャンペーンデータの操作に新しい機能が必要な場合は、`utils/campaign-utils.ts`に追加
4. ストアに新しいアクションやクエリを追加する場合は、`store/campaign.slice.ts`を更新
</file>

<file path="src/features/charge/components/BankTransferSection/index.ts">
export { BankTransferSection } from "./BankTransferSection";
export type { BankTransferSectionProps } from "./BankTransferSection";
</file>

<file path="src/features/charge/components/ChargeComplete/ChargeComplete.tsx">
import { Button } from "@/components/ui/button";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { CheckCircle, Leaf } from "lucide-react";
import { Session } from "next-auth";
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";

interface ChargeCompleteProps {
  amount: string;
  paymentMethod: "credit-card" | "bank";
  session: Session | null;
  transactionId: string;
  transferCode?: string;
  router: AppRouterInstance;
}

export function ChargeComplete({
  amount,
  paymentMethod,
  session,
  transactionId,
  transferCode,
  router,
}: ChargeCompleteProps) {
  return (
    <>
      <CardHeader className="pb-2">
        <CardTitle className="text-xl text-teal-800">チャージ完了</CardTitle>
        <CardDescription>
          {paymentMethod === "credit-card"
            ? "チャージが正常に完了しました"
            : "振込確認が完了しました"}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4 flex flex-col items-center">
        <div className="bg-teal-50 rounded-full p-4 w-20 h-20 flex items-center justify-center">
          <CheckCircle className="h-12 w-12 text-teal-600" />
        </div>

        <div className="text-center">
          <h3 className="text-lg font-medium text-stone-800">
            ¥{Number(amount).toLocaleString()}が
            {paymentMethod === "credit-card" ? "チャージ" : "振込確認"}
            されました
          </h3>
          <p className="text-sm text-stone-600 mt-1">
            現在の残高: ¥{(session?.user?.balance || 0).toLocaleString()}
          </p>
        </div>

        <div className="bg-stone-50 p-3 rounded-md w-full">
          <div className="text-xs text-stone-600">取引ID: {transactionId}</div>
          <div className="text-xs text-stone-600">
            日時: {new Date().toLocaleString("ja-JP")}
          </div>
          {paymentMethod === "bank" && transferCode && (
            <div className="text-xs text-stone-600">
              振込コード: {transferCode}
            </div>
          )}
        </div>

        <div className="bg-teal-50 p-3 rounded-md border border-teal-100 w-full">
          <div className="flex items-start">
            <Leaf className="h-4 w-4 text-teal-600 mt-0.5 mr-2" />
            <div className="text-xs text-teal-700">
              この
              {paymentMethod === "credit-card" ? "チャージ" : "振込"}
              により、¥
              {Math.floor(Number(amount) * 0.005).toLocaleString()}が
              環境保全活動に寄付されました。ご協力ありがとうございます。
            </div>
          </div>
        </div>
      </CardContent>
      <CardFooter className="flex flex-col space-y-2">
        <Button
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          onClick={() => router.push("/")}
        >
          ホームに戻る
        </Button>
        <Button
          variant="outline"
          className="w-full text-stone-600"
          onClick={() => router.push("/history")}
        >
          取引履歴を確認
        </Button>
      </CardFooter>
    </>
  );
}
</file>

<file path="src/features/charge/components/ChargeComplete/index.ts">
export { ChargeComplete } from "./ChargeComplete";
</file>

<file path="src/features/charge/components/ChargeConfirm/index.ts">
export { ChargeConfirm } from "./ChargeConfirm";
</file>

<file path="src/features/charge/components/ChargeInput/index.ts">
export { ChargeInputContainer } from "./ChargeInputContainer";
export type { ChargeInputContainerProps } from "./ChargeInputContainer";

export { ChargeInputForm } from "./ChargeInputForm";
export type { ChargeInputFormProps } from "./ChargeInputForm";

export { AmountInput } from "./AmountInput";
export type { AmountInputProps } from "./AmountInput";

export { BankTransferInput } from "./BankTransferInput";
export type { BankTransferInputProps } from "./BankTransferInput";
</file>

<file path="src/features/charge/types/charge.ts">
/**
 * チャージ機能の型定義
 */

/**
 * チャージメソッド（入金方法）の型
 */
export type ChargeMethod =
  | "bank_transfer"
  | "credit_card"
  | "convenience_store"
  | "direct_debit";

/**
 * チャージステップの型
 */
export type ChargeStep = "input" | "confirm" | "complete";

/**
 * チャージデータの型
 */
export interface ChargeData {
  /** チャージ金額 */
  amount: number;
  /** チャージ方法 */
  method: ChargeMethod;
  /** 処理ID */
  processingId?: string;
  /** 処理日時 */
  processedAt?: string;
  /** 手数料 */
  fee?: number;
  /** エコポイントへの変換率 */
  conversionRate?: number;
  /** 獲得エコポイント */
  ecoPoints?: number;
  /** 取引ステータス */
  status?: "pending" | "completed" | "failed";
  /** バンク情報 (銀行振込の場合) */
  bankInfo?: BankTransferInfo;
  /** クレジットカード情報 (カード決済の場合) */
  cardInfo?: CardInfo;
}

/**
 * 銀行振込情報の型
 */
export interface BankTransferInfo {
  /** 銀行名 */
  bankName: string;
  /** 支店名 */
  branchName: string;
  /** 口座種別 */
  accountType: "普通" | "当座";
  /** 口座番号 */
  accountNumber: string;
  /** 口座名義 */
  accountHolder: string;
  /** 振込期限 */
  deadline?: string;
  /** 振込先メモ */
  transferMemo?: string;
}

/**
 * カード情報の型
 */
export interface CardInfo {
  /** カード会社 */
  brand: string;
  /** カード番号(マスクされたもの) */
  maskedNumber: string;
  /** 有効期限 */
  expiryDate: string;
  /** カード名義 */
  holderName?: string;
}
</file>

<file path="src/features/charge/README.md">
# チャージ機能（Charge Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいたチャージ機能を含みます。

## ディレクトリ構造

```
charge/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── BankTransferSection/    # 銀行振込セクション
│   └── ChargeInput/            # チャージ入力関連コンポーネント
│       ├── AmountInput.tsx     # 金額入力コンポーネント
│       ├── BankTransferInput.tsx # 銀行振込入力コンポーネント
│       ├── ChargeInputContainer.tsx # コンテナコンポーネント
│       ├── ChargeInputForm.tsx # フォーム表示コンポーネント
│       └── index.ts           # 公開API
├── types/                      # 型定義
│   └── charge.ts               # チャージ関連の型定義
├── utils/                      # ユーティリティ関数（将来的に追加予定）
├── store/                      # 状態管理（将来的に追加予定）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // 型定義
  ChargeMethod,
  ChargeStep,
  ChargeData,

  // コンポーネント
  ChargeInputContainer,
  BankTransferSection,

  // コンポーネントプロパティ型
  ChargeInputContainerProps,
  BankTransferSectionProps,
} from "@/features/charge";
```

### コンポーネント例

#### チャージ入力コンテナ

```tsx
<ChargeInputContainer onProceedToConfirm={(amount) => handleConfirm(amount)} />
```

#### 銀行振込セクション

```tsx
<BankTransferSection
  email={userEmail}
  setEmail={setUserEmail}
  amount={chargeAmount}
  setAmount={setChargeAmount}
  emailSent={isEmailSent}
  setEmailSent={setIsEmailSent}
  isLoading={loading}
  isValidEmail={validEmail}
  isValidAmount={validAmount}
  error={errorMessage}
  handleSelectAmount={handleAmountSelection}
  handleSendBankTransferEmail={sendBankTransferEmail}
  transferCode={code}
  setTransferCode={setCode}
  processingVerification={verifying}
  handleNotifyBankTransfer={notifyTransfer}
/>
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. チャージ金額入力フォームの提供
2. 銀行振込プロセスの管理
3. チャージ金額のバリデーション
4. チャージ確認および完了フローの制御

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 共通ユーティリティ: `@/lib/utils/validation`
- アイコン: `lucide-react`

## 拡張予定

今後、以下の機能を追加予定です：

1. チャージ履歴の管理機能
2. 定期チャージ機能
3. クレジットカード決済の詳細実装
4. QRコード決済対応
</file>

<file path="src/features/donation/components/DonateComplete/DonateComplete.tsx">
import { Button } from "@/components/ui/button";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { CheckCircle, Leaf, Trophy } from "lucide-react";
import { Session } from "next-auth";
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";
import { formatCurrency } from "@/shared/utils/formats";
import { DonationProject } from "@/features/donation/types/donation";

interface DonateCompleteProps {
  project: DonationProject;
  amount: string;
  session: Session | null;
  transactionId: string;
  router: AppRouterInstance;
}

export function DonateComplete({
  project,
  amount,
  session,
  transactionId,
  router,
}: DonateCompleteProps) {
  const donationAmount = Number(amount);

  const estimatedImpact = {
    forestArea:
      project.imageType === "mountain"
        ? donationAmount * 0.0007
        : donationAmount * 0.0003,
    waterSaved:
      project.imageType === "ocean"
        ? donationAmount * 0.4
        : donationAmount * 0.2,
    co2Reduction: donationAmount * 0.015,
  };

  return (
    <>
      <CardHeader className="pb-2">
        <CardTitle className="text-xl text-teal-800">寄付完了</CardTitle>
        <CardDescription>ご寄付いただきありがとうございます</CardDescription>
      </CardHeader>

      <CardContent className="space-y-4 flex flex-col items-center">
        <div className="bg-teal-50 rounded-full p-4 w-20 h-20 flex items-center justify-center">
          <CheckCircle className="h-12 w-12 text-teal-600" />
        </div>

        <div className="text-center">
          <h3 className="text-lg font-medium text-stone-800">
            {formatCurrency(donationAmount)}を寄付しました
          </h3>
          <p className="text-sm text-stone-600 mt-1">寄付先: {project.title}</p>
          <p className="text-sm text-stone-600">
            現在の残高: {formatCurrency(session?.user?.balance || 0)}
          </p>
        </div>

        <div className="bg-stone-50 p-3 rounded-md w-full">
          <div className="text-xs text-stone-600">取引ID: {transactionId}</div>
          <div className="text-xs text-stone-600">
            日時: {new Date().toLocaleString("ja-JP")}
          </div>
        </div>

        <div className="w-full bg-teal-50 p-4 rounded-md border border-teal-100">
          <div className="flex items-start space-x-3">
            <Trophy className="h-5 w-5 text-teal-600 mt-0.5" />
            <div>
              <h3 className="text-sm font-medium text-teal-800">
                環境貢献効果
              </h3>
              <p className="text-xs text-teal-700 mt-1">
                あなたの寄付により、以下の環境保全効果が生まれました:
              </p>
              <ul className="mt-2 space-y-1 text-xs text-teal-700">
                <li>
                  森林保全面積: {estimatedImpact.forestArea.toFixed(2)} m²
                </li>
                <li>水資源保全: {Math.round(estimatedImpact.waterSaved)} L</li>
                <li>CO2削減量: {estimatedImpact.co2Reduction.toFixed(1)} kg</li>
              </ul>
              <p className="text-xs text-teal-700 mt-2">
                これまでの累計寄付額: {formatCurrency(donationAmount)}
              </p>
            </div>
          </div>
        </div>
      </CardContent>

      <CardFooter className="flex flex-col space-y-2">
        <Button
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          onClick={() => router.push("/impact")}
        >
          <Leaf className="h-4 w-4 mr-2" />
          環境インパクト詳細を見る
        </Button>
        <Button
          variant="outline"
          className="w-full text-stone-600"
          onClick={() => router.push("/")}
        >
          ホームに戻る
        </Button>
      </CardFooter>
    </>
  );
}
</file>

<file path="src/features/donation/components/DonateComplete/index.ts">
export { DonateComplete } from "./DonateComplete";
</file>

<file path="src/features/donation/components/DonateConfirm/index.ts">
export { DonateConfirm } from "./DonateConfirm";
</file>

<file path="src/features/donation/components/DonateInput/AmountSelector.tsx">
"use client";

import React from "react";
import { Button } from "@/components/ui/button";

interface AmountSelectorProps {
  onSelectAmount: (value: string) => void;
}

// 金額クイック選択コンポーネント
export const AmountSelector = React.memo(
  ({ onSelectAmount }: AmountSelectorProps) => {
    return (
      <div className="flex justify-between text-sm text-stone-600 px-1">
        <span>おすすめ金額:</span>
        <div className="space-x-2">
          <Button
            variant="outline"
            size="sm"
            className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
            onClick={() => onSelectAmount("1000")}
          >
            1,000円
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
            onClick={() => onSelectAmount("5000")}
          >
            5,000円
          </Button>
        </div>
      </div>
    );
  },
);

AmountSelector.displayName = "AmountSelector";
</file>

<file path="src/features/donation/components/DonateInput/index.ts">
export { DonateInputContainer } from "./DonateInputContainer";
export { DonateInputForm } from "./DonateInputForm";
export { AmountSelector } from "./AmountSelector";
export { ProjectInfo } from "./ProjectInfo";
</file>

<file path="src/features/donation/components/DonateInput/ProjectInfo.tsx">
"use client";

import React from "react";
import { Progress } from "@/components/ui/progress";
import { DonationProject } from "../../types/donation";

interface ProjectInfoProps {
  project: DonationProject;
}

// プロジェクト情報表示専用のプレゼンテーションコンポーネント
export const ProjectInfo = React.memo(({ project }: ProjectInfoProps) => {
  // プロジェクトタイプに基づくアイコンの取得
  const getProjectIcon = () => {
    switch (project.imageType) {
      case "ocean":
        return (
          <svg
            className="h-16 w-16 text-blue-500 opacity-80"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <path d="M2 12h20" />
            <path d="M5 12c.5-4.5 4-8 10-8" />
            <path d="M7 12c.5-2.5 2-5 5-5" />
            <path d="M19 12c-.5-4.5-4-8-10-8" />
            <path d="M17 12c-.5-2.5-2-5-5-5" />
            <path d="M2 12c0 4.5 3.5 8 8 9" />
            <path d="M22 12c0 4.5-3.5 8-8 9" />
          </svg>
        );
      case "mountain":
      case "forest":
      default:
        return (
          <svg
            className="h-16 w-16 text-teal-700 opacity-80"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <path d="M8 3v4l-4 4" />
            <path d="M4 11v4h4" />
            <path d="M4 15l6 6" />
            <path d="M14 15l6 6" />
            <path d="M8 21h8" />
            <path d="M16 3v4l4 4" />
            <path d="M20 11v4h-4" />
            <path d="M8 3h8" />
          </svg>
        );
    }
  };

  return (
    <div className="bg-gradient-to-br from-teal-50 to-teal-100 p-4 rounded-lg border border-teal-200">
      <div className="flex items-start space-x-3">
        <div className="flex-shrink-0">{getProjectIcon()}</div>
        <div>
          <p className="text-sm text-teal-800">{project.description}</p>

          <div className="mt-3">
            <div className="flex justify-between text-xs mb-1">
              <span className="text-stone-600">進捗状況</span>
              <span className="text-teal-700 font-medium">
                {project.progressPercent}%
              </span>
            </div>
            <Progress
              value={project.progressPercent}
              className="h-1.5 bg-teal-100"
            />
            <div className="flex justify-between text-xs mt-1">
              <span className="text-teal-800 font-medium">
                ¥{project.currentAmount.toLocaleString()}
              </span>
              <span className="text-stone-500">
                目標: ¥{project.targetAmount.toLocaleString()}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
});

ProjectInfo.displayName = "ProjectInfo";
</file>

<file path="src/features/donation/data/projects-data.ts">
import { DonationProject } from "../types/donation";

/**
 * 寄付プロジェクトのモックデータ
 */
export const donationProjects: DonationProject[] = [
  {
    id: "project_1",
    title: "山岳環境保全プロジェクト",
    description: "登山道の整備や森林再生などを通じて山岳環境の保全を目指します",
    category: "プロジェクト",
    currentAmount: 4500,
    targetAmount: 10000,
    progressPercent: 45,
    imageType: "mountain",
    organization: "日本山岳環境保全協会",
    endDate: "2025/12/31",
    impact: {
      forestArea: 5,
      co2Reduction: 100,
      waterSaved: 50000,
      beneficiaries: 1000,
    },
  },
  {
    id: "project_2",
    title: "海洋プラスチック削減イニシアチブ",
    description:
      "海洋プラスチックの削減と海岸の清掃活動を通じて海の生態系を守ります",
    category: "プロジェクト",
    currentAmount: 7950,
    targetAmount: 15000,
    progressPercent: 53,
    imageType: "ocean",
    organization: "海洋保護基金",
    endDate: "2025/09/30",
    impact: {
      forestArea: 0,
      co2Reduction: 50,
      waterSaved: 100000,
      beneficiaries: 5000,
    },
  },
];
</file>

<file path="src/features/donation/README.md">
# Donation 機能

## 概要

`donation` 機能は、環境保全プロジェクトへの寄付に関する機能を提供します。ユーザーが環境保全プロジェクトに寄付を行い、その環境インパクトを追跡できる機能群を含んでいます。

## アーキテクチャ

### 設計方針

- **Container/Presentation パターン**: ビジネスロジックとUI表示を分離
- **型安全性**: TypeScriptの厳密な型チェックを活用
- **再利用性**: 他の機能からも利用可能なモジュラー設計

### ディレクトリ構造

```
src/features/donation/
├── components/           # UIコンポーネント
│   └── DonateInput/     # 寄付入力フォーム関連
│       ├── DonateInputContainer.tsx
│       ├── DonateInputForm.tsx
│       ├── AmountSelector.tsx
│       ├── ProjectInfo.tsx
│       └── index.ts
├── types/               # 型定義
│   └── donation.ts
├── hooks/               # カスタムフック
├── store/               # 状態管理
├── utils/               # ユーティリティ関数
├── data/                # モックデータ・定数
├── index.ts             # 公開API
└── README.md           # このファイル
```

## コンポーネント

### DonateInput

寄付金額の入力と確認を行うコンポーネント群です。

#### DonateInputContainer

- **役割**: 状態管理とビジネスロジック
- **責任**: フォーム状態、バリデーション、データ送信処理
- **Props**:
  - `project: DonationProject` - 寄付対象のプロジェクト
  - `onProceed: (amount: number) => void` - 次のステップへの進行処理

#### DonateInputForm

- **役割**: UI表示のみ（プレゼンテーション）
- **責任**: フォームの見た目とユーザーインタラクション
- **特徴**:
  - 金額入力フィールド
  - クイック選択ボタン
  - プロジェクト情報表示
  - エラーメッセージ表示

#### AmountSelector

- **役割**: 金額のクイック選択UI
- **機能**: よく使われる金額（1,000円、5,000円など）をワンクリックで選択

#### ProjectInfo

- **役割**: プロジェクト詳細情報の表示
- **表示内容**: プロジェクト説明、進捗状況、目標金額等

## 型定義

### DonationProject

```typescript
interface DonationProject {
  id: string;
  title: string;
  description: string;
  category: string;
  targetAmount: number;
  currentAmount: number;
  progressPercent: number;
  imageType?: "forest" | "ocean" | "mountain" | "city";
  organization: string;
  endDate: string;
  impact: {
    forestArea?: number;
    co2Reduction?: number;
    waterSaved?: number;
    beneficiaries?: number;
  };
}
```

### DonationInfo

```typescript
interface DonationInfo {
  projectId: string;
  amount: number;
  donorName?: string;
  message?: string;
  isAnonymous: boolean;
  paymentMethod: "balance" | "credit" | "bank";
}
```

## 使用方法

### 基本的な使用例

```typescript
import { DonateInputContainer, DonationProject } from '@/features/donation';

function MyComponent() {
  const project: DonationProject = {
    // プロジェクトデータ
  };

  const handleProceed = (amount: number) => {
    // 次のステップの処理
  };

  return (
    <DonateInputContainer
      project={project}
      onProceed={handleProceed}
    />
  );
}
```

### 公開API

```typescript
// 型定義
export * from "./types/donation";

// コンポーネント
export {
  DonateInputContainer,
  DonateInputForm,
  AmountSelector,
  ProjectInfo,
} from "./components/DonateInput";
```

## 下位互換性

既存のコンポーネントとの互換性を保つため、以下のブリッジコンポーネントが提供されています：

- `src/components/donation/DonateInput/index.tsx`
- `src/components/donation/DonateProjectInput.tsx`

これらは新しい実装への橋渡しを行い、段階的な移行を可能にします。

## 依存関係

### 内部依存

- `@/features/balance` - 残高情報の取得
- `@/features/eco-impact` - 環境インパクトの計算（将来的に連携予定）

### 外部依存

- `@/components/ui/*` - UIプリミティブ
- `@/lib/utils/*` - ユーティリティ関数
- `zustand` - 状態管理（将来的に使用予定）

## 開発ガイドライン

### コンポーネント作成時の注意点

1. **Container/Presentation分離**: ロジックとUIを明確に分離する
2. **型安全性**: 全てのPropsとStateに適切な型を定義する
3. **再利用性**: 他の機能でも使える汎用的な設計を心がける
4. **テスタビリティ**: ユニットテストが書きやすい構造にする

### ファイル命名規則

- コンポーネント: PascalCase (`DonateInputContainer.tsx`)
- フック: camelCase + use接頭辞 (`useDonation.ts`)
- 型定義: PascalCase (`DonationProject`)
- ユーティリティ: camelCase (`formatDonationAmount.ts`)

## 今後の拡張予定

1. **確認画面コンポーネント**: 寄付内容の確認UI
2. **完了画面コンポーネント**: 寄付完了後のサンクスページ
3. **状態管理**: Zustandを使った寄付フローの状態管理
4. **バリデーション**: より詳細な入力バリデーション
5. **テスト**: コンポーネントとロジックのユニットテスト
</file>

<file path="src/features/eco-impact/components/CompactEcoImpact/CompactEcoImpact.tsx">
"use client";

import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import Link from "next/link";
import { Leaf, TreePine, Droplets, Wind } from "lucide-react";
import { useEcoImpact } from "../../hooks/useEcoImpact";

interface CompactEcoImpactProps {
  contributionAmount: number;
  showBorder?: boolean;
  // 互換性のために残しておくが、内部では clickable に変換
  disableLink?: boolean;
  // 新しいプロパティも追加（オプション）
  clickable?: boolean;
  className?: string;
}

/**
 * コンパクトな環境貢献表示コンポーネント
 */
export function CompactEcoImpact({
  contributionAmount,
  showBorder = true,
  disableLink = false,
  // clickable プロパティが明示的に指定されていればそれを使用
  clickable,
  className = "",
}: CompactEcoImpactProps) {
  // clickable が明示的に指定されていればそれを使い、
  // そうでなければ disableLink の反対の値を使用
  const isClickable = clickable !== undefined ? clickable : !disableLink;

  // 環境貢献計算カスタムフックを使用
  const { forestArea, waterSaved, co2Reduction, impactPercent } =
    useEcoImpact(contributionAmount);

  // カード内のコンテンツを作成
  const content = (
    <div className={`relative ${className}`}>
      <div className="p-3 rounded-lg">
        <div className="flex items-center mb-2 text-teal-700">
          <Leaf className="h-4 w-4 mr-1" />
          <h3 className="text-sm font-medium">環境への貢献</h3>
        </div>

        <Progress value={impactPercent} className="h-1.5 mb-3" />

        <div className="grid grid-cols-3 gap-1 text-xs">
          <div className="flex flex-col items-center bg-teal-50 p-1.5 rounded">
            <TreePine className="h-3.5 w-3.5 text-teal-600 mb-1" />
            <div className="font-medium text-teal-900">{forestArea} m²</div>
            <div className="text-[10px] text-teal-600">森林保全</div>
          </div>

          <div className="flex flex-col items-center bg-blue-50 p-1.5 rounded">
            <Droplets className="h-3.5 w-3.5 text-blue-600 mb-1" />
            <div className="font-medium text-blue-900">{waterSaved} L</div>
            <div className="text-[10px] text-blue-600">水資源節約</div>
          </div>

          <div className="flex flex-col items-center bg-green-50 p-1.5 rounded">
            <Wind className="h-3.5 w-3.5 text-green-600 mb-1" />
            <div className="font-medium text-green-900">{co2Reduction} kg</div>
            <div className="text-[10px] text-green-600">CO2削減</div>
          </div>
        </div>
      </div>
    </div>
  );

  // リンクとして表示するかどうかで分岐
  if (isClickable) {
    return (
      <Link href="/impact">
        <Card
          className={`hover:shadow-md transition-shadow ${!showBorder ? "border-0 shadow-none" : ""}`}
        >
          {content}
        </Card>
      </Link>
    );
  }

  // クリック不可の場合はシンプルなカード
  return (
    <Card className={!showBorder ? "border-0 shadow-none" : ""}>{content}</Card>
  );
}
</file>

<file path="src/features/eco-impact/components/CompactEcoImpact/index.ts">
export { CompactEcoImpact } from "./CompactEcoImpact";
</file>

<file path="src/features/eco-impact/components/EcoContributionSummary/EcoContributionSummary.tsx">
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Leaf, Trees, Users } from "lucide-react";
import { useEcoImpactStore } from "@/features/eco-impact/store/eco-impact.slice";
import { formatCurrency } from "@/shared/utils/formats";

export function EcoContributionSummary() {
  const { totalDonation, forestArea, co2Reduction } = useEcoImpactStore();

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Leaf className="h-5 w-5 text-green-600" />
          環境貢献サマリー
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="p-4 bg-green-50 rounded-lg">
            <p className="text-sm text-muted-foreground">総貢献額</p>
            <p className="text-2xl font-bold text-green-600">
              {formatCurrency(totalDonation)}
            </p>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-green-100 rounded-full">
                <Trees className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <p className="text-xs text-muted-foreground">植樹本数</p>
                <p className="text-lg font-semibold">
                  {Math.floor(forestArea)}本
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <div className="p-2 bg-blue-100 rounded-full">
                <Users className="h-5 w-5 text-blue-600" />
              </div>
              <div>
                <p className="text-xs text-muted-foreground">CO₂削減量</p>
                <p className="text-lg font-semibold">
                  {co2Reduction.toFixed(1)}kg
                </p>
              </div>
            </div>
          </div>

          <div className="p-3 bg-amber-50 rounded-lg border border-amber-200">
            <p className="text-xs text-amber-700">
              これまでの環境貢献により、{Math.floor(forestArea * 0.3)}人分の
              年間CO₂排出量を相殺しました
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/eco-impact/components/EcoContributionSummary/index.ts">
export { EcoContributionSummary } from "./EcoContributionSummary";
</file>

<file path="src/features/eco-impact/components/EcoImpact/index.ts">
export { EcoImpactDisplay } from "./EcoImpactDisplay";
</file>

<file path="src/features/eco-impact/components/NewsAndProjects/index.ts">
export { NewsAndProjects } from "./NewsAndProjects";
</file>

<file path="src/features/eco-impact/components/RecommendedAction/index.ts">
export { RecommendedAction } from "./RecommendedAction";
</file>

<file path="src/features/eco-impact/components/TransactionEcoImpact/index.ts">
export { TransactionEcoImpact } from "./TransactionEcoImpact";
</file>

<file path="src/features/eco-impact/components/TransactionEcoImpact/TransactionEcoImpact.tsx">
"use client";

import React from "react";
import { EcoImpactDisplay } from "../EcoImpact/EcoImpactDisplay";

interface TransactionEcoImpactProps {
  contributionAmount: number;
  compact?: boolean;
  clickable?: boolean;
  className?: string;
}

export function TransactionEcoImpact({
  contributionAmount,
  compact = false,
  clickable = false,
  className = "",
}: TransactionEcoImpactProps) {
  return (
    <EcoImpactDisplay
      contributionAmount={contributionAmount}
      variant={compact ? "compact" : "transaction"}
      clickable={clickable}
      className={className}
    />
  );
}
</file>

<file path="src/features/eco-impact/data/eco-impact-data.ts">
export interface EcoImpactData {
  forestArea: number;
  waterSaved: number;
  co2Reduction: number;
  progressPercent: number;
  targetForestArea: number;
  targetWaterSaved: number;
  targetCo2Reduction: number;
  totalDonation: number;
  monthlyDonation: number;
}

export const ecoImpactData: EcoImpactData = {
  forestArea: 5.2,
  waterSaved: 450,
  co2Reduction: 25,
  progressPercent: 42,
  targetForestArea: 10,
  targetWaterSaved: 1500,
  targetCo2Reduction: 100,
  totalDonation: 12450,
  monthlyDonation: 850,
};
</file>

<file path="src/features/eco-impact/data/recommended-actions-data.ts">
export interface RecommendedActionItem {
  id: string;
  title: string;
  description: string;
  actionLabel: string;
  actionLink: string;
  icon: string;
  priority: number;
}

export const recommendedActions: RecommendedActionItem[] = [
  {
    id: "action_1",
    title: "今月のおすすめアクション",
    description:
      "決済額からの環境貢献を3%に増やすと、1ヶ月で森林保全面積を約2m²追加できます。",
    actionLabel: "環境貢献を増やす",
    actionLink: "/settings?tab=eco",
    icon: "leaf",
    priority: 3,
  },
  {
    id: "action_2",
    title: "環境貢献レポートの受け取り",
    description:
      "毎月の環境貢献レポートを受け取ることで、あなたの取り組みの成果を確認できます。",
    actionLabel: "設定を変更する",
    actionLink: "/settings?tab=notifications",
    icon: "mail",
    priority: 2,
  },
  {
    id: "action_3",
    title: "友達紹介で環境保全に貢献",
    description:
      "友達を紹介すると、紹介した方も紹介された方も1,000円分のエコポイントを獲得できます。",
    actionLabel: "友達を招待する",
    actionLink: "/invite",
    icon: "users",
    priority: 1,
  },
];
</file>

<file path="src/features/eco-impact/hooks/useEcoImpact.ts">
"use client";

/**
 * 環境インパクト計算と管理に関するカスタムフック
 */
import { useMemo } from "react";
import { useEcoImpactStore } from "../store/eco-impact.slice";
import {
  calculateEcoImpact,
  getEcoRankFromDonation,
} from "../utils/calculations";
import { EcoRank } from "../types/eco-impact";

/**
 * 環境貢献に関するデータを提供するカスタムフック
 * 特定の寄付額を指定するか、ストアの総額を使用
 *
 * @param contributionAmount オプションの寄付金額
 */
export function useEcoImpact(contributionAmount?: number) {
  const ecoStore = useEcoImpactStore();

  // 環境インパクト計算（指定された金額または状態の合計から）
  const impact = useMemo(() => {
    const amount = contributionAmount ?? ecoStore.totalDonation;
    return calculateEcoImpact(amount);
  }, [contributionAmount, ecoStore.totalDonation]);

  // 進捗率計算
  const impactPercent = useMemo(
    () =>
      Math.min(
        100,
        Math.round(
          ((contributionAmount ?? ecoStore.totalDonation) / 1000) * 100,
        ),
      ),
    [contributionAmount, ecoStore.totalDonation],
  );

  // 環境ランク計算
  const ecoRank = useMemo<EcoRank>(
    () =>
      contributionAmount
        ? getEcoRankFromDonation(contributionAmount)
        : ecoStore.getEcoRank(),
    [contributionAmount, ecoStore],
  );

  return {
    ...impact,
    impactPercent,
    ecoRank,
    totalContribution: contributionAmount ?? ecoStore.totalDonation,
    // 現在のストア状態へのアクセス
    forestArea: ecoStore.forestArea,
    waterSaved: ecoStore.waterSaved,
    co2Reduction: ecoStore.co2Reduction,
    // ストアのアクションも公開
    addContribution: ecoStore.addContribution,
    updateProgress: ecoStore.updateProgress,
  };
}
</file>

<file path="src/features/eco-impact/types/eco-impact.ts">
/**
 * エコインパクト機能の型定義
 */

/**
 * 環境貢献ランクの型
 */
export type EcoRank =
  | "エコビギナー"
  | "エコフレンド"
  | "エコマイスター"
  | "エコチャンピオン";

/**
 * 環境貢献パラメータの型
 */
export interface ContributionParams {
  amount: number;
  forestArea?: number;
  waterSaved?: number;
  co2Reduction?: number;
}

/**
 * 環境インパクト計算結果の型
 */
export interface EcoImpactCalculation {
  forestArea: number;
  waterSaved: number;
  co2Reduction: number;
}
</file>

<file path="src/features/eco-impact/utils/calculations.ts">
import {
  EcoRank,
  ContributionParams,
  EcoImpactCalculation,
} from "../types/eco-impact";
import { EcoImpactSlice } from "../store/eco-impact.slice";

/**
 * 寄付額から環境インパクトを計算
 *
 * @param amount 寄付額 (円)
 */
export function calculateEcoImpact(amount: number): EcoImpactCalculation {
  // 換算係数（仮定値）
  const FOREST_FACTOR = 0.00042; // 1円あたり何平方メートルの森林が保全できるか
  const WATER_FACTOR = 0.036; // 1円あたり何リットルの水が節約できるか
  const CO2_FACTOR = 0.002; // 1円あたり何kgのCO2が削減できるか

  return {
    forestArea: parseFloat((amount * FOREST_FACTOR).toFixed(1)),
    waterSaved: Math.round(amount * WATER_FACTOR),
    co2Reduction: Math.round(amount * CO2_FACTOR),
  };
}

/**
 * 寄付額から環境貢献ランクを算出
 *
 * @param donation 寄付総額 (円)
 */
export function getEcoRankFromDonation(donation: number): EcoRank {
  if (donation >= 50000) return "エコチャンピオン";
  if (donation >= 10000) return "エコマイスター";
  if (donation >= 5000) return "エコフレンド";
  return "エコビギナー";
}

/**
 * 環境貢献の進捗率を計算
 */
export function calculateEcoProgress(
  forestArea: number,
  waterSaved: number,
  co2Reduction: number,
  targetForestArea: number,
  targetWaterSaved: number,
  targetCo2Reduction: number,
): number {
  // 各指標の進捗率を計算
  const forestProgress = (forestArea / targetForestArea) * 100;
  const waterProgress = (waterSaved / targetWaterSaved) * 100;
  const co2Progress = (co2Reduction / targetCo2Reduction) * 100;

  // 平均進捗率を計算し、整数に丸める
  return Math.round((forestProgress + waterProgress + co2Progress) / 3);
}

/**
 * 新しい環境貢献を追加した後の状態を計算
 */
export function calculateContribution(
  state: EcoImpactSlice,
  params: ContributionParams,
): Partial<EcoImpactSlice> {
  const { amount, forestArea = 0, waterSaved = 0, co2Reduction = 0 } = params;

  // 自動計算の場合はデフォルト係数を使用
  let forestAreaToAdd = forestArea;
  let waterSavedToAdd = waterSaved;
  let co2ReductionToAdd = co2Reduction;

  // もし外部から値が指定されていなければ自動計算
  if (forestArea === 0 && waterSaved === 0 && co2Reduction === 0) {
    const impact = calculateEcoImpact(amount);
    forestAreaToAdd = impact.forestArea;
    waterSavedToAdd = impact.waterSaved;
    co2ReductionToAdd = impact.co2Reduction;
  }

  // 新しい値を計算
  const newForestArea = parseFloat(
    (state.forestArea + forestAreaToAdd).toFixed(1),
  );
  const newWaterSaved = state.waterSaved + waterSavedToAdd;
  const newCo2Reduction = state.co2Reduction + co2ReductionToAdd;
  const newTotalDonation = state.totalDonation + amount;

  // 進捗率を再計算
  const newProgressPercent = calculateEcoProgress(
    newForestArea,
    newWaterSaved,
    newCo2Reduction,
    state.targetForestArea,
    state.targetWaterSaved,
    state.targetCo2Reduction,
  );

  return {
    forestArea: newForestArea,
    waterSaved: newWaterSaved,
    co2Reduction: newCo2Reduction,
    totalDonation: newTotalDonation,
    progressPercent: newProgressPercent,
  };
}
</file>

<file path="src/features/eco-impact/README.md">
# エコインパクト機能（Eco Impact Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいたエコインパクト機能を含みます。

## ディレクトリ構造

```
eco-impact/
├── README.md             # このファイル（機能の説明）
├── components/           # UIコンポーネント
│   └── CompactEcoImpact/ # コンパクト表示コンポーネント
├── hooks/                # 機能固有のカスタムフック
│   └── useEcoImpact.ts   # エコインパクト管理フック
├── store/                # 状態管理
│   └── eco-impact.slice.ts # エコインパクトのZustandスライス
├── types/                # 型定義
│   └── eco-impact.ts     # エコインパクトの型
├── utils/                # ユーティリティ関数
│   └── calculations.ts   # 環境影響計算関数
└── index.ts              # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // 型
  EcoRank,
  ContributionParams,
  EcoImpactCalculation,

  // ストア
  useEcoImpactStore,

  // フック
  useEcoImpact,

  // ユーティリティ関数
  calculateEcoImpact,
  getEcoRankFromDonation,

  // コンポーネント
  CompactEcoImpact,
} from "@/features/eco-impact";
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. 環境貢献データの型定義
2. 環境貢献データの状態管理
3. 環境影響の計算と表示
4. 環境貢献ランクの管理

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- モックデータ: `@/lib/mock-data/eco-impact`

## 拡張方法

より高度な環境インパクト表示やレポートを追加する場合は、このディレクトリ内に適切なコンポーネントを作成し、`index.ts`から公開してください。
</file>

<file path="src/features/eco-news/components/NewsDetail/index.ts">
export { NewsDetail } from "./NewsDetail";
export { RelatedNews } from "./RelatedNews";
</file>

<file path="src/features/eco-news/components/NewsDetail/NewsDetail.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import {
  ArrowLeft,
  Calendar,
  Share2,
  Leaf,
  TreePine,
  Droplets,
} from "lucide-react";
import { NewsItem, ContentItem } from "../../types/eco-news";
import { RelatedNews } from "./RelatedNews";

interface NewsDetailProps {
  newsItem: NewsItem;
  allItems: ContentItem[];
}

export function NewsDetail({ newsItem, allItems }: NewsDetailProps) {
  const router = useRouter();

  // 背景アイコンを決定する関数
  const getBackgroundIcon = (imageType?: string) => {
    switch (imageType) {
      case "ocean":
        return <Droplets className="h-24 w-24 text-blue-500 opacity-30" />;
      case "mountain":
        return <TreePine className="h-24 w-24 text-green-700 opacity-30" />;
      case "forest":
      default:
        return <TreePine className="h-24 w-24 text-teal-700 opacity-30" />;
    }
  };

  // 背景色を決定する関数
  const getBackgroundGradient = (imageType?: string) => {
    switch (imageType) {
      case "ocean":
        return "from-blue-600 to-blue-500";
      case "mountain":
        return "from-green-700 to-green-600";
      case "forest":
      default:
        return "from-teal-700 to-teal-600";
    }
  };

  // 共有機能
  const handleShare = () => {
    if (navigator.share) {
      navigator
        .share({
          title: newsItem.title || "Eco Walletニュース",
          text: newsItem.content || "",
          url: window.location.href,
        })
        .catch((err) => {
          if (err.name === "AbortError" || err.message === "Share canceled") {
            return;
          }
          console.error("共有に失敗しました", err);
        });
    } else {
      navigator.clipboard
        .writeText(window.location.href)
        .then(() => alert("URLをコピーしました"))
        .catch((err) =>
          console.error("クリップボードへのコピーに失敗しました", err),
        );
    }
  };

  const allNewsItems = allItems.filter(
    (item): item is NewsItem => item.type === "news",
  );

  return (
    <div>
      <div className="mb-4">
        <Button
          variant="ghost"
          size="sm"
          className="text-stone-600"
          onClick={() => router.back()}
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          戻る
        </Button>
      </div>

      <Card className="border-0 shadow-md bg-white overflow-hidden">
        {/* ヘッダー画像エリア */}
        <div
          className={`bg-gradient-to-r ${getBackgroundGradient(newsItem.imageType)} p-6 text-white`}
        >
          <div className="flex items-center justify-center py-6">
            {getBackgroundIcon(newsItem.imageType)}
          </div>
          <h1 className="text-xl font-semibold">{newsItem.title}</h1>
          <div className="flex items-center mt-2">
            <Calendar className="h-4 w-4 mr-1" />
            <span className="text-xs">{newsItem.date}</span>
          </div>
        </div>

        {/* コンテンツエリア */}
        <div className="p-6 space-y-4">
          <div className="flex justify-between items-center">
            <Badge className="bg-blue-100 text-blue-800">
              {newsItem.category}
            </Badge>
            <Button
              variant="outline"
              size="sm"
              className="h-8 text-xs text-stone-600 border border-stone-200"
              onClick={handleShare}
            >
              <Share2 className="h-3 w-3 mr-1" />
              共有
            </Button>
          </div>

          <div className="prose prose-sm max-w-none">
            <p className="text-sm text-stone-700 whitespace-pre-line leading-relaxed">
              {newsItem.content}
            </p>
          </div>

          <Separator className="my-4" />

          {/* 環境貢献情報 */}
          <div className="bg-teal-50 border border-teal-100 rounded-md p-4">
            <div className="flex items-start space-x-3">
              <Leaf className="h-5 w-5 text-teal-600 mt-0.5" />
              <div>
                <h3 className="text-sm font-medium text-teal-800">
                  あなたにできること
                </h3>
                <p className="text-xs text-teal-700 mt-1">
                  Eco Walletを使って環境保全プロジェクトに寄付することで、
                  このニュースで取り上げられている環境問題の解決に貢献できます。
                  また、日々の買い物で環境に配慮した商品を選ぶことも大切な一歩です。
                </p>
                <div className="flex justify-end mt-2">
                  <Button
                    className="bg-teal-700 hover:bg-teal-800 text-white text-xs"
                    onClick={() => router.push("/impact")}
                  >
                    環境貢献する
                  </Button>
                </div>
              </div>
            </div>
          </div>

          {/* 関連ニュース */}
          <RelatedNews
            currentNewsId={newsItem.id}
            category={newsItem.category}
            allNews={allNewsItems}
          />
        </div>
      </Card>

      {/* 下部のボタン */}
      <div className="mt-4 flex justify-between">
        <Button
          variant="outline"
          className="border-stone-200 text-stone-600"
          onClick={() => router.push("/eco-news")}
        >
          ニュース一覧に戻る
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/features/eco-news/components/NewsDetail/RelatedNews.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { NewsItem } from "../../types/eco-news";

interface RelatedNewsProps {
  currentNewsId: string;
  category: string;
  allNews: NewsItem[];
}

export function RelatedNews({
  currentNewsId,
  category,
  allNews,
}: RelatedNewsProps) {
  const router = useRouter();

  const relatedNews = allNews
    .filter(
      (item) =>
        item.type === "news" &&
        item.id !== currentNewsId &&
        item.category === category,
    )
    .slice(0, 2);

  if (relatedNews.length === 0) {
    return null;
  }

  return (
    <div className="bg-stone-50 rounded-md p-4 mt-4">
      <h3 className="text-sm font-medium text-stone-800 mb-2">関連ニュース</h3>
      <div className="space-y-2">
        {relatedNews.map((news) => (
          <Button
            key={news.id}
            variant="outline"
            className="w-full justify-start text-left h-auto py-2 border-stone-200"
            onClick={() => router.push(`/eco-news/${news.id}`)}
          >
            <div>
              <div className="text-sm font-medium text-stone-800">
                {news.title}
              </div>
              <div className="text-xs text-stone-500">{news.date}</div>
            </div>
          </Button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/features/eco-news/components/NewsDetailPage/index.ts">
export { NewsDetailPage } from "./NewsDetailPage";
</file>

<file path="src/features/eco-news/components/NewsDetailPage/NewsDetailPage.tsx">
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { PageContainer } from "@/features/layout";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { NewsDetail } from "../NewsDetail";
import { NewsItem } from "../../types/eco-news";
import { newsAndProjects } from "../../data/eco-news-data";

export function NewsDetailPage() {
  const params = useParams();
  const newsId = params.id as string;

  const [newsItem, setNewsItem] = useState<NewsItem | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // データの取得をシミュレート
    const fetchData = async () => {
      setLoading(true);

      try {
        // 実際のAPIリクエストの代わりにモックデータを使用
        await new Promise((resolve) => setTimeout(resolve, 300)); // 遅延を追加

        const item = newsAndProjects.find(
          (item) => item.id === newsId && item.type === "news",
        ) as NewsItem | undefined;

        setNewsItem(item || null);
      } catch (error) {
        console.error("Failed to fetch news:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [newsId]);

  if (loading) {
    return (
      <PageContainer title="ニュース詳細" activeTab="eco">
        <div className="flex justify-center items-center h-40">
          <LoadingSpinner />
        </div>
      </PageContainer>
    );
  }

  if (!newsItem) {
    return (
      <PageContainer title="ニュース詳細" activeTab="eco">
        <div className="text-center py-8">
          <h2 className="text-lg font-medium text-stone-800">
            ニュースが見つかりませんでした
          </h2>
          <p className="text-sm text-stone-600 mt-2">
            このニュースは削除されたか、存在しません。
          </p>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer title="ニュース詳細" activeTab="eco">
      <NewsDetail newsItem={newsItem} allItems={newsAndProjects} />
    </PageContainer>
  );
}
</file>

<file path="src/features/eco-news/components/NewsList/index.ts">
export { NewsList } from "./NewsList";
</file>

<file path="src/features/eco-news/components/NewsList/NewsList.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { Input } from "@/components/ui/input";
import {
  Newspaper,
  ExternalLink,
  TreePine,
  Droplets,
  Globe,
  ArrowRight,
  Calendar,
  Search,
} from "lucide-react";
import { ContentItem } from "../../types/eco-news";
import { useNewsFilter } from "../../hooks/useNewsFilter";

interface NewsListProps {
  items: ContentItem[];
}

export function NewsList({ items }: NewsListProps) {
  const router = useRouter();
  const {
    filteredItems,
    statusFilter,
    setStatusFilter,
    searchQuery,
    setSearchQuery,
  } = useNewsFilter({ items });

  // 背景グラデーションを決定する関数
  const getBackgroundGradient = (item: ContentItem) => {
    if (item.type === "news") {
      if (item.imageType === "ocean") {
        return "from-blue-600 to-blue-500";
      } else if (item.imageType === "mountain") {
        return "from-green-700 to-green-600";
      }
      return "from-teal-700 to-teal-600"; // デフォルト（forest）
    } else {
      // プロジェクトタイプ
      if (item.imageType === "ocean") {
        return "from-blue-700 to-blue-500";
      } else if (item.imageType === "mountain") {
        return "from-green-700 to-green-500";
      }
      return "from-teal-700 to-teal-500"; // デフォルト（forest）
    }
  };

  // アイコンを決定する関数
  const getItemIcon = (item: ContentItem) => {
    if (item.imageType === "ocean") {
      return <Droplets className="h-16 w-16 text-white opacity-30" />;
    } else if (item.imageType === "mountain") {
      return <TreePine className="h-16 w-16 text-white opacity-30" />;
    }
    return <TreePine className="h-16 w-16 text-white opacity-30" />;
  };

  // バッジスタイルを決定する関数
  const getBadgeStyle = (item: ContentItem) => {
    if (item.type === "news") {
      return "bg-blue-100 text-blue-800 hover:bg-blue-200";
    } else {
      return "bg-green-100 text-green-800 hover:bg-green-200";
    }
  };

  // ボタンスタイルを決定する関数
  const getButtonStyle = (item: ContentItem) => {
    if (item.type === "news") {
      return "text-blue-700 border-blue-200 hover:bg-blue-50";
    } else {
      return "text-teal-700 border-teal-200 hover:bg-teal-50";
    }
  };

  // ニュース詳細ページへ遷移
  const navigateToNewsDetail = (id: string) => {
    router.push(`/eco-news/${id}`);
  };

  return (
    <div>
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-xl font-semibold text-stone-800 flex items-center">
            <Newspaper className="h-5 w-5 mr-2 text-teal-700" />
            エコニュースとプロジェクト
          </h2>
          <Button
            variant="ghost"
            size="sm"
            className="h-8 text-xs text-stone-600"
          >
            <Calendar className="h-3 w-3 mr-1" /> 期間
          </Button>
        </div>
        <p className="text-sm text-stone-600">
          環境保全に関するニュースやプロジェクトをご紹介します。持続可能な未来のために、一緒に行動しましょう。
        </p>
      </div>

      <Card className="border-0 shadow-md bg-white overflow-hidden mb-6">
        <Tabs
          value={statusFilter}
          className="w-full"
          onValueChange={(value) =>
            setStatusFilter(value as typeof statusFilter)
          }
        >
          <div className="p-4 pb-0">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-stone-400" />
              <Input
                type="text"
                placeholder="ニュースやプロジェクトを検索..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10 h-10 bg-stone-50 border-stone-200"
              />
            </div>
          </div>

          <TabsList className="grid grid-cols-3 bg-stone-100 rounded-none border-b border-stone-200">
            <TabsTrigger
              value="all"
              className="text-xs rounded-none data-[state=active]:bg-white"
            >
              すべて
            </TabsTrigger>
            <TabsTrigger
              value="news"
              className="text-xs rounded-none data-[state=active]:bg-white"
            >
              ニュース
            </TabsTrigger>
            <TabsTrigger
              value="project"
              className="text-xs rounded-none data-[state=active]:bg-white"
            >
              プロジェクト
            </TabsTrigger>
          </TabsList>

          <TabsContent value={statusFilter} className="p-6 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {filteredItems.map((item) => (
                <Card
                  key={item.id}
                  className="border-0 shadow-md overflow-hidden eco-transition hover:shadow-lg"
                >
                  <div
                    className={`aspect-video bg-gradient-to-br ${getBackgroundGradient(item)} relative`}
                  >
                    <div className="absolute inset-0 flex items-center justify-center">
                      {getItemIcon(item)}
                    </div>
                  </div>
                  <div className="p-4">
                    <Badge className={`${getBadgeStyle(item)} mb-2`}>
                      {item.category}
                    </Badge>
                    <h3 className="text-sm font-medium text-stone-800 mb-1">
                      {item.title}
                    </h3>
                    {item.type === "news" ? (
                      <p className="text-xs text-stone-600 mb-3 line-clamp-3">
                        {item.content}
                      </p>
                    ) : (
                      <>
                        <p className="text-xs text-stone-600 mb-3">
                          {item.description}
                        </p>
                        <div className="mt-3 flex justify-between items-center">
                          <div className="text-xs">
                            <span className="text-teal-700 font-medium">
                              ¥{item.currentFunding.toLocaleString()}
                            </span>
                            <span className="text-stone-500">
                              {" "}
                              / ¥{item.targetFunding.toLocaleString()}
                            </span>
                          </div>
                          <Progress
                            value={item.progressPercent}
                            className="h-1.5 w-1/2 bg-teal-100"
                          />
                        </div>
                      </>
                    )}
                    <Separator className="my-3" />
                    {item.type === "news" ? (
                      <Button
                        variant="outline"
                        size="sm"
                        className={`w-full ${getButtonStyle(item)} eco-transition`}
                        onClick={() => navigateToNewsDetail(item.id)}
                      >
                        詳細を読む
                        <ExternalLink className="h-3 w-3 ml-1" />
                      </Button>
                    ) : (
                      <Button
                        variant="outline"
                        size="sm"
                        className={`w-full ${getButtonStyle(item)} eco-transition`}
                        onClick={() => router.push(`/donate/${item.id}`)}
                      >
                        寄付する
                        <ArrowRight className="h-3 w-3 ml-1" />
                      </Button>
                    )}
                  </div>
                </Card>
              ))}
            </div>

            {filteredItems.length === 0 && (
              <div className="text-center py-8">
                <p className="text-stone-500">
                  該当する項目が見つかりませんでした。
                </p>
              </div>
            )}
          </TabsContent>
        </Tabs>
      </Card>

      <div className="bg-teal-50 border border-teal-100 rounded-md p-4 mb-4">
        <div className="flex items-start space-x-3">
          <Globe className="h-5 w-5 text-teal-600 mt-0.5" />
          <div>
            <h3 className="text-sm font-medium text-teal-800">
              環境貢献のヒント
            </h3>
            <p className="text-xs text-teal-700 mt-1">
              プロジェクトへの寄付は、エコポイントとして還元されます。また、決済時に環境保全オプションを有効にすることで、あなたの日常の買い物が地球環境の保全につながります。
            </p>
          </div>
        </div>
      </div>

      <p className="text-xs text-center text-stone-500">
        お客様の購入ごとに、売上の1%を環境保護団体に寄付しています
      </p>
    </div>
  );
}
</file>

<file path="src/features/eco-news/components/NewsPage/index.ts">
export { NewsPage } from "./NewsPage";
</file>

<file path="src/features/eco-news/components/NewsPage/NewsPage.tsx">
"use client";

import { PageContainer } from "@/features/layout";
import { NewsList } from "../NewsList";
import { newsAndProjects } from "../../data/eco-news-data";

export function NewsPage() {
  return (
    <PageContainer title="エコニュースとプロジェクト" activeTab="eco">
      <NewsList items={newsAndProjects} />
    </PageContainer>
  );
}
</file>

<file path="src/features/eco-news/data/eco-news-data.ts">
import { ContentItem } from "../types/eco-news";

export const newsAndProjects: ContentItem[] = [
  {
    id: "news_1",
    type: "news",
    title: "富士山のトレイル修復プロジェクト始動",
    content:
      "登山人気の高まりで損傷が進んだ富士山のトレイルを持続可能な方法で修復するプロジェクトが始動しました。このプロジェクトではEco Walletユーザーからの寄付も活用されます。",
    date: "2025/04/20",
    category: "ニュース",
    imageType: "forest",
  },
  {
    id: "project_1",
    type: "project",
    title: "山岳環境保全プロジェクト",
    description: "登山道の整備や森林再生などを通じて山岳環境の保全を目指します",
    category: "プロジェクト",
    currentFunding: 4500,
    targetFunding: 10000,
    progressPercent: 45,
    imageType: "mountain",
  },
  {
    id: "news_2",
    type: "news",
    title: "海洋プラスチック削減キャンペーン開始",
    content:
      "海洋生態系を守るため、プラスチックごみの削減を目指す全国キャンペーンが開始されました。Eco Walletでは決済額の1%が自動的に本キャンペーンに寄付されます。",
    date: "2025/04/15",
    category: "ニュース",
    imageType: "ocean",
  },
  {
    id: "project_2",
    type: "project",
    title: "海洋プラスチック削減イニシアチブ",
    description:
      "海洋プラスチックの削減と海岸の清掃活動を通じて海の生態系を守ります",
    category: "プロジェクト",
    currentFunding: 7950,
    targetFunding: 15000,
    progressPercent: 53,
    imageType: "ocean",
  },
  {
    id: "news_3",
    type: "news",
    title: "環境保全型農業の普及拡大",
    content:
      "化学肥料や農薬の使用を減らし、自然環境と調和した農業を推進する取り組みが全国で広がっています。Eco Walletユーザーの寄付金は、環境保全型農業を実践する農家への支援に使われます。",
    date: "2025/04/10",
    category: "ニュース",
    imageType: "forest",
  },
  {
    id: "project_3",
    type: "project",
    title: "都市緑化プロジェクト",
    description:
      "都市部の緑化を進め、ヒートアイランド現象の緩和と生物多様性の向上を目指します",
    category: "プロジェクト",
    currentFunding: 3200,
    targetFunding: 8000,
    progressPercent: 40,
    imageType: "forest",
  },
  {
    id: "news_4",
    type: "news",
    title: "再生可能エネルギー導入率が過去最高に",
    content:
      "日本の再生可能エネルギー導入率が過去最高を記録しました。太陽光発電と風力発電の普及により、CO2排出量の削減に大きく貢献しています。",
    date: "2025/04/05",
    category: "ニュース",
    imageType: "mountain",
  },
  {
    id: "project_4",
    type: "project",
    title: "絶滅危惧種保護プロジェクト",
    description: "絶滅の危機にある野生動物の保護活動と生息地の保全を行います",
    category: "プロジェクト",
    currentFunding: 5600,
    targetFunding: 12000,
    progressPercent: 47,
    imageType: "forest",
  },
];
</file>

<file path="src/features/eco-news/data/news-data.ts">
export type ImageType = "forest" | "ocean" | "mountain" | "default";

export interface NewsItem {
  id: string;
  type: "news";
  title: string;
  content: string;
  date: string;
  imageUrl?: string;
  imageType?: ImageType;
  category: string;
  externalLink?: string;
}

export const newsData: NewsItem[] = [
  {
    id: "news_1",
    type: "news",
    title: "富士山のトレイル修復プロジェクト始動",
    content:
      "登山人気の高まりで損傷が進んだ富士山のトレイルを持続可能な方法で修復するプロジェクトが始動しました。このプロジェクトではEco Walletユーザーからの寄付も活用されます。",
    date: "2025/04/20",
    category: "ニュース",
    imageType: "forest",
  },
  {
    id: "news_2",
    type: "news",
    title: "海洋プラスチック削減キャンペーン開始",
    content:
      "海洋生態系を守るため、プラスチックごみの削減を目指す全国キャンペーンが開始されました。Eco Walletでは決済額の1%が自動的に本キャンペーンに寄付されます。",
    date: "2025/04/15",
    category: "ニュース",
    imageType: "ocean",
  },
];
</file>

<file path="src/features/eco-news/hooks/useNewsFilter.ts">
"use client";

import { useState, useMemo } from "react";
import { ContentItem, StatusFilter } from "../types/eco-news";

interface UseNewsFilterProps {
  items: ContentItem[];
}

export const useNewsFilter = ({ items }: UseNewsFilterProps) => {
  const [statusFilter, setStatusFilter] = useState<StatusFilter>("all");
  const [searchQuery, setSearchQuery] = useState("");

  const filteredItems = useMemo(() => {
    let filtered = items;

    // ステータスフィルター
    if (statusFilter !== "all") {
      filtered = filtered.filter((item) => item.type === statusFilter);
    }

    // 検索フィルター
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter((item) => {
        const title = item.title.toLowerCase();
        const category = item.category.toLowerCase();

        if (item.type === "news") {
          return (
            title.includes(query) ||
            category.includes(query) ||
            item.content.toLowerCase().includes(query)
          );
        } else {
          return (
            title.includes(query) ||
            category.includes(query) ||
            item.description.toLowerCase().includes(query)
          );
        }
      });
    }

    return filtered;
  }, [items, statusFilter, searchQuery]);

  return {
    filteredItems,
    statusFilter,
    setStatusFilter,
    searchQuery,
    setSearchQuery,
  };
};
</file>

<file path="src/features/eco-news/types/eco-news.ts">
export type ContentType = "news" | "project";
export type ImageType = "forest" | "ocean" | "mountain" | "default";

export interface NewsItem {
  id: string;
  type: "news";
  title: string;
  content: string;
  date: string;
  imageUrl?: string;
  imageType?: ImageType;
  category: string;
  externalLink?: string;
}

export interface ProjectItem {
  id: string;
  type: "project";
  title: string;
  description: string;
  category: string;
  currentFunding: number;
  targetFunding: number;
  progressPercent: number;
  imageUrl?: string;
  imageType?: ImageType;
  externalLink?: string;
}

export type ContentItem = NewsItem | ProjectItem;

export type StatusFilter = "all" | "news" | "project";

export interface NewsFilterState {
  status: StatusFilter;
  searchQuery: string;
  category?: string;
}
</file>

<file path="src/features/eco-news/index.ts">
// Components
export { NewsPage } from "./components/NewsPage";
export { NewsDetailPage } from "./components/NewsDetailPage";
export { NewsList } from "./components/NewsList";
export { NewsDetail } from "./components/NewsDetail";
export { RelatedNews } from "./components/NewsDetail/RelatedNews";

// Types
export * from "./types/eco-news";

// Data
export { newsAndProjects } from "./data/eco-news-data";

// Hooks
export { useNewsFilter } from "./hooks/useNewsFilter";
</file>

<file path="src/features/eco-news/README.md">
# eco-news Module

環境ニュースとプロジェクトの表示・管理を行うモジュール

## Overview

eco-newsモジュールは、環境に関するニュースやプロジェクトの情報を管理・表示する機能を提供します。

## Components

### NewsPage

- ニュース一覧ページの統合コンポーネント
- フィルタリング機能（すべて、ニュース、プロジェクト）
- 検索機能

### NewsDetailPage

- ニュース詳細ページの統合コンポーネント
- 共有機能
- 関連ニュース表示

### NewsList

- ニュース・プロジェクト一覧表示コンポーネント
- タブ切り替え機能
- 検索フィルター

### NewsDetail

- ニュース詳細表示コンポーネント
- 環境貢献情報表示

### RelatedNews

- 関連ニュース表示サブコンポーネント

## Types

- `ContentType`: "news" | "project"
- `ImageType`: "forest" | "ocean" | "mountain" | "default"
- `NewsItem`: ニュースアイテムの型定義
- `ProjectItem`: プロジェクトアイテムの型定義
- `ContentItem`: NewsItem | ProjectItem
- `StatusFilter`: "all" | "news" | "project"
- `NewsFilterState`: フィルター状態の型定義

## Hooks

### useNewsFilter

- ニュース/プロジェクトのフィルタリング機能
- 検索機能
- ステータスフィルター

## Data

### eco-news-data.ts

- モックデータ（ニュースとプロジェクト）

## Usage

```tsx
// ニュース一覧ページ
import { NewsPage } from "@/features/eco-news";

export default function EcoNewsRoute() {
  return <NewsPage />;
}

// ニュース詳細ページ
import { NewsDetailPage } from "@/features/eco-news";

export default function NewsDetailRoute() {
  return <NewsDetailPage />;
}
```

## Design Guidelines

- ティール（環境）とストーン（安定性）を基調色として使用
- 環境タイプに応じた背景グラデーション
  - 森林: ティール系
  - 海洋: ブルー系
  - 山岳: グリーン系
- shadcn/uiコンポーネントの活用
- レスポンシブデザイン対応
</file>

<file path="src/features/invite/components/InviteCard/index.ts">
export { InviteCard } from "./InviteCard";
</file>

<file path="src/features/invite/components/InviteCard/InviteCard.tsx">
import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Users } from "lucide-react";

export function InviteCard() {
  return (
    <Card className="border-0 shadow-md bg-gradient-to-r from-teal-50 to-teal-100 p-4">
      <div className="flex items-start space-x-3">
        <div className="mt-0.5 bg-teal-100 p-2 rounded-full">
          <Users className="h-5 w-5 text-teal-700" />
        </div>
        <div className="flex-1">
          <h3 className="text-sm font-medium text-teal-800">
            友達を招待して1,000円ゲット！
          </h3>
          <p className="text-xs text-teal-700 mt-1">
            友達を招待すると、あなたも友達も1,000円分のエコポイントが獲得できます
          </p>
          <Link href="/invite">
            <Button className="w-full mt-3 bg-teal-700 hover:bg-teal-800 text-white text-xs">
              友達を招待する
            </Button>
          </Link>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/invite/components/QRCodeDisplay/index.ts">
export { QRCodeDisplay } from "./QRCodeDisplay";
export type { QRCodeDisplayProps } from "./QRCodeDisplay";
</file>

<file path="src/features/invite/components/QRCodeDisplay/QRCodeDisplay.tsx">
"use client";

import { useState } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Download } from "lucide-react";
import QRCode from "react-qr-code";

/**
 * QRコード表示のプロパティ
 */
export interface QRCodeDisplayProps {
  value: string;
  size?: number;
}

/**
 * 招待用QRコードを表示するコンポーネント
 *
 * @param value QRコードに埋め込む値
 * @param size  QRコードのサイズ
 */
export function QRCodeDisplay({ value, size = 200 }: QRCodeDisplayProps) {
  const [isLoading, setIsLoading] = useState(false);

  // QRコードのダウンロード処理
  const handleDownload = () => {
    setIsLoading(true);

    // QRコードのSVG要素を取得
    const svg = document.getElementById("invite-qrcode");
    if (!svg) {
      setIsLoading(false);
      return;
    }

    // SVGをデータURLに変換
    const svgData = new XMLSerializer().serializeToString(svg);
    const svgBlob = new Blob([svgData], {
      type: "image/svg+xml;charset=utf-8",
    });
    const svgUrl = URL.createObjectURL(svgBlob);

    // 画像に変換してダウンロード
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);

        // ダウンロード
        const link = document.createElement("a");
        link.download = "eco-wallet-invite-qrcode.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }
      setIsLoading(false);
    };
    img.src = svgUrl;
  };

  return (
    <div className="flex flex-col items-center space-y-3">
      <Card className="p-4 border-stone-200 bg-white">
        <div
          className="flex items-center justify-center bg-white"
          style={{ width: `${size}px`, height: `${size}px` }}
        >
          <QRCode
            id="invite-qrcode"
            value={value}
            size={size - 16} // パディングを考慮
            level="H"
            fgColor="#0F766E"
          />
        </div>
      </Card>

      <Button
        variant="outline"
        size="sm"
        className="text-xs text-stone-600 border-stone-200"
        onClick={handleDownload}
        disabled={isLoading}
      >
        <Download className="h-3 w-3 mr-1" />
        {isLoading ? "保存中..." : "QRコードを保存"}
      </Button>
    </div>
  );
}
</file>

<file path="src/features/invite/components/SocialShareButtons/index.ts">
export { SocialShareButtons } from "./SocialShareButtons";
export type { SocialShareButtonsProps } from "./SocialShareButtons";
</file>

<file path="src/features/invite/components/SocialShareButtons/SocialShareButtons.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Twitter, Facebook, Smartphone } from "lucide-react";
import { useEffect, useState } from "react";

/**
 * ソーシャルシェアボタンのプロパティ
 */
export interface SocialShareButtonsProps {
  /** 招待リンクURL */
  inviteLink: string;
  /** 共有メッセージ (省略可) */
  inviteMessage?: string;
}

/**
 * 招待用ソーシャルシェアボタンを表示するコンポーネント
 *
 * @param inviteLink 招待リンクURL
 * @param inviteMessage 共有メッセージ
 */
export function SocialShareButtons({
  inviteLink,
  inviteMessage = "Eco Walletを試してみませんか？登録すると、私たち二人とも1,000円分のエコポイントがもらえて、環境保全にも貢献できます。",
}: SocialShareButtonsProps) {
  // ブラウザ環境でのWeb Share APIのサポート状況をチェック
  const [isShareSupported, setIsShareSupported] = useState(false);

  useEffect(() => {
    // クライアントサイドでのみ実行される
    setIsShareSupported(
      typeof navigator !== "undefined" && typeof navigator.share === "function",
    );
  }, []);

  // URLエンコードされたメッセージとリンク
  const encodedMessage = encodeURIComponent(inviteMessage);
  const encodedLink = encodeURIComponent(inviteLink);

  // 各SNSの共有URL
  const twitterUrl = `https://twitter.com/intent/tweet?text=${encodedMessage}&url=${encodedLink}`;
  const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodedLink}&quote=${encodedMessage}`;
  const lineUrl = `https://social-plugins.line.me/lineit/share?url=${encodedLink}`;

  /**
   * スマホの場合、ネイティブアプリで共有
   */
  const handleNativeShare = async () => {
    if (typeof navigator !== "undefined" && navigator.share) {
      try {
        await navigator.share({
          title: "Eco Wallet招待",
          text: inviteMessage,
          url: inviteLink,
        });
      } catch (error) {
        // AbortError (ユーザーによる共有キャンセル) の場合はエラーとして扱わない
        if (error instanceof Error && error.name !== "AbortError") {
          console.error("共有に失敗しました", error);
        }
      }
    }
  };

  return (
    <div className="space-y-3">
      <h4 className="text-sm font-medium text-stone-700">SNSで共有</h4>
      <div className="flex flex-wrap gap-2">
        <Button
          variant="outline"
          size="sm"
          className="flex-1 bg-[#1DA1F2]/10 text-[#1DA1F2] border-[#1DA1F2]/30 hover:bg-[#1DA1F2]/20"
          onClick={() => window.open(twitterUrl, "_blank")}
        >
          <Twitter className="h-4 w-4 mr-1" />
          <span>Twitter</span>
        </Button>

        <Button
          variant="outline"
          size="sm"
          className="flex-1 bg-[#4267B2]/10 text-[#4267B2] border-[#4267B2]/30 hover:bg-[#4267B2]/20"
          onClick={() => window.open(facebookUrl, "_blank")}
        >
          <Facebook className="h-4 w-4 mr-1" />
          <span>Facebook</span>
        </Button>

        <Button
          variant="outline"
          size="sm"
          className="flex-1 bg-[#06C755]/10 text-[#06C755] border-[#06C755]/30 hover:bg-[#06C755]/20"
          onClick={() => window.open(lineUrl, "_blank")}
        >
          <span className="mr-1 font-bold">L</span>
          <span>LINE</span>
        </Button>

        {isShareSupported && (
          <Button
            variant="outline"
            size="sm"
            className="flex-1 bg-stone-100 text-stone-700 border-stone-200"
            onClick={handleNativeShare}
          >
            <Smartphone className="h-4 w-4 mr-1" />
            <span>その他</span>
          </Button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/features/invite/types/invite.ts">
/**
 * 招待機能の型定義
 */

/**
 * 招待データの型
 */
export interface Invitation {
  /** 招待コード */
  code: string;
  /** 招待先のメールアドレス (オプション) */
  email?: string;
  /** 招待状態 */
  status: InviteStatus;
  /** 招待日時 */
  createdAt: string;
  /** 使用日時 (使用された場合) */
  usedAt?: string;
  /** 招待元ユーザーID */
  inviterId: string;
  /** 招待先ユーザーID (招待が承諾された場合) */
  inviteeId?: string;
}

/**
 * 招待状態の型
 */
export type InviteStatus =
  | "pending" // 招待中
  | "registered" // 登録済み
  | "expired" // 期限切れ
  | "cancelled"; // キャンセル

/**
 * 招待共有オプションの型
 */
export interface InviteShareOptions {
  /** 招待メッセージ */
  message: string;
  /** 招待リンク */
  link: string;
  /** リンクの期限日数（デフォルトは7日間） */
  expiryDays?: number;
}
</file>

<file path="src/features/invite/README.md">
# 招待機能（Invite Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいた招待機能を含みます。

## ディレクトリ構造

```
invite/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── QRCodeDisplay/          # QRコード表示コンポーネント
│   └── SocialShareButtons/     # ソーシャルシェアボタンコンポーネント
├── data/                       # データソース（将来的に追加予定）
├── hooks/                      # カスタムフック（将来的に追加予定）
├── store/                      # 状態管理（将来的に追加予定）
├── types/                      # 型定義
│   └── invite.ts               # 招待関連の型定義
├── utils/                      # ユーティリティ関数（将来的に追加予定）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // 型定義
  Invitation,
  InviteStatus,
  InviteShareOptions,

  // コンポーネント
  QRCodeDisplay,
  SocialShareButtons,

  // 型
  QRCodeDisplayProps,
  SocialShareButtonsProps,
} from "@/features/invite";
```

### コンポーネント例

#### QRコード表示

```tsx
<QRCodeDisplay
  value="https://eco-wallet.example.com/invite/ABC123"
  size={200}
/>
```

#### ソーシャルシェアボタン

```tsx
<SocialShareButtons
  inviteLink="https://eco-wallet.example.com/invite/ABC123"
  inviteMessage="Eco Walletに参加して環境保全に貢献しませんか？"
/>
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. 招待コードの生成と管理（将来的に追加予定）
2. 招待リンクのシェア機能の提供
3. QRコードを使った招待の表示
4. 招待状況の状態管理（将来的に追加予定）

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 共通ユーティリティ: `@/lib/utils`
- サードパーティライブラリ: `react-qr-code`

## 拡張予定

今後、以下の機能を追加予定です：

1. 招待コードの生成と検証ユーティリティ
2. 招待履歴と状態管理のためのストア
3. 招待キャンペーンとの連携機能
</file>

<file path="src/features/layout/components/AppFooter/AppFooter.tsx">
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Home, QrCode, Leaf, CreditCard } from "lucide-react";

interface AppFooterProps {
  activeTab?: "home" | "pay" | "eco" | "history" | "account";
}

export function AppFooter({ activeTab = "home" }: AppFooterProps) {
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-stone-200 py-2 px-4 shadow-[0_-2px_5px_rgba(0,0,0,0.08)] z-10">
      <div className="flex justify-around max-w-3xl mx-auto">
        <Link href="/" aria-label="ホーム画面に移動">
          <Button
            variant="ghost"
            className={`flex flex-col items-center py-2 px-3 h-auto relative rounded-md ${
              activeTab === "home"
                ? "text-teal-600 bg-teal-100/60"
                : "text-stone-500 hover:bg-stone-100/60"
            }`}
          >
            <Home className="h-5 w-5" />
            <span className="text-xs mt-1 font-medium">ホーム</span>
            {activeTab === "home" && (
              <div className="absolute -top-2 w-1/2 h-1 bg-teal-600 rounded-full" />
            )}
          </Button>
        </Link>

        <Link href="/qrcode" aria-label="QRコード支払い画面に移動">
          <Button
            variant="ghost"
            className={`flex flex-col items-center py-2 px-3 h-auto relative rounded-md ${
              activeTab === "pay"
                ? "text-teal-600 bg-teal-100/60"
                : "text-stone-500 hover:bg-stone-100/60"
            }`}
          >
            <QrCode className="h-5 w-5" />
            <span className="text-xs mt-1 font-medium">支払う</span>
            {activeTab === "pay" && (
              <div className="absolute -top-2 w-1/2 h-1 bg-teal-600 rounded-full" />
            )}
          </Button>
        </Link>

        <Link href="/impact" aria-label="環境への影響を確認">
          <Button
            variant="ghost"
            className={`flex flex-col items-center py-2 px-3 h-auto relative rounded-md ${
              activeTab === "eco"
                ? "text-teal-600 bg-teal-100/60"
                : "text-stone-500 hover:bg-stone-100/60"
            }`}
          >
            <Leaf className="h-5 w-5" />
            <span className="text-xs mt-1 font-medium">環境</span>
            {activeTab === "eco" && (
              <div className="absolute -top-2 w-1/2 h-1 bg-teal-600 rounded-full" />
            )}
          </Button>
        </Link>

        <Link href="/history" aria-label="取引履歴を確認">
          <Button
            variant="ghost"
            className={`flex flex-col items-center py-2 px-3 h-auto relative rounded-md ${
              activeTab === "history"
                ? "text-teal-600 bg-teal-100/60"
                : "text-stone-500 hover:bg-stone-100/60"
            }`}
          >
            <CreditCard className="h-5 w-5" />
            <span className="text-xs mt-1 font-medium">取引</span>
            {activeTab === "history" && (
              <div className="absolute -top-2 w-1/2 h-1 bg-teal-600 rounded-full" />
            )}
          </Button>
        </Link>

        <Link href="/settings" aria-label="アカウント設定を開く">
          <Button
            variant="ghost"
            className={`flex flex-col items-center py-2 px-3 h-auto relative rounded-md ${
              activeTab === "account"
                ? "text-teal-600 bg-teal-100/60"
                : "text-stone-500 hover:bg-stone-100/60"
            }`}
          >
            <Avatar className="h-5 w-5 border border-stone-200">
              <AvatarFallback className="text-[10px] bg-stone-100 text-stone-500">
                山田
              </AvatarFallback>
            </Avatar>
            <span className="text-xs mt-1 font-medium">アカウント</span>
            {activeTab === "account" && (
              <div className="absolute -top-2 w-1/2 h-1 bg-teal-600 rounded-full" />
            )}
          </Button>
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/layout/components/AppFooter/index.ts">
export { AppFooter } from "./AppFooter";
</file>

<file path="src/features/layout/components/AppHeader/AppHeader.tsx">
"use client";

import Link from "next/link";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Bell, Settings } from "lucide-react";
import { useSession } from "next-auth/react";

interface AppHeaderProps {
  title?: string;
  showAvatar?: boolean;
  showSettings?: boolean;
  showNotifications?: boolean;
}

export function AppHeader({
  title = "Eco Wallet",
  showAvatar = true,
  showSettings = true,
  showNotifications = true,
}: AppHeaderProps) {
  const { data: session } = useSession();
  const user = session?.user;

  return (
    <div className="sticky top-0 p-4 bg-teal-700 text-white shadow-sm z-10">
      <div className="flex justify-between items-center max-w-3xl mx-auto">
        <div className="flex items-center space-x-2">
          <Link href="/" aria-label="ホームに戻る">
            <svg viewBox="0 0 100 40" className="h-8 w-auto fill-white">
              <path d="M50,0 L75,20 L65,40 H35 L25,20 L50,0z" />
              <path d="M45,15 L55,15 L55,25 L45,25 L45,15z" fill="teal" />
            </svg>
          </Link>
          <h1 className="text-lg font-bold">{title}</h1>
        </div>

        <div className="flex items-center space-x-3">
          {showNotifications && (
            <Link href="/notifications" aria-label="通知を確認">
              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-teal-600 h-8 w-8 rounded-full"
              >
                <Bell className="h-5 w-5" />
              </Button>
            </Link>
          )}

          {showSettings && (
            <Link href="/settings" aria-label="設定を開く">
              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-teal-600 h-8 w-8 rounded-full"
              >
                <Settings className="h-5 w-5" />
              </Button>
            </Link>
          )}

          {showAvatar && user && (
            <Link href="/settings" aria-label="アカウント設定を開く">
              <Avatar className="h-8 w-8 border border-white/30 hover:border-white transition-colors">
                <AvatarImage
                  src={user.image || "/api/placeholder/32/32"}
                  alt={user.name || "ユーザー"}
                />
                <AvatarFallback className="bg-teal-600 text-white">
                  {user.name ? user.name.slice(0, 2) : "ユ"}
                </AvatarFallback>
              </Avatar>
            </Link>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/features/layout/components/AppHeader/index.ts">
export { AppHeader } from "./AppHeader";
</file>

<file path="src/features/layout/components/AuthLayout/AuthLayout.tsx">
import { ReactNode } from "react";

interface AuthLayoutProps {
  children: ReactNode;
  title: string;
  subtitle?: string;
}

export function AuthLayout({ children, title, subtitle }: AuthLayoutProps) {
  return (
    <div className="flex min-h-screen bg-stone-50 flex-col">
      <div className="flex-1 flex flex-col justify-center items-center px-4 py-6">
        <div className="w-full max-w-md space-y-8 text-center">
          {/* ロゴ */}
          <div className="flex flex-col items-center space-y-3 mb-2">
            <svg
              viewBox="0 0 100 40"
              className="h-16 w-auto fill-teal-700 drop-shadow-sm"
            >
              <path d="M50,0 L75,20 L65,40 H35 L25,20 L50,0z" />
              <path d="M45,15 L55,15 L55,25 L45,25 L45,15z" fill="white" />
            </svg>
            <div className="space-y-1">
              <h1 className="text-2xl font-bold tracking-tight text-stone-900">
                Eco Wallet
              </h1>
              {subtitle && <p className="text-sm text-stone-600">{subtitle}</p>}
            </div>
          </div>

          {/* ページタイトル */}
          <div className="space-y-2 mb-2">
            <h2 className="text-xl font-semibold text-stone-800">{title}</h2>
          </div>

          {/* コンテンツ */}
          <div className="bg-white rounded-lg shadow-sm border border-stone-200 p-6 space-y-5">
            {children}
          </div>
        </div>
      </div>

      {/* フッター */}
      <div className="p-4 text-center border-t border-stone-200 bg-white/50">
        <p className="text-xs text-stone-500">
          © 2025 Eco Wallet. All rights reserved.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/layout/components/AuthLayout/index.ts">
export { AuthLayout } from "./AuthLayout";
</file>

<file path="src/features/layout/components/PageContainer/index.ts">
export { PageContainer } from "./PageContainer";
</file>

<file path="src/features/layout/components/PageContainer/PageContainer.tsx">
import { ReactNode } from "react";
import { AppHeader } from "@/features/layout/components/AppHeader";
import { AppFooter } from "@/features/layout/components/AppFooter";

interface PageContainerProps {
  children: ReactNode;
  title?: string;
  activeTab?: "home" | "pay" | "eco" | "history" | "account";
  showHeader?: boolean;
  showFooter?: boolean;
  showAvatar?: boolean;
  showSettings?: boolean;
  showNotifications?: boolean;
}

export function PageContainer({
  children,
  title = "Eco Wallet",
  activeTab = "home",
  showHeader = true,
  showFooter = true,
  showAvatar = true,
  showSettings = true,
  showNotifications = true,
}: PageContainerProps) {
  return (
    <div className="flex min-h-screen bg-stone-50 flex-col">
      {showHeader && (
        <AppHeader
          title={title}
          showAvatar={showAvatar}
          showSettings={showSettings}
          showNotifications={showNotifications}
        />
      )}

      <div className="flex-1 p-4 space-y-6 max-w-3xl mx-auto w-full pb-20">
        {children}
      </div>

      {showFooter && <AppFooter activeTab={activeTab} />}
    </div>
  );
}
</file>

<file path="src/features/layout/index.ts">
// レイアウト機能の公開API
export { AppHeader } from "./components/AppHeader";
export { AppFooter } from "./components/AppFooter";
export { AuthLayout } from "./components/AuthLayout";
export { PageContainer } from "./components/PageContainer";
</file>

<file path="src/features/layout/README.md">
# レイアウト機能（Layout Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいたレイアウト機能を含みます。

## ディレクトリ構造

```
layout/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── AppHeader/              # アプリケーションヘッダー
│   │   ├── AppHeader.tsx       # 実装
│   │   └── index.ts           # 公開API
│   ├── AppFooter/              # アプリケーションフッター
│   │   ├── AppFooter.tsx       # 実装
│   │   └── index.ts           # 公開API
│   ├── AuthLayout/             # 認証画面用レイアウト
│   │   ├── AuthLayout.tsx      # 実装
│   │   └── index.ts           # 公開API
│   └── PageContainer/          # ページコンテナ
│       ├── PageContainer.tsx   # 実装
│       └── index.ts           # 公開API
├── types/                      # 型定義（現在は空）
├── hooks/                      # カスタムフック（現在は空）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントをインポートします：

```typescript
import {
  AppHeader,
  AppFooter,
  AuthLayout,
  PageContainer,
} from "@/features/layout";
```

### コンポーネント例

#### PageContainer（標準的なページレイアウト）

```tsx
<PageContainer
  title="取引履歴"
  activeTab="history"
  showHeader={true}
  showFooter={true}
>
  {/* ページコンテンツ */}
</PageContainer>
```

#### AuthLayout（認証画面用レイアウト）

```tsx
<AuthLayout title="ログイン" subtitle="アカウントにログインしてください">
  {/* 認証フォーム */}
</AuthLayout>
```

#### AppHeader（ヘッダーのみ使用）

```tsx
<AppHeader
  title="Eco Wallet"
  showAvatar={true}
  showSettings={true}
  showNotifications={true}
/>
```

#### AppFooter（フッターのみ使用）

```tsx
<AppFooter activeTab="home" />
```

## Props

### PageContainer

- `children`: ReactNode - ページコンテンツ
- `title?`: string - ヘッダーに表示するタイトル（デフォルト: "Eco Wallet"）
- `activeTab?`: "home" | "pay" | "eco" | "history" | "account" - アクティブなタブ
- `showHeader?`: boolean - ヘッダーを表示するか（デフォルト: true）
- `showFooter?`: boolean - フッターを表示するか（デフォルト: true）
- `showAvatar?`: boolean - アバターを表示するか（デフォルト: true）
- `showSettings?`: boolean - 設定ボタンを表示するか（デフォルト: true）
- `showNotifications?`: boolean - 通知ボタンを表示するか（デフォルト: true）

### AuthLayout

- `children`: ReactNode - 認証フォームコンテンツ
- `title`: string - ページタイトル
- `subtitle?`: string - サブタイトル（オプション）

### AppHeader

- `title?`: string - タイトル（デフォルト: "Eco Wallet"）
- `showAvatar?`: boolean - アバターを表示するか
- `showSettings?`: boolean - 設定ボタンを表示するか
- `showNotifications?`: boolean - 通知ボタンを表示するか

### AppFooter

- `activeTab?`: "home" | "pay" | "eco" | "history" | "account" - アクティブなタブ

## 責任

この機能モジュールは以下の責任を持ちます：

1. アプリケーション全体の共通レイアウトの提供
2. ヘッダー・フッターナビゲーションの管理
3. 認証画面専用のレイアウト提供
4. レスポンシブデザインの実装
5. ナビゲーション状態の管理

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 認証機能: `next-auth/react`
- アイコン: `lucide-react`

## 移行ガイド

従来の `@/components/layout/` からの移行：

```typescript
// 旧インポート
import { PageContainer } from "@/components/layout/PageContainer";

// 新インポート（ブリッジコンポーネント経由でも動作）
import { PageContainer } from "@/features/layout";
```

ブリッジコンポーネントにより、既存のインポートパスは引き続き動作しますが、新規開発では `@/features/layout` からのインポートを推奨します。
</file>

<file path="src/features/notifications/components/NotificationBadge/index.ts">
export { NotificationBadge } from "./NotificationBadge";
</file>

<file path="src/features/notifications/components/NotificationBadge/NotificationBadge.tsx">
import React from "react";
import { Badge } from "@/components/ui/badge";

interface NotificationBadgeProps {
  count: number;
  className?: string;
}

export const NotificationBadge: React.FC<NotificationBadgeProps> = ({
  count,
  className = "",
}) => {
  if (count === 0) {
    return null;
  }

  return (
    <Badge
      className={`bg-teal-100 text-teal-800 hover:bg-teal-100 ${className}`}
    >
      {count > 99 ? "99+" : count}
    </Badge>
  );
};
</file>

<file path="src/features/notifications/components/NotificationItem/index.ts">
export { NotificationItem } from "./NotificationItem";
</file>

<file path="src/features/notifications/components/NotificationItem/NotificationItem.tsx">
import React from "react";
import {
  Bell,
  Leaf,
  ShoppingBag,
  Megaphone,
  AlertTriangle,
} from "lucide-react";
import {
  Notification,
  NotificationType,
  notificationIcons,
} from "../../types/notification";

interface NotificationItemProps {
  notification: Notification;
  onClick: (notification: Notification) => void;
}

export const NotificationItem: React.FC<NotificationItemProps> = ({
  notification,
  onClick,
}) => {
  // 通知タイプに基づいてアイコンを取得
  const getNotificationIcon = (type: NotificationType) => {
    switch (type) {
      case "transaction":
        return <ShoppingBag className="h-5 w-5 text-blue-500" />;
      case "eco_impact":
        return <Leaf className="h-5 w-5 text-teal-600" />;
      case "campaign":
        return <Megaphone className="h-5 w-5 text-amber-500" />;
      case "security":
        return <AlertTriangle className="h-5 w-5 text-red-500" />;
      case "system":
      default:
        return <Bell className="h-5 w-5 text-stone-500" />;
    }
  };

  const iconConfig = notificationIcons[notification.type];

  return (
    <div
      className={`p-4 flex items-start space-x-3 cursor-pointer hover:bg-stone-50 transition-colors ${
        !notification.isRead ? "bg-teal-50/30" : ""
      }`}
      onClick={() => onClick(notification)}
    >
      <div
        className={`mt-0.5 w-10 h-10 rounded-full flex items-center justify-center ${iconConfig.bgColor}`}
      >
        {getNotificationIcon(notification.type)}
      </div>
      <div className="flex-1">
        <div className="flex justify-between items-start">
          <h3 className="text-sm font-medium text-stone-800">
            {notification.title}
          </h3>
          <span className="text-xs text-stone-500 whitespace-nowrap ml-2">
            {notification.date.split(" ")[0]}
          </span>
        </div>
        <p className="text-xs text-stone-600 mt-1 line-clamp-2">
          {notification.message}
        </p>

        {!notification.isRead && (
          <div className="mt-1.5 flex justify-end">
            <div className="h-2 w-2 rounded-full bg-teal-600"></div>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/features/notifications/components/NotificationList/index.ts">
export { NotificationList } from "./NotificationList";
</file>

<file path="src/features/notifications/components/NotificationList/NotificationList.tsx">
"use client";

import React, { useState } from "react";
import { Bell } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { NotificationItem } from "../NotificationItem";
import { Notification } from "../../types/notification";

interface NotificationListProps {
  notifications: Notification[];
  onNotificationClick: (notification: Notification) => void;
  onNotificationsUpdate: (notifications: Notification[]) => void;
}

export const NotificationList: React.FC<NotificationListProps> = ({
  notifications,
  onNotificationClick,
  onNotificationsUpdate,
}) => {
  const [activeTab, setActiveTab] = useState<string>("all");

  // フィルタリングされた通知の取得
  const getFilteredNotifications = () => {
    if (activeTab === "all") {
      return notifications;
    }
    return notifications.filter((n) => n.type === activeTab);
  };

  const handleNotificationClick = (notification: Notification) => {
    // 未読を既読に変更
    if (!notification.isRead) {
      const updatedNotifications = notifications.map((n) =>
        n.id === notification.id ? { ...n, isRead: true } : n,
      );
      onNotificationsUpdate(updatedNotifications);
    }
    onNotificationClick(notification);
  };

  const filteredNotifications = getFilteredNotifications();

  return (
    <Tabs defaultValue="all" className="w-full" onValueChange={setActiveTab}>
      <TabsList className="grid grid-cols-5 bg-stone-100">
        <TabsTrigger value="all" className="text-xs">
          すべて
        </TabsTrigger>
        <TabsTrigger value="transaction" className="text-xs">
          取引
        </TabsTrigger>
        <TabsTrigger value="eco_impact" className="text-xs">
          環境
        </TabsTrigger>
        <TabsTrigger value="campaign" className="text-xs">
          特典
        </TabsTrigger>
        <TabsTrigger value="system" className="text-xs">
          その他
        </TabsTrigger>
      </TabsList>

      <TabsContent value={activeTab} className="mt-4">
        <div className="divide-y divide-stone-100">
          {filteredNotifications.length > 0 ? (
            filteredNotifications.map((notification) => (
              <NotificationItem
                key={notification.id}
                notification={notification}
                onClick={handleNotificationClick}
              />
            ))
          ) : (
            <div className="py-8 text-center">
              <div className="w-12 h-12 mx-auto bg-stone-100 rounded-full flex items-center justify-center mb-3">
                <Bell className="h-6 w-6 text-stone-400" />
              </div>
              <p className="text-sm text-stone-600">通知はありません</p>
            </div>
          )}
        </div>
      </TabsContent>
    </Tabs>
  );
};
</file>

<file path="src/features/notifications/data/notifications-data.ts">
import { Notification } from "../types/notification";

export const notificationsData: Notification[] = [
  {
    id: "notif_1",
    type: "transaction",
    title: "決済完了",
    message:
      "エコ製品定期プラン（¥4,000）の支払いが完了しました。環境貢献: ¥200",
    date: "2025/04/19 12:30",
    isRead: true,
    link: "/history",
  },
  {
    id: "notif_2",
    type: "eco_impact",
    title: "環境目標達成！",
    message:
      "おめでとうございます！森林保全の目標の50%を達成しました。あと5m²で目標達成です。",
    date: "2025/04/18 14:15",
    isRead: false,
    link: "/impact",
    imageType: "forest",
  },
  {
    id: "notif_3",
    type: "campaign",
    title: "新キャンペーン",
    message:
      "山の日キャンペーンが開始されました。エコ製品購入で20%のポイント還元があります。",
    date: "2025/04/18 09:00",
    isRead: false,
  },
  {
    id: "notif_4",
    type: "system",
    title: "アプリアップデート",
    message:
      "Eco Walletアプリがバージョン2.0にアップデートされました。新機能をご確認ください。",
    date: "2025/04/15 17:45",
    isRead: true,
  },
  {
    id: "notif_5",
    type: "security",
    title: "ログイン確認",
    message:
      "新しいデバイスからログインがありました。心当たりがない場合は設定から確認してください。",
    date: "2025/04/12 08:23",
    isRead: true,
    link: "/settings?tab=security",
  },
  {
    id: "notif_6",
    type: "eco_impact",
    title: "環境貢献レポート",
    message: "3月の環境貢献レポートが発行されました。CO2排出削減: 18kg達成！",
    date: "2025/04/01 10:00",
    isRead: true,
    link: "/impact",
  },
];
</file>

<file path="src/features/notifications/store/notification.slice.ts">
import { StateCreator } from "zustand";
import { create } from "zustand";
import { Notification } from "../types/notification";
import { notificationsData } from "../data/notifications-data";

/**
 * Notification スライスの型定義
 */
export interface NotificationSlice {
  // データ
  notifications: Notification[];
  isLoading: boolean;
  error: string | null;

  // アクション
  setNotifications: (notifications: Notification[]) => void;
  addNotification: (notification: Notification) => void;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  deleteNotification: (id: string) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;

  // クエリ
  getNotificationById: (id: string) => Notification | undefined;
  getNotificationsByType: (type: string) => Notification[];
  getUnreadCount: () => number;
}

/**
 * Notification スライスの作成関数
 */
export const createNotificationSlice: StateCreator<
  NotificationSlice,
  [],
  [],
  NotificationSlice
> = (set, get) => ({
  // 初期状態
  notifications: notificationsData,
  isLoading: false,
  error: null,

  // 通知リストを設定
  setNotifications: (notifications) => {
    set({ notifications });
  },

  // 新しい通知を追加
  addNotification: (notification) => {
    set((state) => ({
      notifications: [notification, ...state.notifications],
    }));
  },

  // 通知を既読にする
  markAsRead: (id) => {
    set((state) => ({
      notifications: state.notifications.map((n) =>
        n.id === id ? { ...n, isRead: true } : n,
      ),
    }));
  },

  // すべての通知を既読にする
  markAllAsRead: () => {
    set((state) => ({
      notifications: state.notifications.map((n) => ({ ...n, isRead: true })),
    }));
  },

  // 通知を削除
  deleteNotification: (id) => {
    set((state) => ({
      notifications: state.notifications.filter((n) => n.id !== id),
    }));
  },

  // ローディング状態を設定
  setLoading: (isLoading) => {
    set({ isLoading });
  },

  // エラー状態を設定
  setError: (error) => {
    set({ error });
  },

  // IDで通知を取得
  getNotificationById: (id) => {
    return get().notifications.find((n) => n.id === id);
  },

  // タイプで通知をフィルタリング
  getNotificationsByType: (type) => {
    return get().notifications.filter((n) => n.type === type);
  },

  // 未読数を取得
  getUnreadCount: () => {
    return get().notifications.filter((n) => !n.isRead).length;
  },
});

/**
 * 単独で使用可能な Notification ストアフック
 */
export const useNotificationStore = create<NotificationSlice>()((...a) => ({
  ...createNotificationSlice(...a),
}));
</file>

<file path="src/features/notifications/types/notification.ts">
export type NotificationType =
  | "transaction"
  | "eco_impact"
  | "campaign"
  | "system"
  | "security";

export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  date: string;
  isRead: boolean;
  link?: string;
  imageType?: string;
}

// 通知アイコンの型定義
export interface NotificationIcon {
  className: string;
  bgColor: string;
}

// 通知タイプごとのアイコン設定
export const notificationIcons: Record<NotificationType, NotificationIcon> = {
  transaction: {
    className: "h-5 w-5 text-blue-500",
    bgColor: "bg-blue-50",
  },
  eco_impact: {
    className: "h-5 w-5 text-teal-600",
    bgColor: "bg-teal-50",
  },
  campaign: {
    className: "h-5 w-5 text-amber-500",
    bgColor: "bg-amber-50",
  },
  security: {
    className: "h-5 w-5 text-red-500",
    bgColor: "bg-red-50",
  },
  system: {
    className: "h-5 w-5 text-stone-500",
    bgColor: "bg-stone-50",
  },
};
</file>

<file path="src/features/notifications/index.ts">
// Types
export type { Notification, NotificationType } from "./types/notification";

// Components
export { NotificationItem } from "./components/NotificationItem";
export { NotificationList } from "./components/NotificationList";
export { NotificationBadge } from "./components/NotificationBadge";

// Store
export { useNotificationStore } from "./store/notification.slice";
export type { NotificationSlice } from "./store/notification.slice";

// Data
export { notificationsData } from "./data/notifications-data";
</file>

<file path="src/features/notifications/README.md">
# Notifications Feature

通知機能を提供するフィーチャーモジュールです。

## 構造

```
notifications/
├── components/
│   ├── NotificationItem/     # 個別の通知アイテムコンポーネント
│   ├── NotificationList/     # 通知リストコンポーネント
│   └── NotificationBadge/    # 通知バッジコンポーネント
├── data/
│   └── notifications-data.ts # モック通知データ
├── store/
│   └── notification.slice.ts # 通知状態管理（Zustand）
├── types/
│   └── notification.ts       # 通知関連の型定義
└── index.ts                  # Public API
```

## 主要な型

### Notification

```typescript
interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  date: string;
  isRead: boolean;
  link?: string;
  imageType?: string;
}
```

### NotificationType

```typescript
type NotificationType =
  | "transaction" // 取引通知
  | "eco_impact" // 環境貢献通知
  | "campaign" // キャンペーン通知
  | "system" // システム通知
  | "security"; // セキュリティ通知
```

## 使用方法

### 通知リストの表示

```typescript
import { NotificationList, useNotificationStore } from "@/features/notifications";

function NotificationsPage() {
  const { notifications, markAsRead, setNotifications } = useNotificationStore();

  const handleNotificationClick = (notification: Notification) => {
    if (!notification.isRead) {
      markAsRead(notification.id);
    }
    // ナビゲーション処理
  };

  return (
    <NotificationList
      notifications={notifications}
      onNotificationClick={handleNotificationClick}
      onNotificationsUpdate={setNotifications}
    />
  );
}
```

### 通知バッジの表示

```typescript
import { NotificationBadge, useNotificationStore } from "@/features/notifications";

function Header() {
  const { getUnreadCount } = useNotificationStore();
  const unreadCount = getUnreadCount();

  return (
    <div>
      <NotificationBadge count={unreadCount} />
    </div>
  );
}
```

## ストア機能

### アクション

- `setNotifications`: 通知リストを設定
- `addNotification`: 新しい通知を追加
- `markAsRead`: 通知を既読にする
- `markAllAsRead`: すべての通知を既読にする
- `deleteNotification`: 通知を削除
- `setLoading`: ローディング状態を設定
- `setError`: エラー状態を設定

### クエリ

- `getNotificationById`: IDで通知を取得
- `getNotificationsByType`: タイプで通知をフィルタリング
- `getUnreadCount`: 未読数を取得

## 通知タイプごとのスタイリング

各通知タイプには専用のアイコンと色が設定されています：

- **transaction**: 青色、ShoppingBagアイコン
- **eco_impact**: ティール色、Leafアイコン
- **campaign**: アンバー色、Megaphoneアイコン
- **security**: 赤色、AlertTriangleアイコン
- **system**: グレー色、Bellアイコン
</file>

<file path="src/features/payment/components/PaymentMethodSelector/PaymentMethodSelectorContainer.tsx">
"use client";

import React, { useState, useMemo } from "react";
import { PaymentMethodSelector } from "./PaymentMethodSelector";
import { ErrorMessage } from "@/components/ui/error-message";
import { getErrorMessage } from "@/lib/utils/error-utils";
import {
  validatePaymentMethod,
  validatePaymentAmount,
  calculatePaymentFee,
} from "@/lib/business/payment";
import type { PaymentMethod, PaymentMethodDetail } from "../../types/payment";
import type { BusinessError } from "@/shared/types/errors";

interface PaymentMethodSelectorContainerProps {
  methods: PaymentMethodDetail[];
  selectedMethod: PaymentMethod;
  onMethodChange: (method: PaymentMethod) => void;
  paymentAmount?: number;
  onValidationChange?: (isValid: boolean, error?: string) => void;
}

/**
 * PaymentMethodSelectorのContainer Component
 * Result型を使用した型安全なバリデーションとエラーハンドリングを提供
 */
export const PaymentMethodSelectorContainer: React.FC<
  PaymentMethodSelectorContainerProps
> = ({
  methods,
  selectedMethod,
  onMethodChange,
  paymentAmount,
  onValidationChange,
}) => {
  const [error, setError] = useState<string>("");

  // 選択された決済方法のバリデーション
  const methodValidationResult = useMemo(() => {
    // PaymentMethodからAPI用の文字列に変換
    const apiMethod =
      selectedMethod === "wallet" ? "bank_transfer" : "credit_card";
    return validatePaymentMethod(apiMethod);
  }, [selectedMethod]);

  // 決済手数料の計算
  const feeCalculationResult = useMemo(() => {
    if (!paymentAmount || paymentAmount <= 0) {
      return null;
    }

    const apiMethod =
      selectedMethod === "wallet" ? "bank_transfer" : "credit_card";
    return calculatePaymentFee(paymentAmount, apiMethod);
  }, [paymentAmount, selectedMethod]);

  // バリデーション結果の統合
  const validationResult = useMemo(() => {
    let validationError: BusinessError | null = null;

    // 決済方法のバリデーション
    if (methodValidationResult.isErr()) {
      validationError = methodValidationResult.error;
    }

    // 決済金額のバリデーション（金額が提供されている場合）
    if (paymentAmount !== undefined) {
      const amountValidationResult = validatePaymentAmount(paymentAmount);
      if (amountValidationResult.isErr()) {
        validationError = amountValidationResult.error;
      }
    }

    return {
      isValid: validationError === null,
      error: validationError,
      fee: feeCalculationResult?.isOk() ? feeCalculationResult.value : 0,
    };
  }, [methodValidationResult, paymentAmount, feeCalculationResult]);

  // バリデーション結果が変更された時の処理
  React.useEffect(() => {
    if (validationResult.error) {
      const errorMessage = getErrorMessage(validationResult.error);
      setError(errorMessage);
      onValidationChange?.(false, errorMessage);
    } else {
      setError("");
      onValidationChange?.(true);
    }
  }, [validationResult, onValidationChange]);

  // 決済方法変更時のハンドラー
  const handleMethodChange = (method: PaymentMethod) => {
    // エラーをクリア
    setError("");

    // 新しい決済方法を設定
    onMethodChange(method);
  };

  // 決済方法の詳細情報を追加（手数料情報など）
  const enhancedMethods = useMemo(() => {
    return methods.map((method) => {
      if (method.type === selectedMethod && validationResult.fee > 0) {
        return {
          ...method,
          label: `${method.label} (手数料: ¥${validationResult.fee.toLocaleString()})`,
        };
      }
      return method;
    });
  }, [methods, selectedMethod, validationResult.fee]);

  return (
    <div className="space-y-3">
      <PaymentMethodSelector
        methods={enhancedMethods}
        selectedMethod={selectedMethod}
        onMethodChange={handleMethodChange}
      />

      {error && <ErrorMessage message={error} />}

      {/* デバッグ情報（開発時のみ表示） */}
      {process.env.NODE_ENV === "development" && validationResult.fee > 0 && (
        <div className="text-xs text-stone-500 bg-stone-50 p-2 rounded border">
          <div>手数料: ¥{validationResult.fee.toLocaleString()}</div>
          <div>
            バリデーション: {validationResult.isValid ? "✅ 有効" : "❌ 無効"}
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/features/payment/components/PaymentOptions/index.ts">
export { PaymentOptions } from "./PaymentOptions";
</file>

<file path="src/features/payment/components/PaymentOptions/PaymentOptions.tsx">
import React from "react";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { formatCurrency } from "@/shared/utils/formats";
import type { PaymentOptions as PaymentOptionsType } from "../../types/payment";

interface PaymentOptionsProps {
  options: PaymentOptionsType;
  onOptionsChange: (options: Partial<PaymentOptionsType>) => void;
}

/**
 * 決済オプション（寄付・レシート設定）を管理するコンポーネント
 */
export const PaymentOptions: React.FC<PaymentOptionsProps> = ({
  options,
  onOptionsChange,
}) => {
  const handleDonationChange = (checked: boolean) => {
    onOptionsChange({ includeDonation: checked });
  };

  const handleReceiptChange = (checked: boolean) => {
    onOptionsChange({ disablePaperReceipt: checked });
  };

  return (
    <div className="space-y-2">
      <div className="flex items-start space-x-2">
        <Checkbox
          id="donate"
          checked={options.includeDonation}
          onCheckedChange={handleDonationChange}
        />
        <div className="grid gap-1">
          <Label
            htmlFor="donate"
            className="text-sm font-medium text-stone-800 cursor-pointer"
          >
            環境保全活動に{formatCurrency(options.donationAmount)}を寄付する
          </Label>
          {options.donationDescription && (
            <p className="text-xs text-stone-600">
              {options.donationDescription}
            </p>
          )}
        </div>
      </div>

      <div className="flex items-start space-x-2">
        <Checkbox
          id="receipt"
          checked={options.disablePaperReceipt}
          onCheckedChange={handleReceiptChange}
        />
        <div className="grid gap-1">
          <Label
            htmlFor="receipt"
            className="text-sm font-medium text-stone-800 cursor-pointer"
          >
            紙のレシートを発行しない
          </Label>
          <p className="text-xs text-stone-600">
            電子レシートをメールでお送りします
          </p>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/features/payment/components/PaymentSummary/index.ts">
export { PaymentSummary } from "./PaymentSummary";
</file>

<file path="src/features/payment/components/PaymentSummary/PaymentSummary.tsx">
import React from "react";
import { Separator } from "@/components/ui/separator";
import { useFormattedCurrency } from "@/shared/hooks/useFormattedCurrency";

interface PaymentSummaryProps {
  subtotal: number;
  donationAmount: number;
  total: number;
  showDonation?: boolean;
}

/**
 * 決済サマリーを表示するコンポーネント
 */
export const PaymentSummary: React.FC<PaymentSummaryProps> = ({
  subtotal,
  donationAmount,
  total,
  showDonation = true,
}) => {
  const formattedSubtotal = useFormattedCurrency(subtotal);
  const formattedDonation = useFormattedCurrency(donationAmount);
  const formattedTotal = useFormattedCurrency(total);

  return (
    <div className="pt-2 space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-stone-600">小計</span>
        <span className="text-stone-800">{formattedSubtotal}</span>
      </div>
      {showDonation && donationAmount > 0 && (
        <div className="flex justify-between text-sm">
          <span className="text-stone-600">環境保全負担金（寄付）</span>
          <span className="text-stone-800">{formattedDonation}</span>
        </div>
      )}
      <Separator className="my-2" />
      <div className="flex justify-between font-medium">
        <span className="text-stone-800">合計</span>
        <span className="text-teal-800">{formattedTotal}</span>
      </div>
    </div>
  );
};
</file>

<file path="src/features/payment/components/ProductInfo/index.ts">
export { ProductInfo } from "./ProductInfo";
</file>

<file path="src/features/payment/components/ProductInfo/ProductInfo.tsx">
import React from "react";
import { useFormattedCurrency } from "@/shared/hooks/useFormattedCurrency";
import type { Product } from "../../types/payment";

interface ProductInfoProps {
  product: Product;
}

/**
 * 商品情報を表示するコンポーネント
 */
export const ProductInfo: React.FC<ProductInfoProps> = ({ product }) => {
  const formattedPrice = useFormattedCurrency(product.price);

  return (
    <div className="bg-stone-50 rounded-md p-3">
      <div className="flex justify-between items-center">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-stone-200 rounded flex items-center justify-center">
            {product.icon ? (
              <div dangerouslySetInnerHTML={{ __html: product.icon }} />
            ) : (
              <svg viewBox="0 0 24 24" className="h-6 w-6 text-stone-500">
                <path
                  fill="currentColor"
                  d="M21,9H3V3H21V9M13,11H3V21H13V11M21,11H15V15H21V11M21,17H15V21H21V17Z"
                />
              </svg>
            )}
          </div>
          <div>
            <h4 className="text-sm font-medium text-stone-800">
              {product.name}
            </h4>
            <p className="text-xs text-stone-600">{product.description}</p>
          </div>
        </div>
        <span className="text-sm font-medium text-stone-800">
          {formattedPrice}
        </span>
      </div>
    </div>
  );
};
</file>

<file path="src/features/payment/data/payment-data.ts">
import type { Product, PaymentMethodDetail } from "../types/payment";

/**
 * 商品のモックデータ
 */
export const mockProducts: Product[] = [
  {
    id: "product-1",
    name: "エコ製品定期プラン",
    description: "リサイクル素材100%",
    price: 3800,
    isEcoFriendly: true,
    ecoDescription:
      "この商品はリサイクル素材を使用し、製造過程でのCO2排出量を80%削減しています",
  },
  {
    id: "product-2",
    name: "エコバッグセット",
    description: "再生可能素材使用",
    price: 2500,
    isEcoFriendly: true,
    ecoDescription: "持続可能な素材を使用し、プラスチック削減に貢献します",
  },
  {
    id: "product-3",
    name: "リユーザブルボトル",
    description: "BPAフリー・耐久性抜群",
    price: 1800,
    isEcoFriendly: true,
    ecoDescription: "使い捨てプラスチックボトルの削減に貢献します",
  },
];

/**
 * 支払い方法のモックデータ
 */
export const mockPaymentMethods: PaymentMethodDetail[] = [
  {
    type: "wallet",
    label: "Eco Wallet残高",
    balance: 12500,
    isDisabled: false,
  },
  {
    type: "card",
    label: "登録済みカード",
    isDisabled: true,
    cardLast4: "1234",
    cardBrand: "Visa",
  },
  {
    type: "bank",
    label: "銀行振込",
    isDisabled: true,
  },
];

/**
 * デフォルトの決済オプション
 */
export const defaultPaymentOptions = {
  includeDonation: true,
  donationAmount: 200,
  disablePaperReceipt: false,
  donationDescription: "寄付金は山岳地域の清掃活動に使用されます",
};
</file>

<file path="src/features/payment/types/payment.ts">
/**
 * 商品情報の型定義
 */
export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  icon?: string;
  isEcoFriendly?: boolean;
  ecoDescription?: string;
}

/**
 * 支払い方法の型定義
 */
export type PaymentMethod = "wallet" | "card" | "bank";

/**
 * 支払い方法詳細の型定義
 */
export interface PaymentMethodDetail {
  type: PaymentMethod;
  label: string;
  balance?: number;
  isDisabled?: boolean;
  cardLast4?: string;
  cardBrand?: string;
}

/**
 * 決済オプションの型定義
 */
export interface PaymentOptions {
  includeDonation: boolean;
  donationAmount: number;
  disablePaperReceipt: boolean;
  donationDescription?: string;
}

/**
 * 決済情報の型定義
 */
export interface PaymentInfo {
  product: Product;
  subtotal: number;
  donationAmount: number;
  total: number;
  selectedPaymentMethod: PaymentMethod;
  options: PaymentOptions;
}

/**
 * 決済処理の状態
 */
export type PaymentStatus = "idle" | "processing" | "success" | "error";

/**
 * 決済ストアの状態
 */
export interface PaymentStore {
  // 状態
  paymentInfo: PaymentInfo | null;
  paymentStatus: PaymentStatus;
  error: string | null;

  // アクション
  setPaymentInfo: (info: PaymentInfo) => void;
  setPaymentMethod: (method: PaymentMethod) => void;
  setPaymentOptions: (options: Partial<PaymentOptions>) => void;
  processPayment: () => Promise<{
    success: boolean;
    transactionId?: string;
    error?: string;
  }>;
  resetPayment: () => void;
}
</file>

<file path="src/features/payment/README.md">
# Payment Feature Module

決済機能を提供するfeatureモジュールです。商品情報の表示、支払い方法の選択、決済オプションの管理、決済処理を含みます。

## 構造

```
payment/
├── components/
│   ├── ProductInfo/          # 商品情報表示
│   ├── PaymentSummary/       # 決済サマリー
│   ├── PaymentMethodSelector/# 支払い方法選択
│   └── PaymentOptions/       # 決済オプション（寄付・レシート）
├── types/
│   └── payment.ts           # 型定義
├── store/
│   └── payment.slice.ts     # Zustand状態管理
├── data/
│   └── payment-data.ts      # モックデータ
├── index.ts                 # Public API
└── README.md               # このファイル
```

## 主な型定義

- `Product`: 商品情報
- `PaymentMethod`: 支払い方法（'wallet' | 'card' | 'bank'）
- `PaymentMethodDetail`: 支払い方法の詳細情報
- `PaymentOptions`: 決済オプション（寄付・レシート設定）
- `PaymentInfo`: 決済情報全体
- `PaymentStatus`: 決済処理の状態

## コンポーネント

### ProductInfo

商品情報を表示するコンポーネント。商品名、説明、価格を表示。

### PaymentSummary

決済金額のサマリーを表示。小計、寄付金額、合計を表示。

### PaymentMethodSelector

支払い方法を選択するためのラジオボタングループ。

### PaymentOptions

決済オプション（環境保全寄付、紙レシート無効化）を管理。

## ストア (Zustand)

### usePaymentStore

決済情報と処理状態を管理するZustandストア。

**状態:**

- `paymentInfo`: 決済情報
- `paymentStatus`: 処理状態
- `error`: エラーメッセージ

**アクション:**

- `setPaymentInfo`: 決済情報を設定
- `setPaymentMethod`: 支払い方法を変更
- `setPaymentOptions`: 決済オプションを更新
- `processPayment`: 決済処理を実行
- `resetPayment`: 状態をリセット

## 使用例

```tsx
import {
  usePaymentStore,
  ProductInfo,
  PaymentSummary,
  PaymentMethodSelector,
  PaymentOptionsComponent,
  mockProducts,
  mockPaymentMethods,
  defaultPaymentOptions,
} from "@/features/payment";

function PaymentPage() {
  const {
    paymentInfo,
    paymentStatus,
    setPaymentInfo,
    setPaymentMethod,
    setPaymentOptions,
    processPayment,
  } = usePaymentStore();

  // 初期化
  useEffect(() => {
    setPaymentInfo({
      product: mockProducts[0],
      subtotal: mockProducts[0].price,
      donationAmount: defaultPaymentOptions.donationAmount,
      total: mockProducts[0].price + defaultPaymentOptions.donationAmount,
      selectedPaymentMethod: "wallet",
      options: defaultPaymentOptions,
    });
  }, []);

  const handlePayment = async () => {
    const result = await processPayment();
    if (result.success) {
      router.push(`/history/${result.transactionId}`);
    }
  };

  return (
    <div>
      <ProductInfo product={paymentInfo.product} />
      <PaymentSummary {...paymentInfo} />
      <PaymentMethodSelector
        methods={mockPaymentMethods}
        selectedMethod={paymentInfo.selectedPaymentMethod}
        onMethodChange={setPaymentMethod}
      />
      <PaymentOptionsComponent
        options={paymentInfo.options}
        onOptionsChange={setPaymentOptions}
      />
      <button onClick={handlePayment}>決済を確定する</button>
    </div>
  );
}
```

## トランザクションとの連携

決済が成功すると、自動的にトランザクションストアに新しいトランザクションが追加されます。
環境貢献オプションが有効な場合、トランザクションにエコ貢献情報が含まれます。

## 注意事項

- 現在はモックデータを使用していますが、実際のAPIとの連携時は`processPayment`メソッドを更新する必要があります
- 支払い方法として現在は'wallet'のみが有効になっています
- 決済処理中は他の操作を無効化することを推奨します
</file>

<file path="src/features/qrcode/components/BarCodeDisplay/BarCodeDisplay.tsx">
"use client";

import React from "react";
import { generateBarcodeNumber } from "../../utils/qrcode-utils";

interface BarCodeDisplayProps {
  value?: string;
  prefix?: string;
  showLabel?: boolean;
  className?: string;
}

export const BarCodeDisplay: React.FC<BarCodeDisplayProps> = ({
  value,
  prefix = "8945",
  showLabel = true,
  className = "",
}) => {
  const barcodeNumber = value || generateBarcodeNumber(prefix);

  return (
    <div className={`p-4 bg-white flex flex-col items-center ${className}`}>
      {showLabel && (
        <p className="text-xs text-stone-600 mb-2">
          バーコード (店舗によって異なります)
        </p>
      )}
      <div className="bg-white py-2 px-4 w-full border border-stone-100 rounded-md">
        <svg viewBox="0 0 200 50" className="w-full h-12">
          {/* バーコードのバーを生成 */}
          <rect x="10" y="5" width="2" height="40" fill="black" />
          <rect x="15" y="5" width="1" height="40" fill="black" />
          <rect x="20" y="5" width="3" height="40" fill="black" />
          <rect x="25" y="5" width="1" height="40" fill="black" />
          <rect x="30" y="5" width="2" height="40" fill="black" />
          <rect x="36" y="5" width="4" height="40" fill="black" />
          <rect x="42" y="5" width="1" height="40" fill="black" />
          <rect x="46" y="5" width="2" height="40" fill="black" />
          <rect x="52" y="5" width="3" height="40" fill="black" />
          <rect x="58" y="5" width="1" height="40" fill="black" />
          <rect x="62" y="5" width="4" height="40" fill="black" />
          <rect x="70" y="5" width="2" height="40" fill="black" />
          <rect x="76" y="5" width="3" height="40" fill="black" />
          <rect x="82" y="5" width="1" height="40" fill="black" />
          <rect x="86" y="5" width="2" height="40" fill="black" />
          <rect x="92" y="5" width="1" height="40" fill="black" />
          <rect x="96" y="5" width="4" height="40" fill="black" />
          <rect x="104" y="5" width="2" height="40" fill="black" />
          <rect x="110" y="5" width="3" height="40" fill="black" />
          <rect x="116" y="5" width="1" height="40" fill="black" />
          <rect x="120" y="5" width="4" height="40" fill="black" />
          <rect x="126" y="5" width="2" height="40" fill="black" />
          <rect x="132" y="5" width="1" height="40" fill="black" />
          <rect x="136" y="5" width="3" height="40" fill="black" />
          <rect x="142" y="5" width="2" height="40" fill="black" />
          <rect x="146" y="5" width="3" height="40" fill="black" />
          <rect x="152" y="5" width="2" height="40" fill="black" />
          <rect x="158" y="5" width="1" height="40" fill="black" />
          <rect x="162" y="5" width="4" height="40" fill="black" />
          <rect x="170" y="5" width="2" height="40" fill="black" />
          <rect x="176" y="5" width="1" height="40" fill="black" />
          <rect x="180" y="5" width="3" height="40" fill="black" />
          <rect x="186" y="5" width="2" height="40" fill="black" />
        </svg>
        <p className="text-xs text-center mt-1 font-mono text-stone-600">
          {barcodeNumber}
        </p>
      </div>
    </div>
  );
};
</file>

<file path="src/features/qrcode/components/BarCodeDisplay/index.ts">
export { BarCodeDisplay } from "./BarCodeDisplay";
</file>

<file path="src/features/qrcode/components/QRCodeDisplay/index.ts">
export { QRCodeDisplay } from "./QRCodeDisplay";
</file>

<file path="src/features/qrcode/components/QRCodeDisplay/QRCodeDisplay.tsx">
"use client";

import QRCode from "react-qr-code";

interface QRCodeDisplayProps {
  value: string;
  size?: number;
  level?: "L" | "M" | "Q" | "H";
  bgColor?: string;
  fgColor?: string;
  className?: string;
}

export const QRCodeDisplay: React.FC<QRCodeDisplayProps> = ({
  value,
  size = 200,
  level = "H",
  bgColor = "#FFFFFF",
  fgColor = "#0F766E",
  className = "",
}) => {
  return (
    <div
      className={`bg-white p-4 rounded-lg border-2 border-stone-200 ${className}`}
    >
      <QRCode
        value={value}
        size={size}
        level={level}
        bgColor={bgColor}
        fgColor={fgColor}
        style={{
          height: "auto",
          maxWidth: "100%",
          width: "100%",
        }}
      />
    </div>
  );
};
</file>

<file path="src/features/qrcode/components/QRCodeGenerator/index.ts">
export { QRCodeGenerator } from "./QRCodeGenerator";
</file>

<file path="src/features/qrcode/components/QRCodeGenerator/QRCodeGenerator.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { RefreshCcw, CheckCircle } from "lucide-react";
import { Progress } from "@/components/ui/progress";
import { useQRCodeGenerator } from "../../hooks/useQRCodeGenerator";
import { QRCodeDisplay } from "../QRCodeDisplay";
import type { QRCodeType, QRCodeGeneratorOptions } from "../../types/qrcode";

interface QRCodeGeneratorProps {
  type?: QRCodeType;
  options?: QRCodeGeneratorOptions;
  showHeader?: boolean;
  showSecurityCode?: boolean;
  showTimer?: boolean;
  className?: string;
}

export const QRCodeGenerator: React.FC<QRCodeGeneratorProps> = ({
  type = "payment",
  options = {
    size: 200,
    level: "H",
    fgColor: "#0F766E",
  },
  showHeader = true,
  showSecurityCode = true,
  showTimer = true,
  className = "",
}) => {
  const {
    qrContent,
    timeLeft,
    formattedTimeLeft,
    isExpired,
    isGenerating,
    error,
    generateNewCode,
  } = useQRCodeGenerator({ type });

  const [copied, setCopied] = useState(false);

  // セキュリティコードをコピー
  const copySecurityCode = () => {
    if (qrContent?.securityCode) {
      navigator.clipboard.writeText(qrContent.securityCode);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  // 進捗バーの計算
  const totalTime = type === "payment" ? 240 : 600; // 支払いは4分、その他は10分
  const progressValue = (timeLeft / totalTime) * 100;

  if (error) {
    return (
      <div className={`p-4 bg-red-50 text-red-600 rounded-lg ${className}`}>
        <p className="text-sm">{error}</p>
        <Button
          variant="outline"
          size="sm"
          onClick={generateNewCode}
          className="mt-2"
        >
          再試行
        </Button>
      </div>
    );
  }

  return (
    <div className={className}>
      {showHeader && (
        <div className="p-4 bg-white">
          <div className="flex justify-between items-center">
            <h2 className="text-lg font-medium text-stone-800">
              {type === "payment" ? "お支払いコード" : "QRコード"}
            </h2>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 p-0 w-8 text-teal-700 hover:bg-teal-50"
              onClick={generateNewCode}
              disabled={isGenerating}
              aria-label="コードを更新"
            >
              <RefreshCcw
                className={`h-4 w-4 ${isGenerating ? "animate-spin" : ""}`}
              />
            </Button>
          </div>
          <p className="text-sm text-stone-600">
            {type === "payment"
              ? "店舗のスキャナーにかざしてください"
              : "QRコードをスキャンしてください"}
          </p>
        </div>
      )}

      {/* QRコード表示エリア */}
      <div className="bg-white p-6 flex flex-col items-center justify-center">
        {qrContent && (
          <QRCodeDisplay
            value={qrContent.data}
            size={options.size}
            level={options.level}
            fgColor={options.fgColor}
            bgColor={options.bgColor}
          />
        )}

        {showTimer && (
          <div className="mt-4 w-full max-w-xs">
            {/* タイマー表示 */}
            <div className="flex justify-between items-center text-xs text-stone-600 mb-1">
              <span>有効期限:</span>
              <span className={timeLeft < 60 ? "text-red-500 font-medium" : ""}>
                あと{formattedTimeLeft}
              </span>
            </div>
            <Progress value={progressValue} className="h-1.5 bg-stone-100" />
          </div>
        )}

        {/* セキュリティコード表示 - コピー機能付き */}
        {showSecurityCode && qrContent?.securityCode && (
          <div
            className="mt-4 flex items-center justify-center border border-stone-200 rounded-md p-2 cursor-pointer hover:bg-stone-50"
            onClick={copySecurityCode}
          >
            <span className="text-sm text-stone-800 font-mono mr-2">
              セキュリティコード: {qrContent.securityCode}
            </span>
            {copied ? (
              <CheckCircle className="h-4 w-4 text-teal-600" />
            ) : (
              <Button
                variant="ghost"
                size="sm"
                className="h-6 w-6 p-0 text-stone-500"
                aria-label="コードをコピー"
                onClick={(e) => {
                  e.stopPropagation();
                  copySecurityCode();
                }}
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
              </Button>
            )}
          </div>
        )}

        {isExpired && (
          <div className="mt-4 text-sm text-red-600">
            QRコードの有効期限が切れました。更新してください。
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/features/qrcode/components/QRCodePage/index.ts">
export { QRCodePage } from "./QRCodePage";
</file>

<file path="src/features/qrcode/components/QRCodePage/QRCodePage.tsx">
"use client";

import Link from "next/link";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import { Leaf, Shield, Info, MapPin, ArrowLeft } from "lucide-react";
import { QRCodeGenerator } from "../QRCodeGenerator";
import { BarCodeDisplay } from "../BarCodeDisplay";

interface QRCodePageProps {
  balance?: number;
}

export const QRCodePage: React.FC<QRCodePageProps> = ({ balance = 8500 }) => {
  return (
    <div className="flex min-h-screen bg-stone-50 flex-col">
      {/* ヘッダー部分 - ティールカラーを適用 */}
      <div className="p-4 bg-teal-700 text-white shadow-md">
        <div className="flex justify-between items-center max-w-md mx-auto">
          <div className="flex items-center space-x-2">
            <Link href="/" aria-label="ホームに戻る">
              <svg viewBox="0 0 100 40" className="h-8 w-auto fill-white">
                <path d="M50,0 L75,20 L65,40 H35 L25,20 L50,0z" />
                <path d="M45,15 L55,15 L55,25 L45,25 L45,15z" fill="teal" />
              </svg>
            </Link>
            <h1 className="text-lg font-bold">Eco Wallet</h1>
          </div>
          <Link href="/" aria-label="戻る">
            <Button
              variant="ghost"
              size="sm"
              className="text-white hover:bg-teal-600 transition-colors"
            >
              <ArrowLeft className="h-4 w-4 mr-1" />
              戻る
            </Button>
          </Link>
          <div className="text-sm font-medium">
            残高: ¥{balance.toLocaleString()}
          </div>
        </div>
      </div>

      {/* メインコンテンツ */}
      <div className="flex-1 flex flex-col items-center justify-center p-4 bg-stone-50">
        <Card className="w-full max-w-md border-0 shadow-lg">
          <CardContent className="p-0">
            {/* QRコードジェネレーターコンポーネント */}
            <QRCodeGenerator type="payment" />

            <Separator />

            {/* 環境保全メッセージ */}
            <div className="eco-contribution-container mx-4 my-4">
              <div className="flex items-start space-x-3">
                <Leaf className="h-5 w-5 text-teal-700 mt-0.5" />
                <div>
                  <h3 className="text-sm font-medium text-teal-800">
                    環境保全オプション有効
                  </h3>
                  <p className="text-xs text-teal-700 mt-1">
                    このお支払いの1%が山岳環境保全プロジェクトに寄付されます。
                    あなたの取引で年間約500gの紙資源を節約できます。
                  </p>
                  <Badge className="mt-2 bg-teal-100 text-teal-800 hover:bg-teal-200 text-xs">
                    CO2削減: 約5kg/年
                  </Badge>
                </div>
              </div>
            </div>

            <Separator />

            {/* バーコード表示 */}
            <BarCodeDisplay />
          </CardContent>
        </Card>

        {/* 下部のアクションエリア */}
        <div className="w-full max-w-md mt-4 flex justify-between">
          <Link href="/history">
            <Button
              variant="outline"
              size="sm"
              className="border-stone-200 text-stone-600 hover:bg-stone-100"
            >
              <Shield className="h-4 w-4 mr-2" />
              取引履歴
            </Button>
          </Link>
          <Button
            variant="outline"
            size="sm"
            className="border-stone-200 text-stone-600 hover:bg-stone-100"
          >
            <MapPin className="h-4 w-4 mr-2" />
            近くの店舗
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="border-stone-200 text-stone-600 hover:bg-stone-100"
          >
            <Info className="h-4 w-4 mr-2" />
            ヘルプ
          </Button>
        </div>

        <p className="text-xs text-center text-stone-500 mt-6">
          この決済方法を選ぶことで、紙の領収書を削減し環境保全に貢献しています
        </p>
      </div>
    </div>
  );
};
</file>

<file path="src/features/qrcode/components/QRCodeScanner/index.ts">
export { QRCodeScanner } from "./QRCodeScanner";
</file>

<file path="src/features/qrcode/components/QRCodeScanner/QRCodeScanner.tsx">
"use client";

import { useRef, useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Alert } from "@/components/ui/alert";
import { Camera, Loader2, X } from "lucide-react";
import { useQRCodeScanner } from "../../hooks/useQRCodeScanner";
import type { QRCodeScanResult } from "../../types/qrcode";

interface QRCodeScannerProps {
  onScan?: (result: QRCodeScanResult) => void;
  onError?: (error: string) => void;
  showHeader?: boolean;
  className?: string;
}

export const QRCodeScanner: React.FC<QRCodeScannerProps> = ({
  onScan,
  onError,
  showHeader = true,
  className = "",
}) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isScanning, setIsScanning] = useState(false);
  const [cameraError, setCameraError] = useState<string | null>(null);

  const {
    scanResult,
    isCameraActive,
    isCameraLoading,
    error,
    startCamera,
    stopCamera,
    resetScan,
  } = useQRCodeScanner({
    videoRef,
    canvasRef,
  });

  // カメラの開始/停止
  const handleToggleCamera = async () => {
    if (isCameraActive) {
      stopCamera();
      setIsScanning(false);
    } else {
      try {
        setCameraError(null);
        setIsScanning(true);
        await startCamera();
      } catch {
        setCameraError("カメラへのアクセスが拒否されました");
        setIsScanning(false);
      }
    }
  };

  // スキャン結果の処理
  useEffect(() => {
    if (scanResult && onScan) {
      onScan(scanResult);
      // 自動的にカメラを停止
      stopCamera();
      setIsScanning(false);
    }
  }, [scanResult, onScan, stopCamera]);

  // エラーの処理
  useEffect(() => {
    if (error) {
      if (onError) {
        onError(error);
      }
      setCameraError(error);
    }
  }, [error, onError]);

  // コンポーネントのアンマウント時にカメラを停止
  useEffect(() => {
    return () => {
      if (isCameraActive) {
        stopCamera();
      }
    };
  }, [isCameraActive, stopCamera]);

  return (
    <div className={className}>
      {showHeader && (
        <div className="p-4 bg-white border-b">
          <h2 className="text-lg font-medium text-stone-800">
            QRコードスキャナー
          </h2>
          <p className="text-sm text-stone-600">
            QRコードをカメラに映してスキャンしてください
          </p>
        </div>
      )}

      <div className="bg-white p-6">
        {/* カメラビュー */}
        {isScanning && (
          <div className="relative w-full max-w-md mx-auto mb-4">
            <div className="relative aspect-square bg-black rounded-lg overflow-hidden">
              <video
                ref={videoRef}
                className="absolute inset-0 w-full h-full object-cover"
                autoPlay
                playsInline
                muted
              />
              <canvas
                ref={canvasRef}
                className="absolute inset-0 w-full h-full pointer-events-none"
                style={{ display: "none" }}
              />

              {/* スキャンフレーム */}
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-64 h-64 relative">
                  {/* 四隅の角 */}
                  <div className="absolute top-0 left-0 w-8 h-8 border-t-2 border-l-2 border-teal-500"></div>
                  <div className="absolute top-0 right-0 w-8 h-8 border-t-2 border-r-2 border-teal-500"></div>
                  <div className="absolute bottom-0 left-0 w-8 h-8 border-b-2 border-l-2 border-teal-500"></div>
                  <div className="absolute bottom-0 right-0 w-8 h-8 border-b-2 border-r-2 border-teal-500"></div>

                  {/* スキャンライン（アニメーション） */}
                  <div className="absolute left-0 right-0 h-0.5 bg-teal-500 animate-scan"></div>
                </div>
              </div>

              {/* 閉じるボタン */}
              <Button
                variant="ghost"
                size="sm"
                className="absolute top-2 right-2 h-8 w-8 p-0 bg-black/50 hover:bg-black/70 text-white"
                onClick={handleToggleCamera}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>

            {isCameraLoading && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/50 rounded-lg">
                <Loader2 className="h-8 w-8 text-white animate-spin" />
              </div>
            )}
          </div>
        )}

        {/* エラー表示 */}
        {cameraError && (
          <Alert variant="destructive" className="mb-4">
            <p className="text-sm">{cameraError}</p>
          </Alert>
        )}

        {/* スキャン結果表示 */}
        {scanResult && (
          <div className="mb-4 p-4 bg-teal-50 border border-teal-200 rounded-lg">
            <h3 className="text-sm font-medium text-teal-800 mb-1">
              スキャン成功
            </h3>
            <p className="text-sm text-teal-700 font-mono break-all">
              {scanResult.data}
            </p>
            <Button
              variant="outline"
              size="sm"
              onClick={resetScan}
              className="mt-2"
            >
              再スキャン
            </Button>
          </div>
        )}

        {/* カメラ起動ボタン */}
        {!isScanning && !scanResult && (
          <div className="text-center">
            <Button
              onClick={handleToggleCamera}
              disabled={isCameraLoading}
              className="bg-teal-700 hover:bg-teal-800 text-white"
            >
              {isCameraLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  カメラを起動中...
                </>
              ) : (
                <>
                  <Camera className="mr-2 h-4 w-4" />
                  QRコードをスキャン
                </>
              )}
            </Button>
          </div>
        )}

        {/* 使用方法 */}
        {!isScanning && !scanResult && (
          <div className="mt-6 space-y-2">
            <h3 className="text-sm font-medium text-stone-800">使用方法：</h3>
            <ol className="text-sm text-stone-600 space-y-1 list-decimal list-inside">
              <li>「QRコードをスキャン」ボタンをタップ</li>
              <li>カメラへのアクセスを許可</li>
              <li>QRコードをフレーム内に収める</li>
              <li>自動的にスキャンされます</li>
            </ol>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/features/qrcode/utils/qrcode-utils.ts">
/**
 * QRコード関連のユーティリティ関数
 */

import { QRCodeContent, QRCodeType } from "../types/qrcode";

/**
 * ランダムなセキュリティコードを生成
 * @param length コードの長さ（デフォルト: 6）
 * @returns 生成されたセキュリティコード
 */
export const generateSecurityCode = (length: number = 6): string => {
  const min = Math.pow(10, length - 1);
  const max = Math.pow(10, length) - 1;
  return Math.floor(min + Math.random() * (max - min + 1)).toString();
};

/**
 * QRコードのURLを生成
 * @param type QRコードのタイプ
 * @param data データ
 * @returns QRコード用のURL
 */
export const generateQRCodeUrl = (type: QRCodeType, data: string): string => {
  switch (type) {
    case "payment":
      return `ecowallet://payment/${data}`;
    case "transfer":
      return `ecowallet://transfer/${data}`;
    case "invitation":
      return `ecowallet://invite/${data}`;
    default:
      return data;
  }
};

/**
 * QRコードコンテンツを生成
 * @param type QRコードのタイプ
 * @param data データ
 * @param expirationMinutes 有効期限（分）
 * @returns QRコードコンテンツ
 */
export const createQRCodeContent = (
  type: QRCodeType,
  data: string,
  expirationMinutes: number = 4,
): QRCodeContent => {
  const expiresAt = new Date();
  expiresAt.setMinutes(expiresAt.getMinutes() + expirationMinutes);

  const securityCode = type === "payment" ? generateSecurityCode() : undefined;

  return {
    type,
    data: generateQRCodeUrl(type, securityCode || data),
    securityCode,
    expiresAt,
  };
};

/**
 * 残り時間をフォーマット
 * @param seconds 秒数
 * @returns フォーマットされた時間（例: "3:45"）
 */
export const formatTimeLeft = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, "0")}`;
};

/**
 * QRコードの有効期限をチェック
 * @param expiresAt 有効期限
 * @returns 有効かどうか
 */
export const isQRCodeValid = (expiresAt?: Date): boolean => {
  if (!expiresAt) return true;
  return new Date() < expiresAt;
};

/**
 * QRコードのデータをパース
 * @param qrData QRコードのデータ
 * @returns パースされたデータ
 */
export const parseQRCodeData = (
  qrData: string,
): {
  protocol?: string;
  type?: string;
  data?: string;
} => {
  const match = qrData.match(/^(\w+):\/\/(\w+)\/(.+)$/);
  if (match) {
    return {
      protocol: match[1],
      type: match[2],
      data: match[3],
    };
  }
  return { data: qrData };
};

/**
 * バーコード番号を生成
 * @param prefix プレフィックス
 * @returns バーコード番号
 */
export const generateBarcodeNumber = (prefix: string = "8945"): string => {
  const randomPart = Array.from({ length: 12 }, () =>
    Math.floor(Math.random() * 10),
  ).join("");
  return `${prefix} ${randomPart.slice(0, 4)} ${randomPart.slice(
    4,
    8,
  )} ${randomPart.slice(8, 12)}`;
};

/**
 * QRコードエラーメッセージ
 */
export const QR_CODE_ERRORS = {
  CAMERA_NOT_AVAILABLE: "カメラが利用できません",
  PERMISSION_DENIED: "カメラの使用許可が必要です",
  SCAN_FAILED: "QRコードの読み取りに失敗しました",
  INVALID_FORMAT: "無効なQRコード形式です",
  EXPIRED: "QRコードの有効期限が切れています",
  GENERATION_FAILED: "QRコードの生成に失敗しました",
} as const;

/**
 * QRコードの有効期限（秒）
 */
export const QR_CODE_EXPIRATION = {
  PAYMENT: 240, // 4分
  TRANSFER: 600, // 10分
  INVITATION: 86400, // 24時間
  GENERAL: 3600, // 1時間
} as const;
</file>

<file path="src/features/qrcode/index.ts">
/**
 * QRコードモジュール
 *
 * QRコードの生成、スキャン、表示機能を提供
 */

// コンポーネント
export { QRCodeDisplay } from "./components/QRCodeDisplay";
export { QRCodeGenerator } from "./components/QRCodeGenerator";
export { QRCodeScanner } from "./components/QRCodeScanner";
export { BarCodeDisplay } from "./components/BarCodeDisplay";
export { QRCodePage } from "./components/QRCodePage";

// フック
export { useQRCodeGenerator } from "./hooks/useQRCodeGenerator";
export { useQRCodeScanner } from "./hooks/useQRCodeScanner";

// 型定義
export type {
  QRCodeType,
  QRCodeContent,
  QRCodeGeneratorOptions,
  QRCodePaymentData,
  QRCodeScanResult,
  QRCodeState,
  BarcodeData,
  QRCodeHistory,
} from "./types/qrcode";

// ユーティリティ
export {
  generateSecurityCode,
  generateQRCodeUrl,
  createQRCodeContent,
  formatTimeLeft,
  isQRCodeValid,
  parseQRCodeData,
  generateBarcodeNumber,
  QR_CODE_ERRORS,
  QR_CODE_EXPIRATION,
} from "./utils/qrcode-utils";
</file>

<file path="src/features/settings/components/PageHeader/index.ts">
export { PageHeader } from "./PageHeader";
</file>

<file path="src/features/settings/components/ProfileCard/index.ts">
export { ProfileCard } from "./ProfileCard";
export type { ProfileCardProps } from "./ProfileCard";
</file>

<file path="src/features/settings/components/ProfileCard/ProfileCard.tsx">
"use client";

import Link from "next/link";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ChevronRight, Leaf, Upload } from "lucide-react";
import { Session } from "next-auth";
import { UserProfile } from "../../types/settings";

/**
 * プロフィールカードのプロパティ
 */
export interface ProfileCardProps {
  /** ユーザー情報 */
  user?: Session["user"] | UserProfile;
  /** 環境貢献データ */
  ecoContribution?: {
    donation: number; // 累計寄付額
    forestArea: number; // 森林保全面積(m²)
    co2Reduction: number; // CO2削減量(kg)
  };
  /** カードの幅のカスタマイズ用クラス */
  className?: string;
}

/**
 * ユーザープロフィールカードを表示するコンポーネント
 *
 * @param user ユーザー情報
 * @param ecoContribution 環境貢献データ
 * @param className カスタムCSSクラス
 */
export function ProfileCard({
  user,
  ecoContribution = {
    donation: 12450,
    forestArea: 5.2,
    co2Reduction: 25,
  },
  className = "sm:w-1/3",
}: ProfileCardProps) {
  return (
    <Card className={`${className} border-0 shadow-md bg-white`}>
      <div className="p-6">
        <div className="flex flex-col items-center text-center">
          <Avatar className="h-20 w-20 border-2 border-teal-100">
            <AvatarImage
              src={user?.image || "/api/placeholder/100/100"}
              alt="プロフィール画像"
            />
            <AvatarFallback className="bg-teal-100 text-teal-800">
              {user?.name ? user.name.slice(0, 2) : "山田"}
            </AvatarFallback>
          </Avatar>
          <Button
            variant="ghost"
            size="sm"
            className="mt-2 text-xs text-stone-600"
          >
            <Upload className="h-3 w-3 mr-1" />
            画像を変更
          </Button>
          <h2 className="mt-3 text-lg font-medium text-stone-900">
            {user?.name || "山田 太郎"}
          </h2>
          <p className="text-sm text-stone-600">
            {user?.email || "eco_user@example.com"}
          </p>

          <div className="mt-4 w-full">
            <Badge className="bg-teal-100 text-teal-800 hover:bg-teal-200 w-full flex items-center py-1.5">
              <Leaf className="h-3 w-3 mr-1" />
              {user?.ecoRank || "エコマイスター"}
            </Badge>
          </div>

          <div className="mt-6 w-full text-left">
            <h3 className="text-sm font-medium text-stone-800 mb-2">
              環境貢献状況
            </h3>
            <div className="space-y-1.5 text-sm">
              <div className="flex justify-between items-center">
                <span className="text-stone-600">累計寄付額</span>
                <span className="font-medium text-teal-700">
                  ¥{ecoContribution.donation.toLocaleString()}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-stone-600">森林保全面積</span>
                <span className="font-medium text-teal-700">
                  {ecoContribution.forestArea.toFixed(1)} m²
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-stone-600">削減CO2</span>
                <span className="font-medium text-teal-700">
                  {ecoContribution.co2Reduction} kg
                </span>
              </div>
            </div>

            <Link href="/impact">
              <Button className="w-full mt-4 text-xs text-teal-700 border border-teal-200 bg-white hover:bg-teal-50">
                環境インパクト詳細
                <ChevronRight className="h-3 w-3 ml-1" />
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/settings/components/SettingSection/index.ts">
export { SettingSection } from "./SettingSection";
export type { SettingSectionProps } from "./SettingSection";
</file>

<file path="src/features/settings/components/SettingSection/SettingSection.tsx">
import { ReactNode } from "react";

/**
 * 設定セクションのプロパティ
 */
export interface SettingSectionProps {
  /** セクションタイトル */
  title: string;
  /** アイコン（オプション） */
  icon?: ReactNode;
  /** 説明文（オプション） */
  description?: string;
  /** セクションの子要素 */
  children: ReactNode;
  /** 追加のCSSクラス（オプション） */
  className?: string;
}

/**
 * 設定画面のセクションを表示するコンポーネント
 *
 * @param title セクションタイトル
 * @param icon アイコン（オプション）
 * @param description 説明文（オプション）
 * @param children セクションの子要素
 * @param className 追加のCSSクラス（オプション）
 */
export function SettingSection({
  title,
  icon,
  description,
  children,
  className = "",
}: SettingSectionProps) {
  return (
    <div className={`space-y-4 ${className}`}>
      <div className="flex items-center space-x-2">
        {icon}
        <h3 className="text-sm font-medium text-stone-800">{title}</h3>
      </div>

      {description && <p className="text-xs text-stone-600">{description}</p>}

      {children}
    </div>
  );
}
</file>

<file path="src/features/settings/components/tabs/EcoTab.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import { Card } from "@/components/ui/card";
import {
  Leaf,
  TreePine,
  Droplets,
  Globe,
  CheckCircle,
  Info,
} from "lucide-react";
import { Session } from "next-auth";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { SettingSection } from "@/features/settings/components/SettingSection";

interface EcoTabProps {
  user?: Session["user"];
}

export function EcoTab({ user }: EcoTabProps) {
  // ユーザーのエコランクに基づいて初期値を設定
  const defaultEcoOption =
    user?.ecoRank === "エコマイスター" || user?.ecoRank === "エコチャンピオン"
      ? "climate"
      : "forest";

  // 設定の状態管理
  const [isSaved, setIsSaved] = useState(false);
  const [donationPercentage, setDonationPercentage] = useState("1");

  // 設定保存のハンドラー
  const handleSaveSettings = () => {
    setIsSaved(true);
    // 実際のアプリではここでAPI呼び出しなど

    // 一定時間後に保存完了通知を非表示
    setTimeout(() => {
      setIsSaved(false);
    }, 3000);
  };

  return (
    <div className="space-y-6">
      {/* ユーザーエコランク表示 */}
      <div className="flex items-center space-x-3 bg-teal-50 p-4 rounded-md border border-teal-100">
        <Leaf className="h-6 w-6 text-teal-700" />
        <div>
          <h3 className="text-sm font-medium text-teal-800">
            あなたの環境貢献ステータス
          </h3>
          <div className="flex items-center mt-1">
            <span className="text-xs text-teal-700 mr-2">
              {user?.name || "ユーザー"}さんは現在
            </span>
            <Badge className="bg-teal-100 text-teal-800">
              {user?.ecoRank || "エコビギナー"}
            </Badge>
            <span className="text-xs text-teal-700 ml-2">ランクです</span>
          </div>
        </div>
      </div>

      {/* 保存完了通知 */}
      {isSaved && (
        <div
          className="flex items-center bg-green-50 p-3 rounded-md border border-green-100"
          role="alert"
        >
          <CheckCircle className="h-4 w-4 text-green-600 mr-2" />
          <p className="text-sm text-green-700">設定が保存されました</p>
        </div>
      )}

      {/* 環境貢献の優先順位セクション */}
      <SettingSection
        title="環境貢献の優先順位"
        icon={<TreePine className="h-4 w-4 text-teal-700" />}
        description="貢献したい環境保全活動の優先順位を選択してください"
      >
        <RadioGroup defaultValue={defaultEcoOption} className="space-y-3">
          <Card className="border border-stone-200 p-4 hover:border-teal-200 transition-colors duration-200">
            <div className="flex items-start space-x-3">
              <RadioGroupItem
                value="forest"
                id="forest"
                className="mt-1"
                aria-label="森林保全を優先"
              />
              <div className="flex-1">
                <div className="flex items-center">
                  <TreePine className="h-4 w-4 text-teal-700 mr-2" />
                  <Label
                    htmlFor="forest"
                    className="text-sm font-medium text-stone-800 cursor-pointer"
                  >
                    森林保全を優先
                  </Label>
                </div>
                <p className="text-xs text-stone-600 mt-1">
                  寄付金は主に山岳地域の森林保全活動に使用されます。この選択により、年間約2m²の森林面積が保全されます。
                </p>
              </div>
            </div>
          </Card>

          <Card className="border border-stone-200 p-4 hover:border-teal-200 transition-colors duration-200">
            <div className="flex items-start space-x-3">
              <RadioGroupItem
                value="ocean"
                id="ocean"
                className="mt-1"
                aria-label="海洋保全を優先"
              />
              <div className="flex-1">
                <div className="flex items-center">
                  <Droplets className="h-4 w-4 text-blue-500 mr-2" />
                  <Label
                    htmlFor="ocean"
                    className="text-sm font-medium text-stone-800 cursor-pointer"
                  >
                    海洋保全を優先
                  </Label>
                </div>
                <p className="text-xs text-stone-600 mt-1">
                  寄付金は主に海洋プラスチック削減と海岸の清掃活動に使用されます。この選択により、年間約5kgのプラスチックが削減されます。
                </p>
              </div>
            </div>
          </Card>

          <Card className="border border-stone-200 p-4 hover:border-teal-200 transition-colors duration-200">
            <div className="flex items-start space-x-3">
              <RadioGroupItem
                value="climate"
                id="climate"
                className="mt-1"
                aria-label="気候変動対策を優先"
              />
              <div className="flex-1">
                <div className="flex items-center">
                  <Globe className="h-4 w-4 text-green-600 mr-2" />
                  <Label
                    htmlFor="climate"
                    className="text-sm font-medium text-stone-800 cursor-pointer"
                  >
                    気候変動対策を優先
                  </Label>
                </div>
                <p className="text-xs text-stone-600 mt-1">
                  寄付金は主に再生可能エネルギー促進とCO2削減活動に使用されます。この選択により、年間約15kgのCO2削減に貢献します。
                </p>
              </div>
            </div>
          </Card>
        </RadioGroup>
      </SettingSection>

      <Separator className="my-6" />

      {/* 環境貢献オプションセクション */}
      <SettingSection
        title="環境貢献オプション"
        icon={<Leaf className="h-4 w-4 text-teal-700" />}
      >
        <Card className="border border-stone-200 p-4">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label
                htmlFor="eco-option1"
                className="text-sm font-medium text-stone-800"
              >
                決済時の寄付オプションを常に有効化
              </Label>
              <p className="text-xs text-stone-500">
                決済額の1%が自動的に環境保全に寄付されます
              </p>
            </div>
            <Switch
              id="eco-option1"
              defaultChecked
              aria-label="決済時の寄付オプションを常に有効化"
            />
          </div>
        </Card>

        <Card className="border border-stone-200 p-4 mt-3">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label
                htmlFor="eco-option2"
                className="text-sm font-medium text-stone-800"
              >
                紙のレシートを辞退
              </Label>
              <p className="text-xs text-stone-500">
                電子レシートのみを受け取ります
              </p>
            </div>
            <Switch
              id="eco-option2"
              defaultChecked
              aria-label="紙のレシートを辞退"
            />
          </div>
        </Card>

        <Card className="border border-stone-200 p-4 mt-3">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label
                htmlFor="eco-option3"
                className="text-sm font-medium text-stone-800"
              >
                環境貢献レポートを受け取る
              </Label>
              <p className="text-xs text-stone-500">
                月に一度、あなたの環境貢献の詳細レポートを受け取ります
              </p>
            </div>
            <Switch
              id="eco-option3"
              defaultChecked
              aria-label="環境貢献レポートを受け取る"
            />
          </div>
        </Card>

        <Card className="border border-stone-200 p-4 mt-3">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label
                htmlFor="eco-option4"
                className="text-sm font-medium text-stone-800"
              >
                環境関連のお知らせを優先表示
              </Label>
              <p className="text-xs text-stone-500">
                環境保全活動に関する最新情報を優先的に受け取ります
              </p>
            </div>
            <Switch
              id="eco-option4"
              defaultChecked
              aria-label="環境関連のお知らせを優先表示"
            />
          </div>
        </Card>
      </SettingSection>

      {/* 寄付比率設定セクション */}
      <Card className="bg-teal-50 border border-teal-100 p-4 mt-6">
        <div className="flex items-start space-x-3">
          <div className="mt-0.5 bg-teal-100 p-1.5 rounded-full">
            <Leaf className="h-4 w-4 text-teal-700" />
          </div>
          <div className="flex-1">
            <h4 className="text-sm font-medium text-teal-800">
              環境貢献をさらに高める
            </h4>
            <p className="text-xs text-teal-700 mt-1">
              決済額からの寄付比率を増やすことで、より大きな環境インパクトを生み出せます
            </p>

            <div className="mt-3 relative">
              <Select
                defaultValue={donationPercentage}
                onValueChange={setDonationPercentage}
              >
                <SelectTrigger className="border-teal-200 bg-white">
                  <SelectValue placeholder="寄付比率を選択" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="1">1% (デフォルト)</SelectItem>
                  <SelectItem value="3">3%</SelectItem>
                  <SelectItem value="5">5%</SelectItem>
                  <SelectItem value="10">10%</SelectItem>
                </SelectContent>
              </Select>

              <div className="mt-2 flex items-center text-xs text-teal-700">
                <Info className="h-3 w-3 mr-1" />
                <span>
                  {donationPercentage}%の寄付で、1ヶ月あたり約
                  {Number(donationPercentage) * 120}円の環境保全に貢献できます
                </span>
              </div>
            </div>
          </div>
        </div>
      </Card>

      <Button
        className="w-full bg-teal-700 hover:bg-teal-800 text-white mt-6"
        onClick={handleSaveSettings}
      >
        設定を保存
      </Button>
    </div>
  );
}
</file>

<file path="src/features/settings/components/tabs/index.ts">
export { EcoTab } from "./EcoTab";
export { ProfileTab } from "./ProfileTab";
export { NotificationsTab } from "./NotificationsTab";
export { PaymentTab } from "./PaymentTab";
export { SecurityTab } from "./SecurityTab";
</file>

<file path="src/features/settings/components/tabs/NotificationsTab.tsx">
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Session } from "next-auth";
import { SettingSection } from "@/features/settings/components/SettingSection";
import { Bell, Mail, ShoppingBag, Leaf, AlertTriangle } from "lucide-react";

interface NotificationsTabProps {
  user?: Session["user"];
}

export function NotificationsTab({ user }: NotificationsTabProps) {
  return (
    <div className="space-y-4">
      {/* 通知設定セクション */}
      <SettingSection
        title="通知設定"
        icon={<Bell className="h-4 w-4 text-stone-600" />}
      >
        {/* 取引通知 */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label htmlFor="notify1" className="text-sm text-stone-800">
              <div className="flex items-center">
                <ShoppingBag className="h-4 w-4 text-stone-600 mr-2" />
                取引通知
              </div>
            </Label>
            <p className="text-xs text-stone-500 ml-6">
              入金・支払い時に通知を受け取ります
            </p>
          </div>
          <Switch id="notify1" defaultChecked />
        </div>

        {/* 環境貢献通知 */}
        <div className="flex items-center justify-between mt-3">
          <div className="space-y-0.5">
            <Label htmlFor="notify2" className="text-sm text-stone-800">
              <div className="flex items-center">
                <Leaf className="h-4 w-4 text-teal-600 mr-2" />
                環境貢献通知
              </div>
            </Label>
            <p className="text-xs text-stone-500 ml-6">
              あなたの環境貢献が特定のマイルストーンに達した際に通知します
            </p>
          </div>
          <Switch id="notify2" defaultChecked />
        </div>

        {/* キャンペーン情報 */}
        <div className="flex items-center justify-between mt-3">
          <div className="space-y-0.5">
            <Label htmlFor="notify3" className="text-sm text-stone-800">
              <div className="flex items-center">
                <Bell className="h-4 w-4 text-amber-500 mr-2" />
                キャンペーン情報
              </div>
            </Label>
            <p className="text-xs text-stone-500 ml-6">
              環境保全キャンペーンやイベントの情報を受け取ります
            </p>
          </div>
          <Switch id="notify3" defaultChecked />
        </div>

        {/* セキュリティ通知 */}
        <div className="flex items-center justify-between mt-3">
          <div className="space-y-0.5">
            <Label htmlFor="notify4" className="text-sm text-stone-800">
              <div className="flex items-center">
                <AlertTriangle className="h-4 w-4 text-red-500 mr-2" />
                セキュリティ通知
              </div>
            </Label>
            <p className="text-xs text-stone-500 ml-6">
              ログインやアカウント変更時に通知を受け取ります
            </p>
          </div>
          <Switch id="notify4" defaultChecked />
        </div>
      </SettingSection>

      <Separator />

      {/* メールアドレス設定セクション */}
      <SettingSection
        title="通知メールアドレス"
        icon={<Mail className="h-4 w-4 text-stone-600" />}
      >
        <div className="space-y-2">
          <Input
            id="notify-email"
            defaultValue={user?.email || "eco_user@example.com"}
            className="border-stone-200"
          />
          <p className="text-xs text-stone-500 mt-1">
            通知の受信に使用するメールアドレスです
          </p>
        </div>
      </SettingSection>

      <Button className="w-full bg-teal-700 hover:bg-teal-800 text-white mt-2">
        設定を保存
      </Button>
    </div>
  );
}
</file>

<file path="src/features/settings/components/tabs/PaymentTab.tsx">
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";
import { CreditCard, Wallet, RefreshCw } from "lucide-react";
import { Session } from "next-auth";
import { SettingSection } from "@/features/settings/components/SettingSection";

interface PaymentTabProps {
  user?: Session["user"];
}

export function PaymentTab({ user }: PaymentTabProps) {
  const recommendedChargeAmount =
    user?.balance && user.balance < 5000
      ? Math.max(5000, Math.ceil((user.balance * 0.5) / 1000) * 1000)
      : 5000;

  return (
    <div className="space-y-4">
      {/* 残高表示 */}
      <div className="text-xs text-stone-600 mb-2">
        {user?.name || "ユーザー"}さんの現在の残高: ¥
        {user?.balance?.toLocaleString() || "8,500"}
      </div>

      {/* 支払い方法セクション */}
      <SettingSection
        title="支払い方法"
        icon={<CreditCard className="h-4 w-4 text-stone-600" />}
      >
        <div className="space-y-3">
          {/* VISAカード */}
          <div className="border border-stone-200 rounded-md p-4 bg-white">
            <div className="flex justify-between items-center">
              <div className="flex items-center space-x-3">
                <div className="w-10 h-10 bg-blue-50 rounded-md flex items-center justify-center">
                  <CreditCard className="h-5 w-5 text-blue-500" />
                </div>
                <div>
                  <h4 className="text-sm font-medium text-stone-800">
                    VISAカード
                  </h4>
                  <p className="text-xs text-stone-500">**** **** **** 4567</p>
                </div>
              </div>
              <Badge className="bg-teal-100 text-teal-800 hover:bg-teal-200">
                デフォルト
              </Badge>
            </div>
          </div>

          {/* MASTERカード */}
          <div className="border border-stone-200 rounded-md p-4 bg-white">
            <div className="flex justify-between items-center">
              <div className="flex items-center space-x-3">
                <div className="w-10 h-10 bg-red-50 rounded-md flex items-center justify-center">
                  <CreditCard className="h-5 w-5 text-red-500" />
                </div>
                <div>
                  <h4 className="text-sm font-medium text-stone-800">
                    MASTERカード
                  </h4>
                  <p className="text-xs text-stone-500">**** **** **** 8901</p>
                </div>
              </div>
              <Button
                variant="ghost"
                size="sm"
                className="h-8 text-xs text-stone-500"
              >
                編集
              </Button>
            </div>
          </div>
        </div>

        <Button
          variant="outline"
          className="w-full text-stone-700 border-stone-200 mt-2"
        >
          新しい支払い方法を追加
        </Button>
      </SettingSection>

      <Separator />

      {/* チャージ設定セクション */}
      <SettingSection
        title="チャージ設定"
        icon={<Wallet className="h-4 w-4 text-stone-600" />}
      >
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label htmlFor="auto-charge" className="text-sm text-stone-800">
              <div className="flex items-center">
                <RefreshCw className="h-4 w-4 text-stone-600 mr-2" />
                自動チャージ
              </div>
            </Label>
            <p className="text-xs text-stone-500 ml-6">
              残高が指定額以下になると自動的にチャージされます
            </p>
          </div>
          <Switch id="auto-charge" />
        </div>

        <div className="flex space-x-3 mt-3">
          <div className="w-1/2">
            <Label htmlFor="min-balance" className="text-xs text-stone-600">
              チャージ実行残高
            </Label>
            <div className="flex items-center">
              <Input
                id="min-balance"
                defaultValue="1000"
                className="border-stone-200"
                disabled
              />
              <span className="ml-1 text-sm text-stone-600">円以下</span>
            </div>
          </div>
          <div className="w-1/2">
            <Label htmlFor="charge-amount" className="text-xs text-stone-600">
              チャージ金額
            </Label>
            <div className="flex items-center">
              <Input
                id="charge-amount"
                defaultValue={recommendedChargeAmount.toString()}
                className="border-stone-200"
                disabled
              />
              <span className="ml-1 text-sm text-stone-600">円</span>
            </div>
          </div>
        </div>
      </SettingSection>

      <Button className="w-full bg-teal-700 hover:bg-teal-800 text-white mt-2">
        設定を保存
      </Button>
    </div>
  );
}
</file>

<file path="src/features/settings/types/settings.ts">
/**
 * 設定機能の型定義
 */

/**
 * 設定のタブの種類
 */
export type SettingsTabType =
  | "profile"
  | "security"
  | "payment"
  | "notifications"
  | "eco";

/**
 * ユーザープロフィール情報
 */
export interface UserProfile {
  id: string;
  name: string;
  email: string;
  image?: string; // アバター画像URL
  avatarUrl?: string; // 互換性のためのエイリアス
  phoneNumber?: string;
  joinedDate: string;
  birthdate?: string;
  gender?: "male" | "female" | "other" | "prefer_not_to_say";
  occupation?: string;
  address?: UserAddress;
  ecoRank?: string; // エコランク（エコマイスターなど）
}

/**
 * ユーザーの住所情報
 */
export interface UserAddress {
  postalCode?: string;
  prefecture?: string;
  city?: string;
  streetAddress?: string;
  building?: string;
}

/**
 * セキュリティ設定
 */
export interface SecuritySettings {
  twoFactorEnabled: boolean;
  biometricLoginEnabled: boolean;
  lastPasswordChange?: string;
  loginNotifications: boolean;
  accountRecoveryEmail?: string;
  securityQuestions?: SecurityQuestion[];
}

/**
 * セキュリティの質問と回答
 */
export interface SecurityQuestion {
  question: string;
  answer: string; // 通常は暗号化されている
}

/**
 * 通知設定
 */
export interface NotificationSettings {
  email: boolean;
  push: boolean;
  sms: boolean;
  transactionAlerts: boolean;
  promotions: boolean;
  ecoTips: boolean;
  newsAndUpdates: boolean;
}

/**
 * 決済方法
 */
export interface PaymentMethod {
  id: string;
  type: "bank_account" | "credit_card" | "debit_card" | "e_wallet";
  name: string;
  maskedNumber: string; // 下4桁などマスクされた番号
  isDefault: boolean;
  expiryDate?: string; // カードの有効期限
  bankName?: string; // 銀行名（銀行口座の場合）
}

/**
 * エコ設定
 */
export interface EcoSettings {
  autoRounding: boolean; // 決済金額の端数を自動的に環境保全に寄付
  carbonOffsetPreference: number; // 炭素オフセットの割合（0-100%）
  monthlyDonationEnabled: boolean; // 月額寄付の有効・無効
  monthlyDonationAmount?: number; // 月額寄付金額
  preferredProjects: string[]; // お気に入りの環境プロジェクトID
}
</file>

<file path="src/features/settings/README.md">
# 設定機能（Settings Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいた設定機能を含みます。

## ディレクトリ構造

```
settings/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── PageHeader/            # ページヘッダーコンポーネント
│   ├── ProfileCard/           # プロフィールカードコンポーネント
│   ├── SettingSection/        # 設定セクションコンポーネント
│   └── SettingsTabCard/       # 設定タブカードコンポーネント (将来追加予定)
├── data/                       # データソース（将来的に追加予定）
├── hooks/                      # カスタムフック（将来的に追加予定）
├── store/                      # 状態管理（将来的に追加予定）
├── types/                      # 型定義
│   └── settings.ts             # 設定関連の型定義
├── utils/                      # ユーティリティ関数（将来的に追加予定）
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // 型定義
  UserProfile,
  SecuritySettings,
  NotificationSettings,
  PaymentMethod,
  EcoSettings,
  SettingsTabType,

  // コンポーネント
  PageHeader,
  SettingSection,
  ProfileCard,

  // プロパティ型
  SettingSectionProps,
  ProfileCardProps,
} from "@/features/settings";
```

### コンポーネント例

#### ページヘッダー

```tsx
<PageHeader />
```

#### 設定セクション

```tsx
<SettingSection title="基本情報" description="アカウントの基本情報を編集します">
  {/* 設定項目 */}
</SettingSection>
```

#### プロフィールカード

```tsx
<ProfileCard
  user={currentUser}
  ecoContribution={{
    donation: 12000,
    forestArea: 5.2,
    co2Reduction: 25,
  }}
/>
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. ユーザープロフィール情報の表示と編集
2. セキュリティ設定の管理
3. 通知設定の管理
4. 決済方法の管理
5. エコ関連設定の管理

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 認証機能: `next-auth`
- アイコン: `lucide-react`

## 拡張予定

今後、以下の機能を追加予定です：

1. 設定タブコンポーネントの移行
2. 設定状態管理のためのストア
3. 設定のバリデーション機能
4. 設定の永続化と同期機能
</file>

<file path="src/features/splash/components/BrandLogo/BrandLogo.tsx">
import React from "react";

interface BrandLogoProps {
  /** ロゴのサイズ（高さ） */
  size?: "small" | "medium" | "large";
  /** アニメーションの有効/無効 */
  animate?: boolean;
  /** カスタムクラス名 */
  className?: string;
}

/**
 * Eco Walletのブランドロゴコンポーネント
 */
export function BrandLogo({
  size = "large",
  animate = true,
  className = "",
}: BrandLogoProps) {
  const sizeClasses = {
    small: "h-16",
    medium: "h-20",
    large: "h-24",
  };

  const textSizeClasses = {
    small: "text-xl",
    medium: "text-2xl",
    large: "text-3xl",
  };

  return (
    <div
      className={`flex flex-col items-center ${animate ? "animate-pulse" : ""} ${className}`}
    >
      <svg
        viewBox="0 0 100 40"
        className={`${sizeClasses[size]} w-auto fill-white mb-4`}
      >
        <path d="M50,0 L75,20 L65,40 H35 L25,20 L50,0z" />
        <path d="M45,15 L55,15 L55,25 L45,25 L45,15z" fill="teal" />
      </svg>
      <h1 className={`${textSizeClasses[size]} font-bold text-white`}>
        Eco Wallet
      </h1>
      {size === "large" && (
        <p className="text-sm text-teal-100 mt-2">
          シンプルで環境に優しい決済サービス
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/features/splash/components/BrandLogo/index.ts">
export { BrandLogo } from "./BrandLogo";
</file>

<file path="src/features/splash/components/InitializationStatus/index.ts">
export { InitializationStatus } from "./InitializationStatus";
</file>

<file path="src/features/splash/components/InitializationStatus/InitializationStatus.tsx">
import React from "react";
import { Leaf } from "lucide-react";
import { InitializationState } from "../../types/splash";

interface InitializationStatusProps {
  /** 初期化状態 */
  state: InitializationState;
  /** エラー時の表示有無 */
  showError?: boolean;
}

/**
 * 初期化状態を表示するコンポーネント
 */
export function InitializationStatus({
  state,
  showError = true,
}: InitializationStatusProps) {
  const getStatusText = (): string => {
    if (state.error && showError) {
      return "初期化エラー";
    }
    if (state.dataLoaded) {
      return "初期化完了";
    }
    if (state.configLoaded) {
      return "データ読み込み中...";
    }
    if (state.authChecked) {
      return "設定を読み込み中...";
    }
    return "認証確認中...";
  };

  const getProgress = (): number => {
    if (state.error) return 0;
    let progress = 0;
    if (state.authChecked) progress += 33;
    if (state.configLoaded) progress += 33;
    if (state.dataLoaded) progress += 34;
    return progress;
  };

  return (
    <div className="mt-8 w-64">
      {/* プログレスバー */}
      <div className="w-full bg-teal-900 rounded-full h-1.5 mb-4">
        <div
          className="bg-teal-300 h-1.5 rounded-full transition-all duration-500 ease-out"
          style={{ width: `${getProgress()}%` }}
        />
      </div>

      {/* ステータステキスト */}
      <p className="text-teal-100 text-sm text-center">{getStatusText()}</p>

      {/* エラー詳細 */}
      {state.error && showError && (
        <div className="mt-4 p-3 bg-red-900/20 border border-red-500/30 rounded-lg">
          <p className="text-red-300 text-xs">{state.error}</p>
        </div>
      )}

      {/* エコメッセージ */}
      {!state.error && (
        <div className="absolute bottom-10 flex items-center text-teal-100 text-sm">
          <Leaf className="h-4 w-4 mr-2" />
          <span>環境と共に、持続可能な未来へ</span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/features/splash/components/SplashScreen/index.ts">
export { SplashScreen } from "./SplashScreen";
</file>

<file path="src/features/splash/components/SplashScreen/SplashScreen.tsx">
"use client";

import React from "react";
import { BrandLogo } from "../BrandLogo";
import { InitializationStatus } from "../InitializationStatus";
import { useSplashScreen } from "../../hooks/useSplashScreen";
import { SplashScreenProps } from "../../types/splash";

/**
 * スプラッシュ画面のメインコンポーネント
 */
export function SplashScreen({ config, onComplete }: SplashScreenProps) {
  const { status, initializationState, isAnimationEnabled } =
    useSplashScreen(config);

  // 初期化完了時のコールバック
  React.useEffect(() => {
    if (status === "completed" && onComplete) {
      onComplete();
    }
  }, [status, onComplete]);

  return (
    <div className="min-h-screen bg-teal-800 flex flex-col items-center justify-center">
      <BrandLogo size="large" animate={isAnimationEnabled} />

      <InitializationStatus
        state={initializationState}
        showError={status === "error"}
      />
    </div>
  );
}
</file>

<file path="src/features/splash/hooks/index.ts">
export { useSplashScreen } from "./useSplashScreen";
</file>

<file path="src/features/splash/hooks/useSplashScreen.ts">
"use client";

import { useEffect, useState, useMemo } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  SplashStatus,
  SplashConfig,
  DEFAULT_SPLASH_CONFIG,
  InitializationState,
} from "../types/splash";
import {
  initializeApp,
  calculateRemainingDelay,
  determineRedirectPath,
} from "../utils/initialization";

/**
 * スプラッシュ画面の制御を行うカスタムフック
 * @param config スプラッシュ画面の設定
 * @returns スプラッシュ画面の状態と制御関数
 */
export function useSplashScreen(config?: Partial<SplashConfig>) {
  const router = useRouter();
  const { status } = useSession();
  const [splashStatus, setSplashStatus] = useState<SplashStatus>("loading");
  const [initState, setInitState] = useState<InitializationState>({
    authChecked: false,
    configLoaded: false,
    dataLoaded: false,
  });

  const mergedConfig = useMemo(
    () => ({ ...DEFAULT_SPLASH_CONFIG, ...config }),
    [config],
  );
  const isAuthenticated = status === "authenticated";

  useEffect(() => {
    const startTime = Date.now();

    const initialize = async () => {
      try {
        // アプリケーションの初期化
        const state = await initializeApp();
        setInitState(state);

        if (state.error) {
          setSplashStatus("error");
          return;
        }

        // 最小表示時間を考慮した遅延
        const remainingDelay = calculateRemainingDelay(
          startTime,
          mergedConfig.minimumDisplayTime,
        );
        await new Promise((resolve) => setTimeout(resolve, remainingDelay));

        // 表示時間の遅延
        const displayDelay = Math.max(
          0,
          mergedConfig.displayDuration - (Date.now() - startTime),
        );
        await new Promise((resolve) => setTimeout(resolve, displayDelay));

        setSplashStatus("completed");

        // リダイレクト処理
        const redirectPath = determineRedirectPath(isAuthenticated);
        router.push(redirectPath);
      } catch (error) {
        console.error("Splash screen initialization error:", error);
        setSplashStatus("error");
      }
    };

    // 認証状態が確定してから初期化を開始
    if (status !== "loading") {
      initialize();
    }
  }, [status, isAuthenticated, router, mergedConfig]);

  return {
    status: splashStatus,
    initializationState: initState,
    isAnimationEnabled: mergedConfig.enableAnimation,
  };
}
</file>

<file path="src/features/splash/types/splash.ts">
/**
 * スプラッシュ画面の表示状態
 */
export type SplashStatus = "loading" | "completed" | "error";

/**
 * スプラッシュ画面の設定
 */
export interface SplashConfig {
  /** 表示時間（ミリ秒） */
  displayDuration: number;
  /** 最小表示時間（ミリ秒） */
  minimumDisplayTime: number;
  /** アニメーションの有効/無効 */
  enableAnimation: boolean;
}

/**
 * 初期化状態
 */
export interface InitializationState {
  /** 認証チェック完了 */
  authChecked: boolean;
  /** アプリ設定の読み込み完了 */
  configLoaded: boolean;
  /** 必要なデータの読み込み完了 */
  dataLoaded: boolean;
  /** エラー情報 */
  error?: string;
}

/**
 * スプラッシュ画面のプロパティ
 */
export interface SplashScreenProps {
  /** カスタム設定 */
  config?: Partial<SplashConfig>;
  /** 初期化完了時のコールバック */
  onComplete?: () => void;
}

/**
 * デフォルトのスプラッシュ設定
 */
export const DEFAULT_SPLASH_CONFIG: SplashConfig = {
  displayDuration: 2000,
  minimumDisplayTime: 1000,
  enableAnimation: true,
};
</file>

<file path="src/features/splash/utils/initialization.ts">
import { InitializationState } from "../types/splash";

/**
 * アプリケーションの初期化を行う
 * @returns 初期化の結果
 */
export async function initializeApp(): Promise<InitializationState> {
  const state: InitializationState = {
    authChecked: false,
    configLoaded: false,
    dataLoaded: false,
  };

  try {
    // 認証状態のチェック（NextAuthのセッション確認はコンポーネント側で行う）
    state.authChecked = true;

    // アプリ設定の読み込み
    await loadAppConfiguration();
    state.configLoaded = true;

    // 必要なデータの読み込み
    await loadInitialData();
    state.dataLoaded = true;

    return state;
  } catch (error) {
    return {
      ...state,
      error:
        error instanceof Error
          ? error.message
          : "初期化中にエラーが発生しました",
    };
  }
}

/**
 * アプリ設定を読み込む
 */
async function loadAppConfiguration(): Promise<void> {
  // 実際の実装では、APIからの設定取得やローカルストレージからの読み込みなどを行う
  // 現在はモックとして遅延を入れる
  await new Promise((resolve) => setTimeout(resolve, 200));
}

/**
 * 初期データを読み込む
 */
async function loadInitialData(): Promise<void> {
  // 実際の実装では、キャッシュデータの読み込みや初期APIコールなどを行う
  // 現在はモックとして遅延を入れる
  await new Promise((resolve) => setTimeout(resolve, 300));
}

/**
 * 最小表示時間を考慮した遅延を計算する
 * @param startTime 開始時刻
 * @param minimumTime 最小表示時間（ミリ秒）
 * @returns 追加で待機すべき時間（ミリ秒）
 */
export function calculateRemainingDelay(
  startTime: number,
  minimumTime: number,
): number {
  const elapsed = Date.now() - startTime;
  return Math.max(0, minimumTime - elapsed);
}

/**
 * リダイレクト先のパスを決定する
 * @param isAuthenticated ユーザーが認証済みか
 * @param intendedPath 意図されたパス（オプション）
 * @returns リダイレクト先のパス
 */
export function determineRedirectPath(
  isAuthenticated: boolean,
  intendedPath?: string,
): string {
  if (isAuthenticated) {
    return intendedPath || "/";
  }
  return "/auth/login";
}
</file>

<file path="src/features/splash/index.ts">
// コンポーネント
export { SplashScreen } from "./components/SplashScreen";
export { BrandLogo } from "./components/BrandLogo";
export { InitializationStatus } from "./components/InitializationStatus";

// フック
export { useSplashScreen } from "./hooks";

// 型定義
export type {
  SplashStatus,
  SplashConfig,
  InitializationState,
  SplashScreenProps,
} from "./types/splash";

// 定数
export { DEFAULT_SPLASH_CONFIG } from "./types/splash";

// ユーティリティ関数
export {
  initializeApp,
  calculateRemainingDelay,
  determineRedirectPath,
} from "./utils/initialization";
</file>

<file path="src/features/splash/README.md">
# Splash Feature Module

スプラッシュ画面機能を提供するfeatureモジュールです。アプリケーション起動時の初期化処理とブランディング表示を担当します。

## 概要

このモジュールは以下の機能を提供します：

- アプリケーション起動時のスプラッシュ画面表示
- 認証状態のチェックと適切なリダイレクト
- 初期化処理の進行状況表示
- ブランドロゴとアニメーション

## ディレクトリ構造

```
features/splash/
├── components/
│   ├── BrandLogo/          # ブランドロゴ表示
│   ├── InitializationStatus/ # 初期化状態表示
│   └── SplashScreen/       # メインスプラッシュ画面
├── hooks/
│   └── useSplashScreen.ts  # スプラッシュ画面制御フック
├── types/
│   └── splash.ts           # 型定義
├── utils/
│   └── initialization.ts   # 初期化ユーティリティ
├── README.md              # このファイル
└── index.ts               # パブリックAPI
```

## 使用方法

### 基本的な使用

```tsx
import { SplashScreen } from "@/features/splash";

export default function SplashPage() {
  return <SplashScreen />;
}
```

### カスタム設定での使用

```tsx
import { SplashScreen } from "@/features/splash";

export default function SplashPage() {
  const config = {
    displayDuration: 3000, // 3秒表示
    minimumDisplayTime: 1500, // 最小1.5秒表示
    enableAnimation: true, // アニメーション有効
  };

  const handleComplete = () => {
    console.log("Splash screen completed");
  };

  return <SplashScreen config={config} onComplete={handleComplete} />;
}
```

## コンポーネント

### SplashScreen

メインのスプラッシュ画面コンポーネント。

**Props:**

- `config?: Partial<SplashConfig>` - スプラッシュ画面の設定
- `onComplete?: () => void` - 初期化完了時のコールバック

### BrandLogo

Eco Walletのブランドロゴコンポーネント。

**Props:**

- `size?: 'small' | 'medium' | 'large'` - ロゴのサイズ
- `animate?: boolean` - アニメーションの有効/無効
- `className?: string` - カスタムクラス名

### InitializationStatus

初期化状態を表示するコンポーネント。

**Props:**

- `state: InitializationState` - 初期化状態
- `showError?: boolean` - エラー表示の有無

## フック

### useSplashScreen

スプラッシュ画面の制御を行うカスタムフック。

```tsx
const { status, initializationState, isAnimationEnabled } =
  useSplashScreen(config);
```

**戻り値:**

- `status: SplashStatus` - スプラッシュ画面の状態
- `initializationState: InitializationState` - 初期化の詳細状態
- `isAnimationEnabled: boolean` - アニメーションの有効状態

## 型定義

### SplashConfig

```typescript
interface SplashConfig {
  displayDuration: number; // 表示時間（ミリ秒）
  minimumDisplayTime: number; // 最小表示時間（ミリ秒）
  enableAnimation: boolean; // アニメーションの有効/無効
}
```

### InitializationState

```typescript
interface InitializationState {
  authChecked: boolean; // 認証チェック完了
  configLoaded: boolean; // アプリ設定の読み込み完了
  dataLoaded: boolean; // 必要なデータの読み込み完了
  error?: string; // エラー情報
}
```

## 初期化フロー

1. **認証状態の確認** - NextAuthのセッション状態を確認
2. **アプリ設定の読み込み** - 必要な設定を読み込み
3. **初期データの読み込み** - キャッシュデータなどを読み込み
4. **リダイレクト処理** - 認証状態に基づいて適切な画面へ遷移

## カスタマイズ

### 初期化処理の拡張

`utils/initialization.ts`の`initializeApp`関数を修正して、独自の初期化処理を追加できます：

```typescript
// 例：APIからの初期データ取得
async function loadInitialData(): Promise<void> {
  const response = await fetch("/api/initial-data");
  const data = await response.json();
  // データの処理
}
```

### スタイルのカスタマイズ

各コンポーネントはTailwind CSSクラスを使用しています。必要に応じてクラスを調整してください。

## 注意事項

- スプラッシュ画面は最小表示時間を設定することで、高速な初期化時でも適切なブランディング表示を確保します
- エラー発生時は自動的にエラー表示モードに切り替わります
- 認証状態に基づいて自動的にリダイレクト処理を行います
</file>

<file path="src/features/transactions/components/RecentTransactions/index.ts">
export { default as RecentTransactionsContainer } from "./RecentTransactionsContainer";
export { default as RecentTransactionsList } from "./RecentTransactionsList";
</file>

<file path="src/features/transactions/components/RecentTransactions/RecentTransactionsList.tsx">
"use client";

import React from "react";
import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TransactionItem } from "../TransactionItem";
import { StyledTransaction } from "../TransactionItem";

interface RecentTransactionsListProps {
  transactions: StyledTransaction[];
  showHeader?: boolean;
}

// プレゼンテーションコンポーネント：スタイリング済みトランザクションの表示のみを担当
const RecentTransactionsList = React.memo(
  ({ transactions, showHeader = true }: RecentTransactionsListProps) => {
    return (
      <div>
        {showHeader && (
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-medium text-stone-800">最近の取引</h3>
            <Link href="/history">
              <Button
                variant="ghost"
                size="sm"
                className="h-7 text-xs text-stone-500"
              >
                すべて見る
              </Button>
            </Link>
          </div>
        )}

        <Card className="border-0 shadow-md bg-white divide-y divide-stone-100">
          {transactions.length > 0 ? (
            transactions.map((item) => (
              <TransactionItem key={item.transaction.id} item={item} />
            ))
          ) : (
            <div className="p-4 text-center text-stone-500 text-sm">
              取引履歴がありません
            </div>
          )}
        </Card>
      </div>
    );
  },
);

RecentTransactionsList.displayName = "RecentTransactionsList";

export default RecentTransactionsList;
</file>

<file path="src/features/transactions/components/TransactionDetail/ActionButtons.tsx">
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { Receipt, Share2 } from "lucide-react";

interface ActionButtonsProps {
  onShowReceipt: () => void;
  onShare: () => void;
}

export const ActionButtons = React.memo(
  ({ onShowReceipt, onShare }: ActionButtonsProps) => {
    return (
      <div className="flex flex-col space-y-2 mt-5 mb-2">
        <Button
          variant="outline"
          size="sm"
          className="w-full flex justify-center items-center border-stone-200 hover:border-stone-300 hover:bg-stone-50"
          onClick={onShowReceipt}
        >
          <Receipt className="h-4 w-4 mr-1.5 text-stone-600" />
          <span>電子レシートを表示</span>
        </Button>

        <Button
          variant="outline"
          size="sm"
          className="w-full flex justify-center items-center border-stone-200 hover:border-stone-300 hover:bg-stone-50"
          onClick={onShare}
        >
          <Share2 className="h-4 w-4 mr-1.5 text-stone-600" />
          <span>この取引を共有</span>
        </Button>
      </div>
    );
  },
);

ActionButtons.displayName = "ActionButtons";
</file>

<file path="src/features/transactions/components/TransactionDetail/index.ts">
export { TransactionDetailContainer } from "./TransactionDetailContainer";
export { TransactionDetailView } from "./TransactionDetailView";
export { TransactionHeader } from "./TransactionHeader";
export { TransactionInfo } from "./TransactionInfo";
export { TransactionEcoInfo } from "./TransactionEcoInfo";
export { ActionButtons } from "./ActionButtons";
export { ReceiptDialog } from "./ReceiptDialog";
</file>

<file path="src/features/transactions/components/TransactionDetail/TransactionEcoInfo.tsx">
"use client";

import React from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Leaf, Trees, Info } from "lucide-react";

interface TransactionEcoInfoProps {
  forestArea: number;
  co2Reduction: number;
  onViewDetails: () => void;
}

export const TransactionEcoInfo = React.memo(
  ({ forestArea, co2Reduction, onViewDetails }: TransactionEcoInfoProps) => {
    return (
      <Card className="border-0 shadow-md bg-gradient-to-br from-emerald-50 to-teal-50 overflow-hidden mt-4">
        <div className="p-5">
          <div className="flex items-center mb-3">
            <Leaf className="text-emerald-600 mr-2 h-5 w-5" />
            <h3 className="text-base font-medium text-emerald-800">環境貢献</h3>
          </div>

          <div className="grid grid-cols-2 gap-4 mb-4">
            <div className="bg-white rounded-lg p-3 shadow-sm">
              <div className="text-xs text-stone-600 mb-1">森林保全面積</div>
              <div className="flex items-center">
                <Trees className="h-4 w-4 text-emerald-600 mr-1" />
                <span className="text-lg font-bold text-emerald-700">
                  {forestArea.toFixed(2)}m²
                </span>
              </div>
            </div>
            <div className="bg-white rounded-lg p-3 shadow-sm">
              <div className="text-xs text-stone-600 mb-1">CO₂削減量</div>
              <div className="flex items-center">
                <Leaf className="h-4 w-4 text-emerald-600 mr-1" />
                <span className="text-lg font-bold text-emerald-700">
                  {co2Reduction.toFixed(2)}kg
                </span>
              </div>
            </div>
          </div>

          <Button
            variant="ghost"
            size="sm"
            className="w-full justify-center border border-emerald-200 bg-white hover:bg-emerald-50"
            onClick={onViewDetails}
          >
            <Info className="h-4 w-4 mr-1 text-emerald-600" />
            <span className="text-emerald-700">環境貢献詳細を見る</span>
          </Button>
        </div>
      </Card>
    );
  },
);

TransactionEcoInfo.displayName = "TransactionEcoInfo";
</file>

<file path="src/features/transactions/components/TransactionDetail/TransactionHeader.tsx">
"use client";

import React from "react";
import { ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { TransactionStyle } from "@/features/transactions";

interface TransactionHeaderProps {
  description: string;
  date: string;
  badges?: string[];
  ecoEnabled?: boolean;
  style?: TransactionStyle;
  onBack: () => void;
}

export const TransactionHeader = React.memo(
  ({
    description,
    date,
    badges = [],
    ecoEnabled = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    style,
    onBack,
  }: TransactionHeaderProps) => {
    return (
      <div className="mb-4">
        <Button
          variant="ghost"
          size="sm"
          className="pl-0 mb-3 text-stone-600"
          onClick={onBack}
        >
          <ArrowLeft className="mr-1 h-4 w-4" />
          履歴に戻る
        </Button>

        <div className="flex justify-between">
          <h1 className="text-xl font-bold text-stone-800 mb-1 truncate">
            {description}
          </h1>
        </div>

        <div className="flex items-center text-sm text-stone-600 mb-2">
          <span>{date}</span>
        </div>

        <div className="flex flex-wrap gap-1">
          {badges.map((badge) => (
            <Badge
              key={badge}
              variant="outline"
              className={`text-xs font-medium ${
                badge === "環境貢献" && ecoEnabled
                  ? "border-emerald-200 bg-emerald-50 text-emerald-800"
                  : "border-stone-200 bg-stone-50"
              }`}
            >
              {badge}
            </Badge>
          ))}
        </div>
      </div>
    );
  },
);

TransactionHeader.displayName = "TransactionHeader";
</file>

<file path="src/features/transactions/components/TransactionDetailSection/index.ts">
export { TransactionDetailSection } from "./TransactionDetailSection";
</file>

<file path="src/features/transactions/components/TransactionDetailSection/TransactionDetailSection.tsx">
import { ReactNode } from "react";

interface TransactionDetailSectionProps {
  title: string;
  icon?: ReactNode;
  children: ReactNode;
  className?: string;
}

export function TransactionDetailSection({
  title,
  icon,
  children,
  className = "",
}: TransactionDetailSectionProps) {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center space-x-2">
        {icon}
        <h3 className="text-sm font-medium text-stone-700">{title}</h3>
      </div>
      {children}
    </div>
  );
}
</file>

<file path="src/features/transactions/components/TransactionFilters/index.ts">
export { TransactionFilters } from "./TransactionFilters";
</file>

<file path="src/features/transactions/components/TransactionItem/index.ts">
export { default as TransactionItem } from "./TransactionItem";
export type { StyledTransaction } from "./TransactionItem";
</file>

<file path="src/features/transactions/components/TransactionList/index.ts">
export { TransactionList } from "./TransactionList";
</file>

<file path="src/features/transactions/hooks/transactionStyling.tsx">
import React from "react";
import {
  ArrowDown,
  ArrowUp,
  CircleDollarSign,
  HeartHandshake,
  Clock,
} from "lucide-react";
import { TransactionType } from "@/shared/types/transaction";

// トランザクションスタイルの型定義
export interface TransactionStyle {
  bgColor: string;
  textColor: string;
  borderColor: string;
  iconType: string;
  icon: React.ReactNode;
}

/**
 * トランザクションのタイプとバッジに基づいてスタイルを生成する関数
 */
export function getTransactionStyle(
  type: TransactionType,
  badges: string[] = [],
): TransactionStyle {
  // トランザクションタイプに応じたスタイルを設定
  switch (type) {
    case "payment":
      return {
        bgColor: "bg-stone-100",
        textColor: "text-stone-600",
        borderColor: "border-stone-200",
        iconType: "payment",
        icon: <ArrowUp className="h-5 w-5 text-stone-600" />,
      };
    case "charge":
      return {
        bgColor: "bg-green-100",
        textColor: "text-green-600",
        borderColor: "border-green-200",
        iconType: "charge",
        icon: <CircleDollarSign className="h-5 w-5 text-green-600" />,
      };
    case "receive":
      // 特典バッジがある場合は特別なスタイル
      if (badges.includes("特典")) {
        return {
          bgColor: "bg-amber-100",
          textColor: "text-amber-600",
          borderColor: "border-amber-200",
          iconType: "bonus",
          icon: <ArrowDown className="h-5 w-5 text-amber-600" />,
        };
      }
      return {
        bgColor: "bg-sky-100",
        textColor: "text-sky-600",
        borderColor: "border-sky-200",
        iconType: "receive",
        icon: <ArrowDown className="h-5 w-5 text-sky-600" />,
      };
    case "donation":
      return {
        bgColor: "bg-teal-100",
        textColor: "text-teal-600",
        borderColor: "border-teal-200",
        iconType: "donation",
        icon: <HeartHandshake className="h-5 w-5 text-teal-600" />,
      };
    case "expired":
      return {
        bgColor: "bg-red-100",
        textColor: "text-red-600",
        borderColor: "border-red-200",
        iconType: "expired",
        icon: <Clock className="h-5 w-5 text-red-600" />,
      };
    default:
      // デフォルトスタイル
      return {
        bgColor: "bg-stone-100",
        textColor: "text-stone-600",
        borderColor: "border-stone-200",
        iconType: "default",
        icon: <CircleDollarSign className="h-5 w-5 text-stone-600" />,
      };
  }
}
</file>

<file path="src/features/transactions/types/receipt.ts">
/**
 * レシートの項目の型定義
 */
export interface ReceiptItem {
  name: string;
  quantity: number;
  price: number;
  isEco: boolean;
}

/**
 * レシートの環境貢献効果の型定義
 */
export interface ReceiptSavings {
  paperSaved: string;
  co2Reduction: string;
}
</file>

<file path="src/features/transfer/components/RecipientSelector/RecipientSelector.tsx">
import React from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { UserPlus } from "lucide-react";
import { Recipient } from "../../types/transfer";

interface RecipientSelectorProps {
  recipients: Recipient[];
  selectedRecipient: Recipient | null;
  onSelectRecipient: (recipient: Recipient) => void;
  onAddRecipient?: () => void;
}

export const RecipientSelector: React.FC<RecipientSelectorProps> = ({
  recipients,
  selectedRecipient,
  onSelectRecipient,
  onAddRecipient,
}) => {
  return (
    <div className="bg-stone-50 rounded-md p-3">
      <p className="text-xs text-stone-500 mb-2">最近の送金先</p>
      <div className="flex space-x-2 overflow-x-auto pb-1">
        {recipients.map((recipient) => (
          <div
            key={recipient.id}
            className="flex-shrink-0 flex flex-col items-center space-y-1 cursor-pointer"
            onClick={() => onSelectRecipient(recipient)}
          >
            <Avatar
              className={`h-12 w-12 border ${
                selectedRecipient?.id === recipient.id
                  ? "border-teal-500"
                  : "border-stone-200"
              }`}
            >
              <AvatarImage src={recipient.avatar} alt={recipient.name} />
              <AvatarFallback
                className={`bg-${recipient.color}-100 text-${recipient.color}-800`}
              >
                {recipient.name.slice(0, 2)}
              </AvatarFallback>
            </Avatar>
            <span className="text-xs">{recipient.name}</span>
          </div>
        ))}
        {onAddRecipient && (
          <div
            className="flex-shrink-0 flex flex-col items-center space-y-1 cursor-pointer"
            onClick={onAddRecipient}
          >
            <div className="h-12 w-12 rounded-full border border-dashed border-stone-300 flex items-center justify-center bg-white hover:bg-stone-50 transition-colors">
              <UserPlus className="h-5 w-5 text-stone-400" />
            </div>
            <span className="text-xs">追加</span>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/features/transfer/components/RecipientSelector/RecipientSelectorModal.tsx">
"use client";

import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { RecipientSelector } from "./RecipientSelector";
import { Recipient } from "../../types/transfer";
import { recentRecipients } from "../../data/recipients-data";

interface RecipientSelectorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectRecipient: (recipient: Recipient) => void;
}

export const RecipientSelectorModal: React.FC<RecipientSelectorModalProps> = ({
  isOpen,
  onClose,
  onSelectRecipient,
}) => {
  const [selectedRecipient, setSelectedRecipient] = useState<Recipient | null>(
    null,
  );

  const handleSelectRecipient = (recipient: Recipient) => {
    setSelectedRecipient(recipient);
    onSelectRecipient(recipient);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>受取人を選択</DialogTitle>
        </DialogHeader>
        <div className="mt-4">
          <RecipientSelector
            recipients={recentRecipients}
            selectedRecipient={selectedRecipient}
            onSelectRecipient={handleSelectRecipient}
          />
        </div>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/features/transfer/components/SplitForm/index.ts">
export { SplitForm } from "./SplitForm";
</file>

<file path="src/features/transfer/components/SplitHistoryList/index.ts">
export { SplitHistoryList } from "./SplitHistoryList";
</file>

<file path="src/features/transfer/components/SplitHistoryList/SplitHistoryList.tsx">
"use client";

import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  ChevronRight,
  Search,
  CalendarDays,
  Users,
  ArrowUp,
  ArrowDown,
} from "lucide-react";
import {
  useSplitHistory,
  StatusFilter,
  SortType,
} from "../../hooks/useSplitHistory";
import { splitHistories } from "../../data/split-histories-data";
import { format } from "date-fns";
import { ja } from "date-fns/locale";
import Link from "next/link";

export const SplitHistoryList = () => {
  const {
    filteredHistories,
    statusFilter,
    setStatusFilter,
    sortType,
    setSortType,
    sortOrder,
    setSortOrder,
    searchQuery,
    setSearchQuery,
    statusCounts,
  } = useSplitHistory({ histories: splitHistories });

  const [isSearchVisible, setIsSearchVisible] = useState(false);

  const toggleSortOrder = () => {
    setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
  };

  const getStatusBadgeVariant = (status: string) => {
    switch (status) {
      case "completed":
        return "default";
      case "pending":
        return "secondary";
      case "cancelled":
        return "outline";
      default:
        return "default";
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case "completed":
        return "完了";
      case "pending":
        return "保留中";
      case "cancelled":
        return "キャンセル";
      default:
        return status;
    }
  };

  return (
    <div className="space-y-4">
      {/* ヘッダー */}
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">割り勘履歴</h2>
        <Button
          variant="ghost"
          size="icon"
          onClick={() => setIsSearchVisible(!isSearchVisible)}
          className="text-teal-600"
        >
          <Search className="h-5 w-5" />
        </Button>
      </div>

      {/* 検索バー */}
      {isSearchVisible && (
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-stone-400" />
          <Input
            type="text"
            placeholder="タイトルで検索..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
      )}

      {/* フィルタータブ */}
      <Tabs
        value={statusFilter}
        onValueChange={(value) => setStatusFilter(value as StatusFilter)}
      >
        <TabsList className="grid w-full grid-cols-4">
          <TabsTrigger value="all">すべて ({statusCounts.all})</TabsTrigger>
          <TabsTrigger value="completed">
            完了 ({statusCounts.completed})
          </TabsTrigger>
          <TabsTrigger value="pending">
            保留中 ({statusCounts.pending})
          </TabsTrigger>
          <TabsTrigger value="cancelled">
            キャンセル ({statusCounts.cancelled})
          </TabsTrigger>
        </TabsList>
      </Tabs>

      {/* ソート */}
      <div className="flex items-center gap-2">
        <Select
          value={sortType}
          onValueChange={(value) => setSortType(value as SortType)}
        >
          <SelectTrigger className="w-[120px]">
            <SelectValue placeholder="並び替え" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="date">日付</SelectItem>
            <SelectItem value="amount">金額</SelectItem>
            <SelectItem value="participants">人数</SelectItem>
          </SelectContent>
        </Select>
        <Button
          variant="ghost"
          size="icon"
          onClick={toggleSortOrder}
          className="text-teal-600"
        >
          {sortOrder === "asc" ? (
            <ArrowUp className="h-4 w-4" />
          ) : (
            <ArrowDown className="h-4 w-4" />
          )}
        </Button>
      </div>

      {/* 履歴リスト */}
      <div className="space-y-3">
        {filteredHistories.length === 0 ? (
          <Card className="p-8 text-center">
            <p className="text-stone-500">履歴が見つかりません</p>
          </Card>
        ) : (
          filteredHistories.map((history) => (
            <Link key={history.id} href={`/transfer/split/${history.id}`}>
              <Card className="cursor-pointer transition-colors hover:bg-stone-50">
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex-1 space-y-1">
                      <div className="flex items-center gap-2">
                        <h3 className="font-semibold">{history.title}</h3>
                        <Badge variant={getStatusBadgeVariant(history.status)}>
                          {getStatusLabel(history.status)}
                        </Badge>
                      </div>
                      <div className="flex items-center gap-4 text-sm text-stone-600">
                        <div className="flex items-center gap-1">
                          <CalendarDays className="h-3 w-3" />
                          <span>
                            {format(new Date(history.date), "yyyy年MM月dd日", {
                              locale: ja,
                            })}
                          </span>
                        </div>
                        <div className="flex items-center gap-1">
                          <Users className="h-3 w-3" />
                          <span>{history.participantCount}人</span>
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="text-lg font-semibold">
                        ¥{history.amount.toLocaleString()}
                      </span>
                      <ChevronRight className="h-5 w-5 text-stone-400" />
                    </div>
                  </div>
                </CardContent>
              </Card>
            </Link>
          ))
        )}
      </div>

      {/* 統計情報 */}
      {filteredHistories.length > 0 && (
        <Card className="mt-6">
          <CardHeader>
            <CardTitle className="text-base">統計情報</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div>
                <p className="text-stone-600">合計金額</p>
                <p className="text-lg font-semibold">
                  ¥
                  {filteredHistories
                    .reduce((sum, h) => sum + h.amount, 0)
                    .toLocaleString()}
                </p>
              </div>
              <div>
                <p className="text-stone-600">平均金額</p>
                <p className="text-lg font-semibold">
                  ¥
                  {Math.round(
                    filteredHistories.reduce((sum, h) => sum + h.amount, 0) /
                      filteredHistories.length,
                  ).toLocaleString()}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
</file>

<file path="src/features/transfer/components/SuccessMessage/index.ts">
export { SuccessMessage } from "./SuccessMessage";
</file>

<file path="src/features/transfer/components/TransferForm/index.ts">
export { TransferForm } from "./TransferForm";
</file>

<file path="src/features/transfer/components/TransferSplitPage/index.ts">
export { TransferSplitPage } from "./TransferSplitPage";
</file>

<file path="src/features/transfer/components/TransferSplitPage/TransferSplitPage.tsx">
"use client";

import React, { useState } from "react";
import { ArrowLeftRight, Split } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card } from "@/components/ui/card";
import { TransferForm } from "../TransferForm";
import { SplitForm } from "../SplitForm";
import { SplitHistoryList } from "../SplitHistoryList";

export const TransferSplitPage = () => {
  const [activeTab, setActiveTab] = useState<"transfer" | "split">("transfer");

  return (
    <div className="min-h-screen pb-20">
      {/* ページヘッダー */}
      <div className="bg-teal-600 text-white p-6">
        <h1 className="text-2xl font-bold mb-2">送金・割り勘</h1>
        <p className="text-sm opacity-90">
          友達に送金したり、割り勘の管理ができます
        </p>
      </div>

      {/* タブ切り替え */}
      <div className="container mx-auto px-4 py-6 max-w-2xl">
        <Tabs
          value={activeTab}
          onValueChange={(value) => setActiveTab(value as "transfer" | "split")}
          className="space-y-6"
        >
          <TabsList className="grid w-full grid-cols-2 h-14">
            <TabsTrigger
              value="transfer"
              className="flex items-center gap-2 text-base font-medium data-[state=active]:bg-teal-600 data-[state=active]:text-white"
            >
              <ArrowLeftRight className="w-5 h-5" />
              送金
            </TabsTrigger>
            <TabsTrigger
              value="split"
              className="flex items-center gap-2 text-base font-medium data-[state=active]:bg-teal-600 data-[state=active]:text-white"
            >
              <Split className="w-5 h-5" />
              割り勘
            </TabsTrigger>
          </TabsList>

          {/* 送金タブ */}
          <TabsContent value="transfer" className="space-y-6">
            <Card className="p-6">
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-stone-800">
                  送金する
                </h2>
                <p className="text-sm text-stone-600 mt-1">
                  送金先と金額を入力してください
                </p>
              </div>
              <TransferForm />
            </Card>
          </TabsContent>

          {/* 割り勘タブ */}
          <TabsContent value="split" className="space-y-6">
            {/* 割り勘作成フォーム */}
            <Card className="p-6">
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-stone-800">
                  割り勘を作成
                </h2>
                <p className="text-sm text-stone-600 mt-1">
                  割り勘の詳細を入力してください
                </p>
              </div>
              <SplitForm />
            </Card>

            {/* 割り勘履歴 */}
            <div>
              <h2 className="text-xl font-semibold text-stone-800 mb-4">
                割り勘履歴
              </h2>
              <SplitHistoryList />
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
};
</file>

<file path="src/features/transfer/data/recipients-data.ts">
import { Recipient, SplitHistory } from "../types/transfer";

// 受取人のモックデータ
export const recentRecipients: Recipient[] = [
  {
    id: "rec1",
    name: "田中",
    avatar: "/api/placeholder/32/32",
    color: "blue",
    isEcoUser: true,
  },
  {
    id: "rec2",
    name: "佐藤",
    avatar: "/api/placeholder/32/32",
    color: "green",
    isEcoUser: true,
  },
  {
    id: "rec3",
    name: "鈴木",
    avatar: "/api/placeholder/32/32",
    color: "purple",
    isEcoUser: false,
  },
  {
    id: "rec4",
    name: "高橋",
    avatar: "/api/placeholder/32/32",
    color: "amber",
    isEcoUser: true,
  },
];

// 過去の割り勘履歴のモックデータ
export const splitHistories: SplitHistory[] = [
  {
    id: "split-camp-123",
    title: "キャンプ用品費用",
    date: "2025/04/10",
    participantCount: 3,
    amount: 18600,
    status: "completed",
  },
  {
    id: "split-fuji-456",
    title: "富士山登山費用",
    date: "2025/03/15",
    participantCount: 4,
    amount: 24000,
    status: "pending",
  },
];

// デフォルトの参加者データ
export const defaultParticipants = [
  {
    id: "self",
    name: "あなた（山田太郎）",
    isPayor: true,
    amount: "",
    email: "",
  },
  {
    id: "p1",
    name: "田中 花子",
    isEcoUser: true,
    amount: "",
    email: "tanaka@example.com",
  },
  {
    id: "p2",
    name: "佐藤 健太",
    isEcoUser: false,
    amount: "",
    email: "",
  },
];
</file>

<file path="src/features/transfer/data/split-histories-data.ts">
import { SplitHistory } from "../types/transfer";

export const splitHistories: SplitHistory[] = [
  {
    id: "1",
    title: "チームランチ会",
    date: "2024-04-15T12:30:00Z",
    participantCount: 5,
    amount: 12500,
    status: "completed",
  },
  {
    id: "2",
    title: "歓迎会の費用",
    date: "2024-04-10T19:00:00Z",
    participantCount: 8,
    amount: 32000,
    status: "completed",
  },
  {
    id: "3",
    title: "週末BBQ",
    date: "2024-04-20T10:00:00Z",
    participantCount: 6,
    amount: 18000,
    status: "pending",
  },
  {
    id: "4",
    title: "誕生日プレゼント代",
    date: "2024-03-28T15:00:00Z",
    participantCount: 4,
    amount: 8000,
    status: "completed",
  },
  {
    id: "5",
    title: "映画チケット代",
    date: "2024-04-18T20:00:00Z",
    participantCount: 3,
    amount: 5400,
    status: "cancelled",
  },
  {
    id: "6",
    title: "カラオケ代",
    date: "2024-04-12T21:00:00Z",
    participantCount: 7,
    amount: 14000,
    status: "completed",
  },
  {
    id: "7",
    title: "花見の買い出し",
    date: "2024-04-01T11:00:00Z",
    participantCount: 10,
    amount: 25000,
    status: "completed",
  },
  {
    id: "8",
    title: "タクシー代",
    date: "2024-04-22T23:30:00Z",
    participantCount: 4,
    amount: 3200,
    status: "pending",
  },
  {
    id: "9",
    title: "送別会",
    date: "2024-03-25T19:00:00Z",
    participantCount: 15,
    amount: 45000,
    status: "completed",
  },
  {
    id: "10",
    title: "コンサートチケット",
    date: "2024-04-05T18:00:00Z",
    participantCount: 2,
    amount: 16000,
    status: "cancelled",
  },
];
</file>

<file path="src/features/transfer/types/transfer.ts">
// 送金・割り勘関連の型定義

export interface Recipient {
  id: string;
  name: string;
  avatar?: string;
  color?: string;
  email?: string;
  isEcoUser?: boolean;
}

export interface TransferFormData {
  recipient: string;
  selectedRecipient: Recipient | null;
  amount: string;
  message?: string;
  isDonateChecked: boolean;
}

export interface SplitParticipant {
  id: string;
  name: string;
  isPayor?: boolean;
  isEcoUser?: boolean;
  amount: string;
  email: string;
}

export interface SplitFormData {
  splitTitle: string;
  totalAmount: string;
  participants: SplitParticipant[];
  isReceiptDisabled: boolean;
  splitMethod: "wallet" | "bank" | "qr";
}

export interface TransferResult {
  transactionId: string;
  recipientName: string;
  transferAmount: number;
  donationAmount: number;
  totalDeduction: number;
}

export interface SplitResult {
  transactionId: string;
  splitTitle: string;
  totalAmount: number;
  receivableAmount: number;
}

export interface TransferError {
  message: string;
  code?: string;
}

export interface SplitHistory {
  id: string;
  title: string;
  date: string;
  participantCount: number;
  amount: number;
  status: "completed" | "pending" | "cancelled";
}
</file>

<file path="src/features/transfer/README.md">
# Transfer Feature

送金・割り勘機能を提供するfeatureモジュールです。

## 概要

このfeatureは以下の機能を提供します：

- 個人間送金
- 割り勘機能
- 送金履歴の管理
- 環境貢献寄付オプション

## ディレクトリ構造

```
features/transfer/
├── components/
│   ├── TransferSplitPage/     # メインページコンポーネント
│   ├── TransferForm/          # 送金フォーム
│   ├── SplitForm/             # 割り勘フォーム
│   ├── RecipientSelector/     # 受取人選択
│   ├── SplitHistoryList/      # 割り勘履歴リスト
│   └── SuccessMessage/        # 成功メッセージ
├── hooks/
│   ├── useTransferForm.ts     # 送金フォームロジック
│   └── useSplitForm.ts        # 割り勘フォームロジック
├── types/
│   └── transfer.ts            # 型定義
├── utils/
│   └── validation.ts          # バリデーション関数
├── data/
│   └── recipients-data.ts     # モックデータ
└── index.ts
```

## 主要な型定義

```typescript
// 受取人
interface Recipient {
  id: string;
  name: string;
  avatar?: string;
  color?: string;
  email?: string;
  isEcoUser?: boolean;
}

// 送金フォームデータ
interface TransferFormData {
  recipient: string;
  selectedRecipient: Recipient | null;
  amount: string;
  message?: string;
  isDonateChecked: boolean;
}

// 割り勘参加者
interface SplitParticipant {
  id: string;
  name: string;
  isPayor?: boolean;
  isEcoUser?: boolean;
  amount: string;
  email: string;
}
```

## 使用例

### 送金機能

```typescript
import { useTransferForm } from "@/features/transfer";

const TransferExample = () => {
  const {
    formData,
    updateField,
    selectRecipient,
    handleTransfer,
    isProcessing,
    error,
    isSuccess,
  } = useTransferForm();

  // 送金処理
  const onSubmit = async () => {
    await handleTransfer();
  };
};
```

### 割り勘機能

```typescript
import { useSplitForm } from "@/features/transfer";

const SplitExample = () => {
  const {
    formData,
    updateField,
    updateParticipantAmount,
    distributeEvenly,
    handleSplitRequest,
    isProcessing,
    error,
  } = useSplitForm();

  // 割り勘請求処理
  const onSubmit = async () => {
    await handleSplitRequest();
  };
};
```

## 主要機能

### 送金機能

- 受取人の選択（最近の送金先から選択可能）
- 金額入力とバリデーション
- 環境貢献寄付オプション（1%）
- 残高チェック
- トランザクション記録

### 割り勘機能

- 参加者の追加・削除
- 金額の自動分配（均等割り）
- 個別金額の設定
- 電子レシートオプション
- 送金方法の選択（Wallet/銀行振込/QRコード）

## 依存関係

- `@/features/transactions` - トランザクション管理
- `@/features/balance` - 残高管理
- `@/features/layout` - レイアウトコンポーネント
- `@/shared/hooks` - 共通フック
- `next-auth/react` - 認証情報

## テスト

```bash
# ユニットテスト
npm run test features/transfer

# 統合テスト
npm run test:integration features/transfer
```

## 今後の改善点

- [ ] リアルタイムバリデーション
- [ ] 送金予約機能
- [ ] 繰り返し送金機能
- [ ] グループ割り勘機能
- [ ] 送金通知機能
</file>

<file path="src/lib/business/balance.ts">
/**
 * 残高管理のビジネスロジック関数
 * Result<T, BusinessError>を使用した型安全な残高管理
 */

import { Result, ok, err } from "neverthrow";
import type { BusinessError } from "@/shared/types/errors";
import type { ChargeRequest } from "@/services/api/balance";
import {
  fetchBalance as apiFetchBalance,
  chargeBalance as apiChargeBalance,
} from "@/services/api/balance";
import type { CampaignBalance } from "@/lib/utils/balance-utils";

/**
 * 残高計算結果の型定義
 */
export interface BalanceCalculationResult {
  totalBalance: number;
  availableBalance: number;
  reservedBalance: number;
  campaignBalance: number;
  breakdown: {
    regular: number;
    campaign: CampaignBalance[];
  };
}

/**
 * 残高チェック結果の型定義
 */
export interface BalanceCheckResult {
  hasSufficientFunds: boolean;
  availableAmount: number;
  shortfallAmount: number;
  suggestedChargeAmount: number;
}

/**
 * チャージパラメータの型定義
 */
export interface ChargeParams {
  amount: number;
  paymentMethod: "bank_transfer" | "credit_card" | "convenience_store" | "atm";
  description?: string;
}

/**
 * 送金パラメータの型定義
 */
export interface TransferParams {
  recipientId: string;
  amount: number;
  message?: string;
  description?: string;
}

/**
 * 残高状態の型定義
 */
export interface BalanceState {
  userId: string;
  currentBalance: number;
  availableBalance: number;
  pendingTransactions: number;
  lastUpdated: Date;
  limits: {
    dailySpendingLimit: number;
    monthlySpendingLimit: number;
    maxBalance: number;
  };
}

/**
 * チャージ金額のバリデーション
 * @param amount チャージ金額
 * @returns バリデーション結果
 */
export function validateChargeAmount(
  amount: number,
): Result<number, BusinessError> {
  if (amount <= 0) {
    return err({
      type: "CHARGE_MINIMUM_NOT_MET",
      message: "チャージ金額は0より大きい値である必要があります",
      minimum: 1,
      requested: amount,
    });
  }

  if (amount < 100) {
    return err({
      type: "CHARGE_MINIMUM_NOT_MET",
      message: "チャージ金額は100円以上である必要があります",
      minimum: 100,
      requested: amount,
    });
  }

  if (amount > 1000000) {
    return err({
      type: "TRANSACTION_LIMIT_EXCEEDED",
      message: "チャージ金額が上限を超えています（上限: 1,000,000円）",
      limit: 1000000,
      attempted: amount,
      limitType: "transaction",
    });
  }

  if (!Number.isInteger(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "チャージ金額は整数である必要があります",
      reason: `小数点を含む金額: ${amount}`,
      paymentId: undefined,
    });
  }

  return ok(amount);
}

/**
 * 送金金額のバリデーション
 * @param amount 送金金額
 * @param availableBalance 利用可能残高
 * @returns バリデーション結果
 */
export function validateTransferAmount(
  amount: number,
  availableBalance: number,
): Result<number, BusinessError> {
  if (amount <= 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "送金金額は0より大きい値である必要があります",
      reason: `無効な金額: ${amount}`,
      paymentId: undefined,
    });
  }

  if (amount > availableBalance) {
    return err({
      type: "INSUFFICIENT_BALANCE",
      message: "残高が不足しています",
      required: amount,
      available: availableBalance,
    });
  }

  if (amount > 100000) {
    return err({
      type: "TRANSACTION_LIMIT_EXCEEDED",
      message: "送金金額が上限を超えています（上限: 100,000円）",
      limit: 100000,
      attempted: amount,
      limitType: "transaction",
    });
  }

  if (!Number.isInteger(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "送金金額は整数である必要があります",
      reason: `小数点を含む金額: ${amount}`,
      paymentId: undefined,
    });
  }

  return ok(amount);
}

/**
 * 送金先のバリデーション
 * @param recipientId 送金先ユーザーID
 * @param senderId 送金者ユーザーID
 * @returns バリデーション結果
 */
export function validateTransferRecipient(
  recipientId: string,
  senderId: string,
): Result<string, BusinessError> {
  if (!recipientId || recipientId.trim().length === 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "送金先ユーザーIDが無効です",
      reason: `空のユーザーID: ${recipientId}`,
      paymentId: undefined,
    });
  }

  if (recipientId === senderId) {
    return err({
      type: "TRANSFER_TO_SELF",
      message: "自分自身への送金はできません",
    });
  }

  return ok(recipientId);
}

/**
 * 残高を計算する
 * @param regularBalance 通常残高
 * @param campaignBalances キャンペーン残高の配列
 * @returns 計算結果
 */
export function calculateTotalBalance(
  regularBalance: number,
  campaignBalances: CampaignBalance[] = [],
): Result<BalanceCalculationResult, BusinessError> {
  if (regularBalance < 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "通常残高が負の値です",
      reason: `無効な残高: ${regularBalance}`,
      paymentId: undefined,
    });
  }

  try {
    const campaignTotal = campaignBalances.reduce((sum, cb) => {
      if (cb.amount < 0) {
        throw new Error(`無効なキャンペーン残高: ${cb.amount}`);
      }
      return sum + cb.amount;
    }, 0);

    const totalBalance = regularBalance + campaignTotal;

    // 利用可能残高（期限切れを除く）
    const now = new Date();
    const availableCampaignBalances = campaignBalances.filter((cb) => {
      const expiryDate = new Date(cb.expiryDate);
      return expiryDate > now;
    });

    const availableCampaignTotal = availableCampaignBalances.reduce(
      (sum, cb) => sum + cb.amount,
      0,
    );

    const availableBalance = regularBalance + availableCampaignTotal;

    const result: BalanceCalculationResult = {
      totalBalance,
      availableBalance,
      reservedBalance: 0, // 予約済み残高（今回は0と仮定）
      campaignBalance: campaignTotal,
      breakdown: {
        regular: regularBalance,
        campaign: campaignBalances,
      },
    };

    return ok(result);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "残高計算中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 残高不足をチェックする
 * @param requiredAmount 必要金額
 * @param availableBalance 利用可能残高
 * @returns チェック結果
 */
export function checkSufficientBalance(
  requiredAmount: number,
  availableBalance: number,
): Result<BalanceCheckResult, BusinessError> {
  if (requiredAmount <= 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "必要金額は0より大きい値である必要があります",
      reason: `無効な金額: ${requiredAmount}`,
      paymentId: undefined,
    });
  }

  if (availableBalance < 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "利用可能残高が負の値です",
      reason: `無効な残高: ${availableBalance}`,
      paymentId: undefined,
    });
  }

  const hasSufficientFunds = availableBalance >= requiredAmount;
  const shortfallAmount = hasSufficientFunds
    ? 0
    : requiredAmount - availableBalance;

  // チャージ推奨金額（不足分 + 1000円のマージン）
  const suggestedChargeAmount = hasSufficientFunds
    ? 0
    : Math.ceil((shortfallAmount + 1000) / 1000) * 1000; // 1000円単位で切り上げ

  const result: BalanceCheckResult = {
    hasSufficientFunds,
    availableAmount: availableBalance,
    shortfallAmount,
    suggestedChargeAmount,
  };

  return ok(result);
}

/**
 * チャージを実行する
 * @param params チャージパラメータ
 * @returns チャージ結果
 */
export async function processCharge(
  params: ChargeParams,
): Promise<
  Result<
    { transactionId: string; amount: number; status: string },
    BusinessError
  >
> {
  // 金額のバリデーション
  const amountValidation = validateChargeAmount(params.amount);
  if (amountValidation.isErr()) {
    return err(amountValidation.error);
  }

  try {
    // API呼び出し用のリクエスト作成
    const chargeRequest: ChargeRequest = {
      amount: params.amount,
      paymentMethod: params.paymentMethod,
      paymentDetails: {
        description: params.description || "チャージ",
      },
    };

    // API呼び出し
    const apiResult = await apiChargeBalance(chargeRequest);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "チャージ処理に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    const apiResponse = apiResult.value;

    return ok({
      transactionId: apiResponse.transactionId,
      amount: apiResponse.amount,
      status: apiResponse.status,
    });
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "チャージ処理中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 残高状態を取得・計算する
 * @param userId ユーザーID
 * @returns 残高状態
 */
export async function getBalanceState(
  userId?: string,
): Promise<Result<BalanceState, BusinessError>> {
  try {
    const balanceResult = await apiFetchBalance(userId);

    if (balanceResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "残高情報の取得に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    const balanceData = balanceResult.value;

    const balanceState: BalanceState = {
      userId: balanceData.userId,
      currentBalance: balanceData.currentBalance,
      availableBalance: balanceData.availableBalance,
      pendingTransactions: balanceData.pendingAmount,
      lastUpdated: new Date(balanceData.lastUpdated),
      limits: {
        dailySpendingLimit: 50000, // 仮の値
        monthlySpendingLimit: 500000, // 仮の値
        maxBalance: 1000000, // 仮の値
      },
    };

    return ok(balanceState);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "残高状態取得中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 残高制限をチェックする
 * @param currentAmount 現在金額
 * @param additionalAmount 追加金額
 * @param limitAmount 制限金額
 * @param limitType 制限種別
 * @returns チェック結果
 */
export function checkBalanceLimit(
  currentAmount: number,
  additionalAmount: number,
  limitAmount: number,
  limitType: "daily" | "monthly" | "transaction",
): Result<boolean, BusinessError> {
  if (currentAmount < 0 || additionalAmount < 0 || limitAmount < 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "金額は0以上である必要があります",
      reason: `無効な金額: current=${currentAmount}, additional=${additionalAmount}, limit=${limitAmount}`,
      paymentId: undefined,
    });
  }

  const newTotal = currentAmount + additionalAmount;

  if (newTotal > limitAmount) {
    return err({
      type: "TRANSACTION_LIMIT_EXCEEDED",
      message: `${limitType === "daily" ? "日次" : limitType === "monthly" ? "月次" : "取引"}制限を超えています`,
      limit: limitAmount,
      attempted: newTotal,
      limitType,
    });
  }

  return ok(true);
}

// テストコード（In Source Testing）
if (import.meta.vitest) {
  const { it, expect, describe } = import.meta.vitest;

  describe("validateChargeAmount", () => {
    it("有効なチャージ金額の場合、成功を返す", () => {
      const result = validateChargeAmount(1000);
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(1000);
    });

    it("0以下の金額の場合、エラーを返す", () => {
      const result = validateChargeAmount(0);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("CHARGE_MINIMUM_NOT_MET");
    });

    it("最小金額未満の場合、エラーを返す", () => {
      const result = validateChargeAmount(50);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("CHARGE_MINIMUM_NOT_MET");
    });

    it("上限を超える金額の場合、エラーを返す", () => {
      const result = validateChargeAmount(2000000);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSACTION_LIMIT_EXCEEDED");
    });
  });

  describe("validateTransferAmount", () => {
    it("有効な送金金額の場合、成功を返す", () => {
      const result = validateTransferAmount(1000, 5000);
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(1000);
    });

    it("残高不足の場合、エラーを返す", () => {
      const result = validateTransferAmount(5000, 3000);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("INSUFFICIENT_BALANCE");
    });

    it("上限を超える金額の場合、エラーを返す", () => {
      const result = validateTransferAmount(200000, 300000);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSACTION_LIMIT_EXCEEDED");
    });
  });

  describe("validateTransferRecipient", () => {
    it("有効な送金先の場合、成功を返す", () => {
      const result = validateTransferRecipient("user_123", "user_456");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe("user_123");
    });

    it("自分自身への送金の場合、エラーを返す", () => {
      const result = validateTransferRecipient("user_123", "user_123");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSFER_TO_SELF");
    });

    it("空の送金先IDの場合、エラーを返す", () => {
      const result = validateTransferRecipient("", "user_456");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("calculateTotalBalance", () => {
    it("通常残高とキャンペーン残高を正しく計算する", () => {
      const campaignBalances: CampaignBalance[] = [
        {
          id: 1,
          amount: 500,
          label: "キャンペーン1",
          expiryDate: "2025-12-31",
          daysLeft: 30,
        },
        {
          id: 2,
          amount: 300,
          label: "キャンペーン2",
          expiryDate: "2025-12-31",
          daysLeft: 60,
        },
      ];

      const result = calculateTotalBalance(1000, campaignBalances);
      expect(result.isOk()).toBe(true);

      const calculation = result._unsafeUnwrap();
      expect(calculation.totalBalance).toBe(1800);
      expect(calculation.campaignBalance).toBe(800);
      expect(calculation.breakdown.regular).toBe(1000);
    });

    it("負の通常残高の場合、エラーを返す", () => {
      const result = calculateTotalBalance(-100);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("checkSufficientBalance", () => {
    it("残高が十分な場合、適切な結果を返す", () => {
      const result = checkSufficientBalance(1000, 5000);
      expect(result.isOk()).toBe(true);

      const check = result._unsafeUnwrap();
      expect(check.hasSufficientFunds).toBe(true);
      expect(check.shortfallAmount).toBe(0);
      expect(check.suggestedChargeAmount).toBe(0);
    });

    it("残高不足の場合、不足分と推奨チャージ額を計算する", () => {
      const result = checkSufficientBalance(5000, 3000);
      expect(result.isOk()).toBe(true);

      const check = result._unsafeUnwrap();
      expect(check.hasSufficientFunds).toBe(false);
      expect(check.shortfallAmount).toBe(2000);
      expect(check.suggestedChargeAmount).toBe(3000); // 2000 + 1000のマージンを1000円単位で切り上げ
    });
  });

  describe("checkBalanceLimit", () => {
    it("制限内の場合、成功を返す", () => {
      const result = checkBalanceLimit(1000, 2000, 5000, "daily");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(true);
    });

    it("制限を超える場合、エラーを返す", () => {
      const result = checkBalanceLimit(3000, 3000, 5000, "daily");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSACTION_LIMIT_EXCEEDED");
    });
  });
}
</file>

<file path="src/lib/business/eco-contribution.ts">
/**
 * 環境貢献計算のビジネスロジック関数
 * Result<T, BusinessError>を使用した型安全な環境貢献処理
 */

import { Result, ok, err } from "neverthrow";
import type { BusinessError } from "@/shared/types/errors";
import type {
  EcoRank,
  ContributionParams,
  EcoState,
  EcoImpact,
} from "@/lib/utils/eco/types";
import {
  determineEcoRank,
  calculateEcoImpact,
  calculateContribution,
  calculateEcoProgress,
} from "@/lib/utils/eco/calculations";

/**
 * 拡張環境貢献パラメータの型定義
 */
export interface ExtendedContributionParams extends ContributionParams {
  userId?: string;
  projectId?: string;
  category?: "forest" | "ocean" | "energy" | "waste" | "carbon";
  description?: string;
}

/**
 * 環境貢献計算結果の型定義
 */
export interface EcoContributionResult {
  impact: EcoImpact;
  newState: Partial<EcoState>;
  rank: EcoRank;
  progress: number;
  achievements: string[];
  nextMilestone: {
    amount: number;
    rank: EcoRank;
    description: string;
  };
}

/**
 * 環境貢献集計結果の型定義
 */
export interface EcoContributionSummary {
  totalContribution: number;
  totalImpact: EcoImpact;
  contributionsByCategory: Record<string, number>;
  contributionsByProject: Record<string, number>;
  currentRank: EcoRank;
  nextRankThreshold: number;
  averageContributionPerTransaction: number;
  contributionStreak: number;
}

/**
 * 環境貢献の有効性チェック結果
 */
export interface EcoContributionValidation {
  isValid: boolean;
  validatedAmount: number;
  validatedCategory: string;
  warnings: string[];
  suggestions: string[];
}

/**
 * 環境貢献金額のバリデーション
 * @param amount 貢献金額
 * @returns バリデーション結果
 */
export function validateEcoContributionAmount(
  amount: number,
): Result<number, BusinessError> {
  if (amount < 0) {
    return err({
      type: "DONATION_LIMIT_EXCEEDED",
      message: "環境貢献金額は0以上である必要があります",
      maxDonationAmount: 0,
      requestedAmount: amount,
    });
  }

  if (amount > 50000) {
    return err({
      type: "DONATION_LIMIT_EXCEEDED",
      message: "環境貢献金額が上限を超えています（上限: 50,000円）",
      maxDonationAmount: 50000,
      requestedAmount: amount,
    });
  }

  if (!Number.isInteger(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献金額は整数である必要があります",
      reason: `小数点を含む金額: ${amount}`,
      paymentId: undefined,
    });
  }

  return ok(amount);
}

/**
 * 環境貢献カテゴリのバリデーション
 * @param category 貢献カテゴリ
 * @returns バリデーション結果
 */
export function validateEcoContributionCategory(
  category?: string,
): Result<"forest" | "ocean" | "energy" | "waste" | "carbon", BusinessError> {
  if (!category) {
    return ok("forest"); // デフォルトは森林保全
  }

  const validCategories = [
    "forest",
    "ocean",
    "energy",
    "waste",
    "carbon",
  ] as const;

  if (
    !validCategories.includes(
      category as "forest" | "ocean" | "energy" | "waste" | "carbon",
    )
  ) {
    return err({
      type: "PAYMENT_FAILED",
      message: "無効な環境貢献カテゴリです",
      reason: `サポートされていないカテゴリ: ${category}`,
      paymentId: undefined,
    });
  }

  return ok(category as "forest" | "ocean" | "energy" | "waste" | "carbon");
}

/**
 * 環境貢献パラメータのバリデーション
 * @param params 環境貢献パラメータ
 * @returns バリデーション結果
 */
export function validateEcoContributionParams(
  params: ExtendedContributionParams,
): Result<EcoContributionValidation, BusinessError> {
  const warnings: string[] = [];
  const suggestions: string[] = [];

  // 金額のバリデーション
  const amountResult = validateEcoContributionAmount(params.amount);
  if (amountResult.isErr()) {
    return err(amountResult.error);
  }

  // カテゴリのバリデーション
  const categoryResult = validateEcoContributionCategory(params.category);
  if (categoryResult.isErr()) {
    return err(categoryResult.error);
  }

  // 金額に基づく警告とアドバイス
  if (params.amount < 100) {
    warnings.push("少額の貢献でも環境に良い影響を与えます");
  }

  if (params.amount >= 1000) {
    suggestions.push(
      "大きな貢献をありがとうございます！SNSでシェアしませんか？",
    );
  }

  // 説明文のバリデーション
  if (params.description && params.description.length > 200) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献の説明は200文字以内である必要があります",
      reason: `説明文が長すぎます: ${params.description.length}文字`,
      paymentId: undefined,
    });
  }

  const result: EcoContributionValidation = {
    isValid: true,
    validatedAmount: amountResult.value,
    validatedCategory: categoryResult.value ?? "forest",
    warnings,
    suggestions,
  };

  return ok(result);
}

/**
 * 環境貢献を計算する（Result版）
 * @param currentState 現在の環境貢献状態
 * @param params 貢献パラメータ
 * @returns 計算結果
 */
export function calculateEcoContributionSafe(
  currentState: EcoState,
  params: ExtendedContributionParams,
): Result<EcoContributionResult, BusinessError> {
  // パラメータのバリデーション
  const validationResult = validateEcoContributionParams(params);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    // 既存の計算関数を使用
    const impact = calculateEcoImpact(params.amount);
    const newState = calculateContribution(currentState, params);

    // 新しい合計寄付額からランクを計算
    const newTotalDonation = newState.totalDonation || 0;
    const rank = determineEcoRank(newTotalDonation);

    // 進捗率の計算（仮の目標値を使用）
    const targetForestArea = 100; // 100m²
    const targetWaterSaved = 50000; // 50,000L
    const targetCo2Reduction = 1000; // 1,000kg

    const progress = calculateEcoProgress(
      newState.forestArea || 0,
      newState.waterSaved || 0,
      newState.co2Reduction || 0,
      targetForestArea,
      targetWaterSaved,
      targetCo2Reduction,
    );

    // 成果の判定
    const achievements: string[] = [];
    if (impact.forestArea >= 1) {
      achievements.push(`森林保全: ${impact.forestArea}m²貢献`);
    }
    if (impact.waterSaved >= 100) {
      achievements.push(`水資源保護: ${impact.waterSaved}L節約`);
    }
    if (impact.co2Reduction >= 1) {
      achievements.push(`CO₂削減: ${impact.co2Reduction}kg削減`);
    }

    // 次のマイルストーンの計算
    const nextMilestone = calculateNextMilestone(newTotalDonation, rank);

    const result: EcoContributionResult = {
      impact,
      newState,
      rank,
      progress,
      achievements,
      nextMilestone,
    };

    return ok(result);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献計算中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 次のマイルストーンを計算する
 * @param currentDonation 現在の寄付総額
 * @param currentRank 現在のランク
 * @returns 次のマイルストーン情報
 */
export function calculateNextMilestone(
  currentDonation: number,
  _currentRank: EcoRank, // eslint-disable-line @typescript-eslint/no-unused-vars
): { amount: number; rank: EcoRank; description: string } {
  const milestones = [
    {
      threshold: 5000,
      rank: "エコサポーター" as EcoRank,
      description: "継続的な環境貢献者",
    },
    {
      threshold: 20000,
      rank: "エコマイスター" as EcoRank,
      description: "環境保全のリーダー",
    },
    {
      threshold: 50000,
      rank: "エコチャンピオン" as EcoRank,
      description: "環境保全の先駆者",
    },
  ];

  const nextMilestone = milestones.find(
    (milestone) => currentDonation < milestone.threshold,
  );

  if (nextMilestone) {
    return {
      amount: nextMilestone.threshold - currentDonation,
      rank: nextMilestone.rank,
      description: nextMilestone.description,
    };
  }

  // 最高ランクに到達済み
  return {
    amount: 0,
    rank: "エコチャンピオン",
    description: "最高ランク達成済み",
  };
}

/**
 * 環境貢献の集計を計算する
 * @param contributions 貢献履歴の配列
 * @returns 集計結果
 */
export function aggregateEcoContributions(
  contributions: ExtendedContributionParams[],
): Result<EcoContributionSummary, BusinessError> {
  if (!Array.isArray(contributions)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献データが無効です",
      reason: "配列ではない貢献データ",
      paymentId: undefined,
    });
  }

  try {
    const totalContribution = contributions.reduce(
      (sum, c) => sum + c.amount,
      0,
    );
    const contributionCount = contributions.length;

    // 総合インパクトの計算
    const totalImpact = contributions.reduce(
      (acc, contribution) => {
        const impact = calculateEcoImpact(contribution.amount);
        return {
          forestArea: acc.forestArea + impact.forestArea,
          waterSaved: acc.waterSaved + impact.waterSaved,
          co2Reduction: acc.co2Reduction + impact.co2Reduction,
        };
      },
      { forestArea: 0, waterSaved: 0, co2Reduction: 0 },
    );

    // カテゴリ別集計
    const contributionsByCategory: Record<string, number> = {};
    contributions.forEach((contribution) => {
      const category = contribution.category || "forest";
      contributionsByCategory[category] =
        (contributionsByCategory[category] || 0) + contribution.amount;
    });

    // プロジェクト別集計
    const contributionsByProject: Record<string, number> = {};
    contributions.forEach((contribution) => {
      if (contribution.projectId) {
        contributionsByProject[contribution.projectId] =
          (contributionsByProject[contribution.projectId] || 0) +
          contribution.amount;
      }
    });

    // 現在のランクと次のランクまでの金額
    const currentRank = determineEcoRank(totalContribution);
    const nextRankThreshold = calculateNextMilestone(
      totalContribution,
      currentRank,
    ).amount;

    // 平均貢献額
    const averageContributionPerTransaction =
      contributionCount > 0 ? totalContribution / contributionCount : 0;

    // 貢献ストリーク（連続貢献日数の簡易計算）
    const contributionStreak = Math.min(contributionCount, 30); // 最大30日

    const result: EcoContributionSummary = {
      totalContribution,
      totalImpact,
      contributionsByCategory,
      contributionsByProject,
      currentRank,
      nextRankThreshold,
      averageContributionPerTransaction,
      contributionStreak,
    };

    return ok(result);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献集計中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 環境貢献の効率性を計算する
 * @param amount 貢献金額
 * @param category 貢献カテゴリ
 * @returns 効率性情報
 */
export function calculateEcoEfficiency(
  amount: number,
  category: ExtendedContributionParams["category"] = "forest",
): Result<
  { efficiency: number; description: string; comparison: string },
  BusinessError
> {
  const amountValidation = validateEcoContributionAmount(amount);
  if (amountValidation.isErr()) {
    return err(amountValidation.error);
  }

  const categoryValidation = validateEcoContributionCategory(category);
  if (categoryValidation.isErr()) {
    return err(categoryValidation.error);
  }

  try {
    const impact = calculateEcoImpact(amount);

    // カテゴリ別の効率性計算
    let efficiency = 0;
    let description = "";
    let comparison = "";

    switch (category) {
      case "forest":
        efficiency = (impact.forestArea / amount) * 1000; // 1000円あたりのm²
        description = `森林保全: ${impact.forestArea}m²の森林を保護`;
        comparison = `一般的な植樹活動の${Math.round(efficiency * 100)}%の効率`;
        break;
      case "ocean":
        efficiency = impact.waterSaved / amount; // 1円あたりのL
        description = `海洋保護: ${impact.waterSaved}Lの水を浄化`;
        comparison = `一般的な海洋清掃の${Math.round(efficiency * 50)}%の効率`;
        break;
      case "energy":
        efficiency = (impact.co2Reduction / amount) * 100; // 100円あたりのkg
        description = `再生エネルギー: ${impact.co2Reduction}kgのCO₂削減`;
        comparison = `太陽光発電の${Math.round(efficiency * 80)}%の効率`;
        break;
      case "waste":
        efficiency = (impact.co2Reduction / amount) * 200; // 削減量ベース
        description = `廃棄物削減: ${impact.co2Reduction}kg相当の廃棄物削減`;
        comparison = `リサイクル活動の${Math.round(efficiency * 60)}%の効率`;
        break;
      case "carbon":
        efficiency = (impact.co2Reduction / amount) * 1000; // 1000円あたりのkg
        description = `炭素オフセット: ${impact.co2Reduction}kgのCO₂を削減`;
        comparison = `カーボンクレジットの${Math.round(efficiency * 120)}%の効率`;
        break;
    }

    return ok({
      efficiency: Math.round(efficiency * 100) / 100, // 小数点2桁
      description,
      comparison,
    });
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献効率性計算中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 環境貢献レポートを生成する
 * @param state 環境貢献状態
 * @param period 期間（月・年単位）
 * @returns レポート
 */
export function generateEcoContributionReport(
  state: EcoState,
  period: "month" | "year" = "month",
): Result<
  {
    summary: string;
    achievements: string[];
    recommendations: string[];
    nextGoals: string[];
  },
  BusinessError
> {
  try {
    const rank = determineEcoRank(state.totalDonation);
    const periodLabel = period === "month" ? "今月" : "今年";

    // サマリーの生成
    const summary = `${periodLabel}の環境貢献: ${state.monthlyDonation.toLocaleString()}円
現在のランク: ${rank}
森林保全: ${state.forestArea}m²
水資源保護: ${state.waterSaved.toLocaleString()}L
CO₂削減: ${state.co2Reduction}kg`;

    // 成果の生成
    const achievements: string[] = [];
    if (state.forestArea >= 10) {
      achievements.push(`大きな森林保全貢献: ${state.forestArea}m²`);
    }
    if (state.waterSaved >= 10000) {
      achievements.push(`水資源保護: ${state.waterSaved.toLocaleString()}L`);
    }
    if (state.co2Reduction >= 100) {
      achievements.push(`大きなCO₂削減: ${state.co2Reduction}kg`);
    }

    // レコメンデーションの生成
    const recommendations: string[] = [];
    if (state.monthlyDonation < 1000) {
      recommendations.push("月1,000円の貢献で年間12m²の森林保全が可能です");
    }
    if (rank === "エコビギナー") {
      recommendations.push(
        "継続的な貢献で「エコサポーター」ランクを目指しましょう",
      );
    }

    // 次の目標の生成
    const nextGoals: string[] = [];
    const nextMilestone = calculateNextMilestone(state.totalDonation, rank);
    if (nextMilestone.amount > 0) {
      nextGoals.push(
        `${nextMilestone.rank}まであと${nextMilestone.amount.toLocaleString()}円`,
      );
    }
    nextGoals.push(
      `${period === "month" ? "来月" : "来年"}は${Math.round(state.monthlyDonation * 1.2).toLocaleString()}円の貢献を目標にしませんか？`,
    );

    return ok({
      summary,
      achievements,
      recommendations,
      nextGoals,
    });
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "環境貢献レポート生成中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

// テストコード（In Source Testing）
if (import.meta.vitest) {
  const { it, expect, describe } = import.meta.vitest;

  describe("validateEcoContributionAmount", () => {
    it("有効な金額の場合、成功を返す", () => {
      const result = validateEcoContributionAmount(1000);
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(1000);
    });

    it("負の金額の場合、エラーを返す", () => {
      const result = validateEcoContributionAmount(-100);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("DONATION_LIMIT_EXCEEDED");
    });

    it("上限を超える金額の場合、エラーを返す", () => {
      const result = validateEcoContributionAmount(60000);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("DONATION_LIMIT_EXCEEDED");
    });

    it("小数点の金額の場合、エラーを返す", () => {
      const result = validateEcoContributionAmount(100.5);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("validateEcoContributionCategory", () => {
    it("有効なカテゴリの場合、成功を返す", () => {
      const result = validateEcoContributionCategory("forest");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe("forest");
    });

    it("無効なカテゴリの場合、エラーを返す", () => {
      const result = validateEcoContributionCategory("invalid_category");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });

    it("未定義の場合、デフォルト値を返す", () => {
      const result = validateEcoContributionCategory();
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe("forest");
    });
  });

  describe("calculateEcoContributionSafe", () => {
    it("有効なパラメータで正しく計算する", () => {
      const currentState: EcoState = {
        forestArea: 5,
        waterSaved: 1000,
        co2Reduction: 50,
        totalDonation: 2000,
        monthlyDonation: 500,
      };

      const params: ExtendedContributionParams = {
        amount: 1000,
        category: "forest",
      };

      const result = calculateEcoContributionSafe(currentState, params);
      expect(result.isOk()).toBe(true);

      const calculation = result._unsafeUnwrap();
      expect(calculation.impact.forestArea).toBe(0.5); // 1000円 * 0.0005
      expect(calculation.rank).toBe("エコビギナー"); // 3000円未満
    });
  });

  describe("aggregateEcoContributions", () => {
    it("貢献を正しく集計する", () => {
      const contributions: ExtendedContributionParams[] = [
        { amount: 1000, category: "forest" },
        { amount: 500, category: "ocean" },
        { amount: 1500, category: "forest" },
      ];

      const result = aggregateEcoContributions(contributions);
      expect(result.isOk()).toBe(true);

      const summary = result._unsafeUnwrap();
      expect(summary.totalContribution).toBe(3000);
      expect(summary.contributionsByCategory.forest).toBe(2500);
      expect(summary.contributionsByCategory.ocean).toBe(500);
      expect(summary.averageContributionPerTransaction).toBe(1000);
    });

    it("空の配列の場合、適切な結果を返す", () => {
      const result = aggregateEcoContributions([]);
      expect(result.isOk()).toBe(true);

      const summary = result._unsafeUnwrap();
      expect(summary.totalContribution).toBe(0);
      expect(summary.averageContributionPerTransaction).toBe(0);
    });
  });

  describe("calculateEcoEfficiency", () => {
    it("森林カテゴリの効率性を正しく計算する", () => {
      const result = calculateEcoEfficiency(1000, "forest");
      expect(result.isOk()).toBe(true);

      const efficiency = result._unsafeUnwrap();
      expect(efficiency.efficiency).toBe(0.5); // 1000円で0.5m²
      expect(efficiency.description).toContain("森林保全");
    });

    it("海洋カテゴリの効率性を正しく計算する", () => {
      const result = calculateEcoEfficiency(1000, "ocean");
      expect(result.isOk()).toBe(true);

      const efficiency = result._unsafeUnwrap();
      expect(efficiency.description).toContain("海洋保護");
    });
  });

  describe("calculateNextMilestone", () => {
    it("次のマイルストーンを正しく計算する", () => {
      const milestone = calculateNextMilestone(3000, "エコビギナー");
      expect(milestone.amount).toBe(2000); // 5000 - 3000
      expect(milestone.rank).toBe("エコサポーター");
    });

    it("最高ランクの場合、適切な結果を返す", () => {
      const milestone = calculateNextMilestone(60000, "エコチャンピオン");
      expect(milestone.amount).toBe(0);
      expect(milestone.rank).toBe("エコチャンピオン");
    });
  });
}
</file>

<file path="src/lib/business/payment.ts">
/**
 * 決済処理のビジネスロジック関数
 * Result<T, BusinessError>を使用した型安全な決済処理
 */

import { Result, ok, err } from "neverthrow";
import type { BusinessError } from "@/shared/types/errors";
import type { PaymentRequest } from "@/services/api/balance";
import {
  processPayment as apiProcessPayment,
  checkPaymentStatus as apiCheckPaymentStatus,
} from "@/services/api/balance";

/**
 * 決済情報の型定義
 */
export interface PaymentValidationResult {
  isValid: boolean;
  amount: number;
  method: string;
  currency: string;
}

/**
 * 決済実行パラメータ
 */
export interface ProcessPaymentParams {
  amount: number;
  paymentMethod: "bank_transfer" | "credit_card" | "convenience_store" | "atm";
  description?: string;
  metadata?: Record<string, unknown>;
}

/**
 * 決済状態の型定義
 */
export interface PaymentState {
  transactionId: string;
  amount: number;
  status: "pending" | "processing" | "completed" | "failed" | "cancelled";
  method: string;
  createdAt: Date;
  completedAt?: Date;
}

/**
 * 決済金額のバリデーション
 * @param amount 決済金額
 * @returns バリデーション結果
 */
export function validatePaymentAmount(
  amount: number,
): Result<number, BusinessError> {
  if (amount <= 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済金額は0より大きい値である必要があります",
      reason: `無効な金額: ${amount}`,
      paymentId: undefined,
    });
  }

  if (amount > 1000000) {
    return err({
      type: "TRANSACTION_LIMIT_EXCEEDED",
      message: "決済金額が上限を超えています（上限: 1,000,000円）",
      limit: 1000000,
      attempted: amount,
      limitType: "transaction",
    });
  }

  if (!Number.isInteger(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済金額は整数である必要があります",
      reason: `小数点を含む金額: ${amount}`,
      paymentId: undefined,
    });
  }

  return ok(amount);
}

/**
 * 決済方法のバリデーション
 * @param method 決済方法
 * @returns バリデーション結果
 */
export function validatePaymentMethod(
  method: string,
): Result<ProcessPaymentParams["paymentMethod"], BusinessError> {
  const validMethods = [
    "bank_transfer",
    "credit_card",
    "convenience_store",
    "atm",
  ] as const;

  if (!validMethods.includes(method as ProcessPaymentParams["paymentMethod"])) {
    return err({
      type: "PAYMENT_FAILED",
      message: "無効な決済方法です",
      reason: `サポートされていない決済方法: ${method}`,
      paymentId: undefined,
    });
  }

  return ok(method as ProcessPaymentParams["paymentMethod"]);
}

/**
 * 決済パラメータの包括的バリデーション
 * @param params 決済パラメータ
 * @returns バリデーション結果
 */
export function validatePaymentParams(
  params: ProcessPaymentParams,
): Result<PaymentValidationResult, BusinessError> {
  // 金額のバリデーション
  const amountResult = validatePaymentAmount(params.amount);
  if (amountResult.isErr()) {
    return err(amountResult.error);
  }

  // 決済方法のバリデーション
  const methodResult = validatePaymentMethod(params.paymentMethod);
  if (methodResult.isErr()) {
    return err(methodResult.error);
  }

  // 説明文のバリデーション（オプション）
  if (params.description && params.description.length > 100) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済説明文は100文字以内である必要があります",
      reason: `説明文が長すぎます: ${params.description.length}文字（上限: 100文字）`,
      paymentId: undefined,
    });
  }

  return ok({
    isValid: true,
    amount: amountResult.value,
    method: methodResult.value,
    currency: "JPY",
  });
}

/**
 * 決済を実行する
 * @param params 決済パラメータ
 * @returns 決済結果
 */
export async function processPayment(
  params: ProcessPaymentParams,
): Promise<Result<PaymentState, BusinessError>> {
  // バリデーション実行
  const validationResult = validatePaymentParams(params);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    // API呼び出し用のリクエスト作成
    const apiRequest: PaymentRequest = {
      amount: params.amount,
      merchantId: "default_merchant", // 仮の加盟店ID
      description: params.description || "",
      ecoContribution: {
        enabled: true,
        percentage: 5, // デフォルト5%のエコ貢献
      },
    };

    // API呼び出し
    const apiResult = await apiProcessPayment(apiRequest);

    if (apiResult.isErr()) {
      // APIエラーをBusinessErrorに変換
      return err({
        type: "PAYMENT_FAILED",
        message: "決済処理に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    const apiResponse = apiResult.value;

    // PaymentStateに変換（statusの型を調整）
    let paymentStatus: PaymentState["status"] = "pending";
    if (apiResponse.status === "success") {
      paymentStatus = "completed";
    } else if (apiResponse.status === "failed") {
      paymentStatus = "failed";
    } else if (apiResponse.status === "pending") {
      paymentStatus = "pending";
    }

    const paymentState: PaymentState = {
      transactionId: apiResponse.transactionId,
      amount: apiResponse.amount,
      status: paymentStatus,
      method: params.paymentMethod,
      createdAt: new Date(),
      completedAt: paymentStatus === "completed" ? new Date() : undefined,
    };

    return ok(paymentState);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済処理中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 決済状態を確認する
 * @param transactionId 取引ID
 * @returns 決済状態
 */
export async function checkPaymentState(
  transactionId: string,
): Promise<Result<PaymentState, BusinessError>> {
  if (!transactionId || transactionId.trim().length === 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引IDが無効です",
      reason: `空の取引ID: ${transactionId}`,
      paymentId: transactionId,
    });
  }

  try {
    const apiResult = await apiCheckPaymentStatus(transactionId);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "決済状態の確認に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: transactionId,
      });
    }

    const apiResponse = apiResult.value;

    // PaymentStateに変換（statusの型を調整）
    let paymentStatus: PaymentState["status"] = "pending";
    if (apiResponse.status === "success") {
      paymentStatus = "completed";
    } else if (apiResponse.status === "failed") {
      paymentStatus = "failed";
    } else if (apiResponse.status === "pending") {
      paymentStatus = "pending";
    }

    const paymentState: PaymentState = {
      transactionId: apiResponse.transactionId,
      amount: apiResponse.amount,
      status: paymentStatus,
      method: "unknown", // APIレスポンスから決済方法が取得できない場合
      createdAt: new Date(), // APIレスポンスから作成日時が取得できない場合
      completedAt: paymentStatus === "completed" ? new Date() : undefined,
    };

    return ok(paymentState);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済状態確認中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: transactionId,
    });
  }
}

/**
 * 決済キャンセル処理
 * @param transactionId 取引ID
 * @returns キャンセル結果
 */
export function cancelPayment(
  transactionId: string,
): Result<{ transactionId: string; cancelledAt: Date }, BusinessError> {
  if (!transactionId || transactionId.trim().length === 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引IDが無効です",
      reason: `空の取引ID: ${transactionId}`,
      paymentId: transactionId,
    });
  }

  // 実際の実装では、API呼び出しを行う
  // 現在はモック実装
  return ok({
    transactionId,
    cancelledAt: new Date(),
  });
}

/**
 * 決済手数料を計算する
 * @param amount 決済金額
 * @param method 決済方法
 * @returns 手数料
 */
export function calculatePaymentFee(
  amount: number,
  method: ProcessPaymentParams["paymentMethod"],
): Result<number, BusinessError> {
  const amountValidation = validatePaymentAmount(amount);
  if (amountValidation.isErr()) {
    return err(amountValidation.error);
  }

  const methodValidation = validatePaymentMethod(method);
  if (methodValidation.isErr()) {
    return err(methodValidation.error);
  }

  // 決済方法別の手数料計算
  let feeRate = 0;
  switch (method) {
    case "credit_card":
      feeRate = 0.033; // 3.3%
      break;
    case "bank_transfer":
      feeRate = 0; // 無料
      break;
    case "convenience_store":
      feeRate = 0.01; // 1%
      break;
    case "atm":
      feeRate = 0.005; // 0.5%
      break;
    default:
      return err({
        type: "PAYMENT_FAILED",
        message: "不明な決済方法です",
        reason: `未対応の決済方法: ${method}`,
        paymentId: undefined,
      });
  }

  const fee = Math.floor(amount * feeRate);
  return ok(fee);
}

// テストコード（In Source Testing）
if (import.meta.vitest) {
  const { it, expect, describe } = import.meta.vitest;

  describe("validatePaymentAmount", () => {
    it("有効な金額の場合、成功を返す", () => {
      const result = validatePaymentAmount(1000);
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(1000);
    });

    it("0以下の金額の場合、エラーを返す", () => {
      const result = validatePaymentAmount(0);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });

    it("上限を超える金額の場合、エラーを返す", () => {
      const result = validatePaymentAmount(2000000);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSACTION_LIMIT_EXCEEDED");
    });

    it("小数点の金額の場合、エラーを返す", () => {
      const result = validatePaymentAmount(100.5);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("validatePaymentMethod", () => {
    it("有効な決済方法の場合、成功を返す", () => {
      const result = validatePaymentMethod("credit_card");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe("credit_card");
    });

    it("無効な決済方法の場合、エラーを返す", () => {
      const result = validatePaymentMethod("invalid_method");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("validatePaymentParams", () => {
    it("有効なパラメータの場合、成功を返す", () => {
      const params: ProcessPaymentParams = {
        amount: 1000,
        paymentMethod: "credit_card",
        description: "テスト決済",
      };
      const result = validatePaymentParams(params);
      expect(result.isOk()).toBe(true);

      const validation = result._unsafeUnwrap();
      expect(validation.isValid).toBe(true);
      expect(validation.amount).toBe(1000);
      expect(validation.method).toBe("credit_card");
    });

    it("長すぎる説明文の場合、エラーを返す", () => {
      const params: ProcessPaymentParams = {
        amount: 1000,
        paymentMethod: "credit_card",
        description: "a".repeat(101), // 101文字
      };
      const result = validatePaymentParams(params);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("calculatePaymentFee", () => {
    it("クレジットカードの手数料を正しく計算する", () => {
      const result = calculatePaymentFee(1000, "credit_card");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(33); // 1000 * 0.033 = 33
    });

    it("銀行振込の手数料は0円", () => {
      const result = calculatePaymentFee(1000, "bank_transfer");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(0);
    });

    it("コンビニ決済の手数料を正しく計算する", () => {
      const result = calculatePaymentFee(1000, "convenience_store");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(10); // 1000 * 0.01 = 10
    });
  });

  describe("cancelPayment", () => {
    it("有効な取引IDの場合、キャンセル成功を返す", () => {
      const result = cancelPayment("txn_123");
      expect(result.isOk()).toBe(true);

      const cancelled = result._unsafeUnwrap();
      expect(cancelled.transactionId).toBe("txn_123");
      expect(cancelled.cancelledAt).toBeInstanceOf(Date);
    });

    it("空の取引IDの場合、エラーを返す", () => {
      const result = cancelPayment("");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });
}
</file>

<file path="src/lib/business/transaction.ts">
/**
 * トランザクション処理のビジネスロジック関数
 * Result<T, BusinessError>を使用した型安全な取引処理
 */

import { Result, ok, err } from "neverthrow";
import type { BusinessError } from "@/shared/types/errors";
import type {
  Transaction,
  TransactionType,
  EcoContribution,
} from "@/shared/types/transaction";
import type {
  CreateTransactionRequest,
  UpdateTransactionRequest,
  FetchTransactionsParams,
  TransactionsResponse,
  TransactionStats,
} from "@/services/api/transactions";
import {
  createTransaction as apiCreateTransaction,
  updateTransaction as apiUpdateTransaction,
  deleteTransaction as apiDeleteTransaction,
  fetchTransactions as apiFetchTransactions,
  fetchTransactionStats as apiFetchTransactionStats,
} from "@/services/api/transactions";

/**
 * 取引作成パラメータの型定義
 */
export interface CreateTransactionParams {
  type: TransactionType;
  amount: number;
  description: string;
  ecoContribution?: {
    enabled: boolean;
    amount: number;
    project?: string;
  };
  campaignInfo?: Transaction["campaignInfo"];
  splitInfo?: Transaction["splitInfo"];
}

/**
 * 取引更新パラメータの型定義
 */
export interface UpdateTransactionParams {
  transactionId: string;
  description?: string;
  ecoContribution?: EcoContribution;
  campaignInfo?: Transaction["campaignInfo"];
  splitInfo?: Transaction["splitInfo"];
}

/**
 * 取引フィルターパラメータの型定義
 */
export interface TransactionFilterParams {
  userId?: string;
  type?: TransactionType;
  dateFrom?: string;
  dateTo?: string;
  limit?: number;
  offset?: number;
}

/**
 * 取引集計結果の型定義
 */
export interface TransactionAggregation {
  totalAmount: number;
  transactionCount: number;
  averageAmount: number;
  breakdown: {
    byType: Record<TransactionType, number>;
    byMonth: Record<string, number>;
  };
  ecoContribution: {
    totalAmount: number;
    averagePercentage: number;
    transactionCount: number;
  };
}

/**
 * 取引バリデーション結果の型定義
 */
export interface TransactionValidationResult {
  isValid: boolean;
  validatedAmount: number;
  validatedType: TransactionType;
  issues: string[];
}

/**
 * 取引金額のバリデーション
 * @param amount 取引金額
 * @param transactionType 取引種別
 * @returns バリデーション結果
 */
export function validateTransactionAmount(
  amount: number,
  transactionType: TransactionType,
): Result<number, BusinessError> {
  if (!Number.isFinite(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引金額が無効です",
      reason: `有限数ではない金額: ${amount}`,
      paymentId: undefined,
    });
  }

  if (transactionType === "charge" && amount <= 0) {
    return err({
      type: "CHARGE_MINIMUM_NOT_MET",
      message: "チャージ金額は0より大きい値である必要があります",
      minimum: 1,
      requested: amount,
    });
  }

  if (transactionType === "payment" && amount >= 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "決済金額は負の値である必要があります",
      reason: `決済金額が正の値: ${amount}`,
      paymentId: undefined,
    });
  }

  // 各取引タイプの上限チェック
  const limits: Record<TransactionType, number> = {
    charge: 1000000, // チャージ上限: 100万円
    payment: 500000, // 決済上限: 50万円
    receive: 100000, // 受取上限: 10万円
    donation: 50000, // 寄付上限: 5万円
    expired: 0, // 期限切れ: 0
  };

  const limit = limits[transactionType];

  if (Math.abs(amount) > limit) {
    return err({
      type: "TRANSACTION_LIMIT_EXCEEDED",
      message: `${transactionType}の金額上限を超えています（上限: ${limit.toLocaleString()}円）`,
      limit,
      attempted: Math.abs(amount),
      limitType: "transaction",
    });
  }

  if (!Number.isInteger(amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引金額は整数である必要があります",
      reason: `小数点を含む金額: ${amount}`,
      paymentId: undefined,
    });
  }

  return ok(amount);
}

/**
 * 取引種別のバリデーション
 * @param type 取引種別
 * @returns バリデーション結果
 */
export function validateTransactionType(
  type: string,
): Result<TransactionType, BusinessError> {
  const validTypes: TransactionType[] = [
    "charge",
    "payment",
    "receive",
    "donation",
    "expired",
  ];

  if (!validTypes.includes(type as TransactionType)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "無効な取引種別です",
      reason: `サポートされていない取引種別: ${type}`,
      paymentId: undefined,
    });
  }

  return ok(type as TransactionType);
}

/**
 * エコ貢献のバリデーション
 * @param ecoContribution エコ貢献情報
 * @returns バリデーション結果
 */
export function validateEcoContribution(
  ecoContribution?: CreateTransactionParams["ecoContribution"],
): Result<EcoContribution | undefined, BusinessError> {
  if (!ecoContribution || !ecoContribution.enabled) {
    return ok(undefined);
  }

  if (ecoContribution.amount < 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "エコ貢献金額は0以上である必要があります",
      reason: `無効な金額: ${ecoContribution.amount}`,
      paymentId: undefined,
    });
  }

  if (!Number.isInteger(ecoContribution.amount)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "エコ貢献金額は整数である必要があります",
      reason: `小数点を含む金額: ${ecoContribution.amount}`,
      paymentId: undefined,
    });
  }

  const validatedEcoContribution: EcoContribution = {
    enabled: true,
    amount: ecoContribution.amount,
    project: ecoContribution.project,
  };

  return ok(validatedEcoContribution);
}

/**
 * 取引作成パラメータのバリデーション
 * @param params 取引作成パラメータ
 * @returns バリデーション結果
 */
export function validateCreateTransactionParams(
  params: CreateTransactionParams,
): Result<TransactionValidationResult, BusinessError> {
  const issues: string[] = [];

  // 取引種別のバリデーション
  const typeResult = validateTransactionType(params.type);
  if (typeResult.isErr()) {
    return err(typeResult.error);
  }

  // 金額のバリデーション
  const amountResult = validateTransactionAmount(params.amount, params.type);
  if (amountResult.isErr()) {
    return err(amountResult.error);
  }

  // 説明文のバリデーション
  if (!params.description || params.description.trim().length === 0) {
    issues.push("取引説明は必須です");
  } else if (params.description.length > 100) {
    issues.push("取引説明は100文字以内である必要があります");
  }

  // エコ貢献のバリデーション
  const ecoResult = validateEcoContribution(params.ecoContribution);
  if (ecoResult.isErr()) {
    return err(ecoResult.error);
  }

  if (issues.length > 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "バリデーションエラー",
      reason: issues.join(", "),
      paymentId: undefined,
    });
  }

  const result: TransactionValidationResult = {
    isValid: true,
    validatedAmount: amountResult.value,
    validatedType: typeResult.value,
    issues: [],
  };

  return ok(result);
}

/**
 * 取引を作成する
 * @param params 取引作成パラメータ
 * @returns 作成された取引
 */
export async function createTransaction(
  params: CreateTransactionParams,
): Promise<Result<Transaction, BusinessError>> {
  // バリデーション実行
  const validationResult = validateCreateTransactionParams(params);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  // エコ貢献のバリデーション
  const ecoResult = validateEcoContribution(params.ecoContribution);
  if (ecoResult.isErr()) {
    return err(ecoResult.error);
  }

  try {
    // API呼び出し用のリクエスト作成
    const createRequest: CreateTransactionRequest = {
      type: params.type,
      amount: params.amount,
      description: params.description,
      ecoContribution: ecoResult.value,
      campaignInfo: params.campaignInfo,
      splitInfo: params.splitInfo,
    };

    // API呼び出し
    const apiResult = await apiCreateTransaction(createRequest);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引作成に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    return ok(apiResult.value);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引作成中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 取引を更新する
 * @param params 取引更新パラメータ
 * @returns 更新された取引
 */
export async function updateTransaction(
  params: UpdateTransactionParams,
): Promise<Result<Transaction, BusinessError>> {
  if (!params.transactionId || params.transactionId.trim().length === 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引IDが無効です",
      reason: `空の取引ID: ${params.transactionId}`,
      paymentId: params.transactionId,
    });
  }

  // 説明文のバリデーション
  if (params.description !== undefined && params.description.length > 100) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引説明は100文字以内である必要があります",
      reason: `説明文が長すぎます: ${params.description.length}文字`,
      paymentId: params.transactionId,
    });
  }

  try {
    // API呼び出し用のリクエスト作成
    const updateRequest: UpdateTransactionRequest = {
      description: params.description,
      ecoContribution: params.ecoContribution,
      campaignInfo: params.campaignInfo,
      splitInfo: params.splitInfo,
    };

    // API呼び出し
    const apiResult = await apiUpdateTransaction(
      params.transactionId,
      updateRequest,
    );

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引更新に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: params.transactionId,
      });
    }

    return ok(apiResult.value);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引更新中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: params.transactionId,
    });
  }
}

/**
 * 取引を削除する
 * @param transactionId 取引ID
 * @returns 削除結果
 */
export async function deleteTransaction(
  transactionId: string,
): Promise<Result<void, BusinessError>> {
  if (!transactionId || transactionId.trim().length === 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引IDが無効です",
      reason: `空の取引ID: ${transactionId}`,
      paymentId: transactionId,
    });
  }

  try {
    const apiResult = await apiDeleteTransaction(transactionId);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引削除に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: transactionId,
      });
    }

    return ok(undefined);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引削除中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: transactionId,
    });
  }
}

/**
 * 取引一覧を取得する
 * @param params フィルターパラメータ
 * @returns 取引一覧
 */
export async function getTransactions(
  params: TransactionFilterParams = {},
): Promise<Result<TransactionsResponse, BusinessError>> {
  try {
    // API呼び出し用のパラメータ作成
    const fetchParams: FetchTransactionsParams = {
      userId: params.userId,
      type: params.type,
      dateFrom: params.dateFrom,
      dateTo: params.dateTo,
      limit: params.limit || 20,
      offset: params.offset || 0,
    };

    const apiResult = await apiFetchTransactions(fetchParams);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引一覧の取得に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    return ok(apiResult.value);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引一覧取得中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 取引統計を取得する
 * @param userId ユーザーID
 * @param period 期間
 * @returns 取引統計
 */
export async function getTransactionStats(
  userId?: string,
  period: "month" | "year" = "month",
): Promise<Result<TransactionStats, BusinessError>> {
  try {
    const apiResult = await apiFetchTransactionStats(userId, period);

    if (apiResult.isErr()) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引統計の取得に失敗しました",
        reason: "API呼び出しエラー",
        paymentId: undefined,
      });
    }

    return ok(apiResult.value);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引統計取得中に予期しないエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 取引集計を計算する
 * @param transactions 取引の配列
 * @returns 集計結果
 */
export function aggregateTransactions(
  transactions: Transaction[],
): Result<TransactionAggregation, BusinessError> {
  if (!Array.isArray(transactions)) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引データが無効です",
      reason: "配列ではない取引データ",
      paymentId: undefined,
    });
  }

  try {
    const totalAmount = transactions.reduce(
      (sum, t) => sum + Math.abs(t.amount),
      0,
    );
    const transactionCount = transactions.length;
    const averageAmount =
      transactionCount > 0 ? totalAmount / transactionCount : 0;

    // 種別別集計
    const byType: Record<TransactionType, number> = {
      charge: 0,
      payment: 0,
      receive: 0,
      donation: 0,
      expired: 0,
    };

    // 月別集計
    const byMonth: Record<string, number> = {};

    // エコ貢献集計
    let ecoContributionTotal = 0;
    let ecoContributionCount = 0;

    transactions.forEach((transaction) => {
      // 種別別
      byType[transaction.type] += Math.abs(transaction.amount);

      // 月別
      const month = transaction.date.substring(0, 7); // YYYY-MM形式
      byMonth[month] = (byMonth[month] || 0) + Math.abs(transaction.amount);

      // エコ貢献
      if (
        transaction.ecoContribution?.enabled &&
        transaction.ecoContribution.amount
      ) {
        ecoContributionTotal += transaction.ecoContribution.amount;
        ecoContributionCount++;
      }
    });

    const averageEcoPercentage =
      ecoContributionCount > 0 ? (ecoContributionTotal / totalAmount) * 100 : 0;

    const result: TransactionAggregation = {
      totalAmount,
      transactionCount,
      averageAmount,
      breakdown: {
        byType,
        byMonth,
      },
      ecoContribution: {
        totalAmount: ecoContributionTotal,
        averagePercentage: averageEcoPercentage,
        transactionCount: ecoContributionCount,
      },
    };

    return ok(result);
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "取引集計中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

/**
 * 取引の重複をチェックする
 * @param newTransaction 新しい取引
 * @param existingTransactions 既存の取引一覧
 * @param timeWindowMinutes 重複判定の時間窓（分）
 * @returns 重複チェック結果
 */
export function checkTransactionDuplicate(
  newTransaction: CreateTransactionParams,
  existingTransactions: Transaction[],
  timeWindowMinutes: number = 5,
): Result<
  { isDuplicate: boolean; duplicateTransaction?: Transaction },
  BusinessError
> {
  if (timeWindowMinutes <= 0) {
    return err({
      type: "PAYMENT_FAILED",
      message: "時間窓は0より大きい値である必要があります",
      reason: `無効な時間窓: ${timeWindowMinutes}`,
      paymentId: undefined,
    });
  }

  try {
    const now = new Date();
    const timeWindow = timeWindowMinutes * 60 * 1000; // ミリ秒に変換

    const duplicate = existingTransactions.find((existing) => {
      // 同じ種別・金額・説明の取引を検索
      if (
        existing.type !== newTransaction.type ||
        existing.amount !== newTransaction.amount ||
        existing.description !== newTransaction.description
      ) {
        return false;
      }

      // 時間窓内の取引かチェック
      const existingTime = new Date(existing.date);
      const timeDiff = Math.abs(now.getTime() - existingTime.getTime());

      return timeDiff <= timeWindow;
    });

    return ok({
      isDuplicate: !!duplicate,
      duplicateTransaction: duplicate,
    });
  } catch (error) {
    return err({
      type: "PAYMENT_FAILED",
      message: "重複チェック中にエラーが発生しました",
      reason: String(error),
      paymentId: undefined,
    });
  }
}

// テストコード（In Source Testing）
if (import.meta.vitest) {
  const { it, expect, describe } = import.meta.vitest;

  describe("validateTransactionAmount", () => {
    it("有効なチャージ金額の場合、成功を返す", () => {
      const result = validateTransactionAmount(1000, "charge");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe(1000);
    });

    it("チャージで0以下の金額の場合、エラーを返す", () => {
      const result = validateTransactionAmount(0, "charge");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("CHARGE_MINIMUM_NOT_MET");
    });

    it("上限を超える金額の場合、エラーを返す", () => {
      const result = validateTransactionAmount(2000000, "charge");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("TRANSACTION_LIMIT_EXCEEDED");
    });

    it("小数点の金額の場合、エラーを返す", () => {
      const result = validateTransactionAmount(100.5, "payment");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("validateTransactionType", () => {
    it("有効な取引種別の場合、成功を返す", () => {
      const result = validateTransactionType("payment");
      expect(result.isOk()).toBe(true);
      expect(result._unsafeUnwrap()).toBe("payment");
    });

    it("無効な取引種別の場合、エラーを返す", () => {
      const result = validateTransactionType("invalid_type");
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("validateCreateTransactionParams", () => {
    it("有効なパラメータの場合、成功を返す", () => {
      const params: CreateTransactionParams = {
        type: "payment",
        amount: -1000,
        description: "テスト決済",
      };
      const result = validateCreateTransactionParams(params);
      expect(result.isOk()).toBe(true);

      const validation = result._unsafeUnwrap();
      expect(validation.isValid).toBe(true);
      expect(validation.validatedAmount).toBe(-1000);
      expect(validation.validatedType).toBe("payment");
    });

    it("説明文が長すぎる場合、エラーを返す", () => {
      const params: CreateTransactionParams = {
        type: "payment",
        amount: -1000,
        description: "a".repeat(101), // 101文字
      };
      const result = validateCreateTransactionParams(params);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
    });
  });

  describe("aggregateTransactions", () => {
    it("取引を正しく集計する", () => {
      const transactions: Transaction[] = [
        {
          id: "txn_1",
          type: "payment",
          amount: -1000,
          description: "テスト1",
          date: "2025-01-15T10:00:00Z",
        },
        {
          id: "txn_2",
          type: "charge",
          amount: 2000,
          description: "テスト2",
          date: "2025-01-16T10:00:00Z",
        },
      ];

      const result = aggregateTransactions(transactions);
      expect(result.isOk()).toBe(true);

      const aggregation = result._unsafeUnwrap();
      expect(aggregation.totalAmount).toBe(3000);
      expect(aggregation.transactionCount).toBe(2);
      expect(aggregation.averageAmount).toBe(1500);
      expect(aggregation.breakdown.byType.payment).toBe(1000);
      expect(aggregation.breakdown.byType.charge).toBe(2000);
    });

    it("空の配列の場合、適切な結果を返す", () => {
      const result = aggregateTransactions([]);
      expect(result.isOk()).toBe(true);

      const aggregation = result._unsafeUnwrap();
      expect(aggregation.totalAmount).toBe(0);
      expect(aggregation.transactionCount).toBe(0);
      expect(aggregation.averageAmount).toBe(0);
    });
  });

  describe("checkTransactionDuplicate", () => {
    it("重複なしの場合、適切な結果を返す", () => {
      const newTransaction: CreateTransactionParams = {
        type: "payment",
        amount: -1000,
        description: "テスト決済",
      };

      const existingTransactions: Transaction[] = [
        {
          id: "txn_1",
          type: "charge",
          amount: 2000,
          description: "別の取引",
          date: new Date().toISOString(),
        },
      ];

      const result = checkTransactionDuplicate(
        newTransaction,
        existingTransactions,
      );
      expect(result.isOk()).toBe(true);

      const check = result._unsafeUnwrap();
      expect(check.isDuplicate).toBe(false);
      expect(check.duplicateTransaction).toBeUndefined();
    });
  });
}
</file>

<file path="src/lib/utils/eco/calculations.ts">
/**
 * 環境貢献計算に関する関数
 */
import {
  EcoRank,
  ContributionParams,
  EcoState,
  EcoIndicator,
  EcoImpact,
} from "./types";

/**
 * 環境貢献ランクを決定する
 * @param totalDonation 累計寄付額
 * @returns エコランク
 */
export function determineEcoRank(totalDonation: number): EcoRank {
  if (totalDonation >= 50000) return "エコチャンピオン";
  if (totalDonation >= 20000) return "エコマイスター";
  if (totalDonation >= 5000) return "エコサポーター";
  return "エコビギナー";
}

/**
 * 環境貢献目標に対する進捗率を計算する
 * @param current 現在の値
 * @param target 目標値
 * @returns 進捗率（0-100）
 */
export function calculateProgressPercent(
  current: number,
  target: number,
): number {
  return Math.min(100, Math.max(0, Math.round((current / target) * 100)));
}

/**
 * 複数の環境指標の平均進捗率を計算する
 * @param indicators 指標の配列 { current, target }
 * @returns 平均進捗率
 */
export function calculateAverageProgress(
  indicators: Array<EcoIndicator>,
): number {
  if (indicators.length === 0) return 0;

  const totalProgress = indicators.reduce((sum, indicator) => {
    return sum + calculateProgressPercent(indicator.current, indicator.target);
  }, 0);

  return Math.round(totalProgress / indicators.length);
}

/**
 * 環境貢献インパクトを計算する
 * @param amount 金額
 * @returns 環境貢献データ
 */
export function calculateEcoImpact(amount: number): EcoImpact {
  return {
    forestArea: Number((amount * 0.0005).toFixed(2)), // 1000円で0.5m²
    waterSaved: Math.round(amount * 0.25), // 1000円で250L
    co2Reduction: Number((amount * 0.0125).toFixed(1)), // 1000円で12.5kg
  };
}

/**
 * 貢献データを計算する
 * @param state 現在の環境貢献状態
 * @param params 追加貢献のパラメータ
 * @returns 更新された環境貢献状態
 */
export function calculateContribution(
  state: EcoState,
  params: ContributionParams,
): Partial<EcoState> {
  const impact = calculateEcoImpact(params.amount);

  const newForestArea =
    state.forestArea + (params.forestArea || impact.forestArea);
  const newWaterSaved =
    state.waterSaved + (params.waterSaved || impact.waterSaved);
  const newCo2Reduction =
    state.co2Reduction + (params.co2Reduction || impact.co2Reduction);

  // 寄付総額の更新
  const newTotalDonation = state.totalDonation + params.amount;
  const newMonthlyDonation = state.monthlyDonation + params.amount;

  return {
    forestArea: newForestArea,
    waterSaved: newWaterSaved,
    co2Reduction: newCo2Reduction,
    totalDonation: newTotalDonation,
    monthlyDonation: newMonthlyDonation,
  };
}

/**
 * 環境貢献の進捗を計算する
 */
export function calculateEcoProgress(
  forestArea: number,
  waterSaved: number,
  co2Reduction: number,
  targetForestArea: number,
  targetWaterSaved: number,
  targetCo2Reduction: number,
): number {
  // 指標の配列を作成
  const indicators = [
    { current: forestArea, target: targetForestArea },
    { current: waterSaved, target: targetWaterSaved },
    { current: co2Reduction, target: targetCo2Reduction },
  ];

  return calculateAverageProgress(indicators);
}

/**
 * 環境ランクを取得する
 */
export function getEcoRankFromDonation(totalDonation: number): EcoRank {
  return determineEcoRank(totalDonation);
}
</file>

<file path="src/lib/utils/eco/index.ts">
/**
 * 環境貢献関連ユーティリティのインデックス
 * 他のモジュールからのインポートはこのファイル経由で行う
 */

// 型定義のエクスポート
export * from "./types";

// 計算関数のエクスポート
export * from "./calculations";
</file>

<file path="src/lib/utils/eco/types.ts">
/**
 * 環境貢献に関する型定義
 */

/**
 * 環境貢献ランクの定義
 */
export type EcoRank =
  | "エコビギナー"
  | "エコサポーター"
  | "エコマイスター"
  | "エコチャンピオン";

/**
 * 環境指標の型定義
 */
export interface EcoIndicator {
  current: number;
  target: number;
}

/**
 * 貢献パラメータの型定義
 */
export interface ContributionParams {
  amount: number;
  forestArea?: number;
  waterSaved?: number;
  co2Reduction?: number;
}

/**
 * 環境貢献状態の型定義
 */
export interface EcoState {
  forestArea: number;
  waterSaved: number;
  co2Reduction: number;
  totalDonation: number;
  monthlyDonation: number;
}

/**
 * 環境貢献インパクトの型定義
 */
export interface EcoImpact {
  forestArea: number;
  waterSaved: number;
  co2Reduction: number;
}
</file>

<file path="src/lib/utils/transactions/filtering.ts">
/**
 * トランザクションのフィルタリングと集計に関する関数
 */
import { Transaction, TransactionType } from "./types";

/**
 * 日付範囲で取引をフィルタリング
 * @param transactions トランザクション配列
 * @param startDate 開始日（文字列）
 * @param endDate 終了日（文字列）
 * @returns 日付範囲内のトランザクション配列
 */
export function filterTransactionsByDateRange(
  transactions: Transaction[],
  startDate: string,
  endDate: string,
): Transaction[] {
  const start = new Date(startDate);
  const end = new Date(endDate);

  return transactions.filter((transaction) => {
    const transactionDate = new Date(transaction.date);
    return transactionDate >= start && transactionDate <= end;
  });
}

/**
 * タイプによる取引のフィルタリング
 * @param transactions トランザクション配列
 * @param type トランザクションタイプ
 * @returns 指定されたタイプのトランザクション配列
 */
export function filterTransactionsByType(
  transactions: Transaction[],
  type: TransactionType,
): Transaction[] {
  return transactions.filter((transaction) => transaction.type === type);
}

/**
 * 最近の取引を取得
 * @param transactions トランザクション配列
 * @param limit 取得する件数（デフォルト: 5）
 * @returns 最近の取引（配列の先頭から指定件数）
 */
export function getRecentTransactions(
  transactions: Transaction[],
  limit: number = 5,
): Transaction[] {
  return transactions.slice(0, limit);
}

/**
 * 環境貢献のある取引のフィルタリング
 * @param transactions トランザクション配列
 * @returns 環境貢献が有効なトランザクション配列
 */
export function filterTransactionsWithEcoContribution(
  transactions: Transaction[],
): Transaction[] {
  return transactions.filter(
    (transaction) => transaction.ecoContribution?.enabled,
  );
}

/**
 * 環境貢献の合計額を計算
 * @param transactions トランザクション配列
 * @returns 環境貢献の合計金額
 */
export function calculateTotalEcoContribution(
  transactions: Transaction[],
): number {
  return transactions
    .filter((transaction) => transaction.ecoContribution?.enabled)
    .reduce(
      (total, transaction) =>
        total + (transaction.ecoContribution?.amount || 0),
      0,
    );
}
</file>

<file path="src/lib/utils/transactions/index.ts">
/**
 * トランザクション関連ユーティリティのインデックス
 * 他のモジュールからのインポートはこのファイル経由で行う
 */

// 型定義のエクスポート
export * from "./types";

// スタイリング関連のエクスポート
export * from "./styling";

// UIコンポーネント関連のエクスポート
export * from "./ui";

// フィルタリング関連のエクスポート
export * from "./filtering";
</file>

<file path="src/lib/utils/transactions/styling.ts">
/**
 * トランザクションのスタイリングに関する関数
 */
import { TransactionType, TransactionStyleConfig } from "./types";

/**
 * トランザクションタイプに基づいたスタイル設定を取得する(アイコンなし)
 * @param type トランザクションタイプ
 * @param badges オプションのバッジ配列
 * @returns スタイル設定オブジェクト
 */
export function getTransactionStyleConfig(
  type: TransactionType,
  badges?: string[],
): TransactionStyleConfig {
  // 期限切れや特典バッジがある場合、優先的に特別スタイルを適用
  if (badges?.includes("期限切れ")) {
    return {
      iconType: "clock",
      bgColor: "bg-red-50",
      textColor: "text-red-600",
      borderColor: "border-red-100",
    };
  }

  if (badges?.includes("特典")) {
    return {
      iconType: "gift",
      bgColor: "bg-amber-50",
      textColor: "text-amber-600",
      borderColor: "border-amber-100",
    };
  }

  // トランザクションタイプに基づいたデフォルトスタイル
  switch (type) {
    case "payment":
      return {
        iconType: "arrow-up",
        bgColor: "bg-stone-50",
        textColor: "text-stone-800",
        borderColor: "border-stone-100",
      };
    case "charge":
      return {
        iconType: "arrow-down",
        bgColor: "bg-green-50",
        textColor: "text-green-600",
        borderColor: "border-green-100",
      };
    case "receive":
      return {
        iconType: "arrow-down",
        bgColor: "bg-blue-50",
        textColor: "text-blue-600",
        borderColor: "border-blue-100",
      };
    case "expired":
      return {
        iconType: "clock",
        bgColor: "bg-red-50",
        textColor: "text-red-600",
        borderColor: "border-red-100",
      };
    case "donation":
      return {
        iconType: "leaf",
        bgColor: "bg-teal-50",
        textColor: "text-teal-600",
        borderColor: "border-teal-100",
      };
    default:
      return {
        iconType: "info",
        bgColor: "bg-stone-50",
        textColor: "text-stone-800",
        borderColor: "border-stone-100",
      };
  }
}
</file>

<file path="src/lib/utils/transactions/types.ts">
/**
 * トランザクション関連の型定義
 */
import React from "react";

/**
 * トランザクションタイプの定義
 */
export type TransactionType =
  | "payment"
  | "charge"
  | "receive"
  | "donation"
  | "expired";

/**
 * トランザクションインターフェース
 */
export interface Transaction {
  id: string;
  type: TransactionType;
  description: string;
  date: string;
  amount: number;
  ecoContribution?: {
    enabled: boolean;
    amount: number;
  };
  badges?: string[];
}

/**
 * トランザクションのスタイル設定インターフェース
 */
export interface TransactionStyleConfig {
  iconType: string;
  bgColor: string;
  textColor: string;
  borderColor: string;
}

/**
 * トランザクションスタイル（アイコン含む）インターフェース
 */
export interface TransactionStyle {
  icon: React.ReactNode;
  bgColor: string;
  textColor: string;
  borderColor: string;
}
</file>

<file path="src/lib/utils/transactions/ui.tsx">
/**
 * トランザクションのUIスタイリングに関する関数
 */
import React from "react";
import { ArrowUp, ArrowDown, Leaf, Clock, Gift, Info } from "lucide-react";
import { TransactionType, TransactionStyle } from "./types";
import { getTransactionStyleConfig } from "./styling";

/**
 * トランザクションタイプに基づいたスタイルとアイコンを取得する
 * @param type トランザクションタイプ
 * @param badges オプションのバッジ配列
 * @returns スタイル設定とアイコンを含むオブジェクト
 */
export function getTransactionStyle(
  type: TransactionType,
  badges?: string[],
): TransactionStyle {
  const styleConfig = getTransactionStyleConfig(type, badges);

  // スタイル設定に基づいてアイコンを生成
  let icon: React.ReactNode;

  switch (styleConfig.iconType) {
    case "arrow-up":
      icon = <ArrowUp className="h-5 w-5 text-stone-500" />;
      break;
    case "arrow-down":
      if (styleConfig.textColor === "text-green-600") {
        icon = <ArrowDown className="h-5 w-5 text-green-500" />;
      } else {
        icon = <ArrowDown className="h-5 w-5 text-blue-500" />;
      }
      break;
    case "leaf":
      icon = <Leaf className="h-5 w-5 text-teal-500" />;
      break;
    case "clock":
      icon = <Clock className="h-5 w-5 text-red-500" />;
      break;
    case "gift":
      icon = <Gift className="h-5 w-5 text-amber-500" />;
      break;
    default:
      icon = <Info className="h-5 w-5 text-stone-500" />;
      break;
  }

  return {
    icon,
    bgColor: styleConfig.bgColor,
    textColor: styleConfig.textColor,
    borderColor: styleConfig.borderColor,
  };
}
</file>

<file path="src/lib/utils/balance-utils.ts">
/**
 * バランス関連の計算ユーティリティ関数
 */

/**
 * キャンペーン残高の型定義
 */
export type CampaignBalance = {
  id: number;
  amount: number;
  label: string;
  expiryDate: string;
  daysLeft: number;
  conditions?: string;
};

/**
 * 通常残高とキャンペーン残高から合計残高を計算する
 */
export const calculateTotalBalance = (
  regularBalance: number,
  campaignBalances: CampaignBalance[],
): number => {
  const campaignTotal = campaignBalances.reduce(
    (sum, cb) => sum + cb.amount,
    0,
  );
  return regularBalance + campaignTotal;
};
</file>

<file path="src/lib/utils/error-utils.ts">
/**
 * エラーハンドリングユーティリティ
 *
 * このファイルは、AppError型のエラーを処理するためのユーティリティ関数を提供します。
 * エラーメッセージの国際化、重要度判定、ログ出力などの機能を含みます。
 */

import {
  AppError,
  ErrorSeverity,
  ErrorContext,
  ExtendedError,
} from "@/shared/types/errors";

/**
 * エラーをユーザー向けメッセージに変換
 *
 * @param error - 変換対象のAppError
 * @returns ユーザー向けのエラーメッセージ
 */
export function getErrorMessage(error: AppError): string {
  switch (error.type) {
    // ValidationError
    case "INVALID_EMAIL":
      return "有効なメールアドレスを入力してください";
    case "INVALID_AMOUNT":
      return error.message || "有効な金額を入力してください";
    case "REQUIRED_FIELD":
      return `${error.field}は必須項目です`;
    case "INVALID_FORMAT":
      return `${error.field}の形式が正しくありません。期待される形式: ${error.expected}`;
    case "INVALID_PASSWORD":
      return error.message || "パスワードの形式が正しくありません";
    case "PASSWORD_MISMATCH":
      return "パスワードが一致しません";
    case "INVALID_RANGE":
      return `${error.field}は${error.min}から${error.max}の範囲で入力してください（入力値: ${error.actual}）`;

    // ApiError
    case "NETWORK_ERROR":
      return "ネットワークエラーが発生しました。接続を確認してください。";
    case "SERVER_ERROR":
      return "サーバーエラーが発生しました。しばらく時間をおいて再試行してください。";
    case "TIMEOUT_ERROR":
      return "リクエストがタイムアウトしました。再度お試しください。";
    case "UNAUTHORIZED":
      return "ログインが必要です。再度ログインしてください。";
    case "FORBIDDEN":
      return "この操作を実行する権限がありません。";
    case "NOT_FOUND":
      return error.resource
        ? `${error.resource}が見つかりません`
        : "リソースが見つかりません";
    case "CONFLICT":
      return "競合が発生しました。データを更新してから再試行してください。";
    case "RATE_LIMIT_EXCEEDED":
      return error.retryAfter
        ? `リクエスト制限に達しました。${error.retryAfter}秒後に再試行してください。`
        : "リクエスト制限に達しました。しばらく時間をおいて再試行してください。";
    case "BAD_REQUEST":
      return error.message || "リクエストが正しくありません";

    // BusinessError
    case "INSUFFICIENT_BALANCE":
      return `残高が不足しています。必要額: ¥${error.required.toLocaleString()}、利用可能額: ¥${error.available.toLocaleString()}`;
    case "PAYMENT_FAILED":
      return `決済に失敗しました。理由: ${error.reason}`;
    case "TRANSACTION_LIMIT_EXCEEDED":
      return `${error.limitType === "daily" ? "日次" : error.limitType === "monthly" ? "月次" : "取引"}限度額を超えています。限度額: ¥${error.limit.toLocaleString()}、試行額: ¥${error.attempted.toLocaleString()}`;
    case "CAMPAIGN_NOT_ACTIVE":
      return "このキャンペーンは現在利用できません";
    case "DONATION_LIMIT_EXCEEDED":
      return `寄付限度額を超えています。最大寄付額: ¥${error.maxDonationAmount.toLocaleString()}、要求額: ¥${error.requestedAmount.toLocaleString()}`;
    case "ACCOUNT_SUSPENDED":
      return error.suspendedUntil
        ? `アカウントが${error.suspendedUntil.toLocaleDateString()}まで一時停止されています。理由: ${error.reason}`
        : `アカウントが一時停止されています。理由: ${error.reason}`;
    case "KYC_REQUIRED":
      return `本人確認が必要です。${error.requiredLevel === "basic" ? "基本" : "詳細"}認証を完了してください。`;
    case "CHARGE_MINIMUM_NOT_MET":
      return `最小チャージ額を満たしていません。最小額: ¥${error.minimum.toLocaleString()}、入力額: ¥${error.requested.toLocaleString()}`;
    case "INVALID_QR_CODE":
      return "QRコードが無効です。正しいQRコードを読み込んでください。";
    case "TRANSFER_TO_SELF":
      return "自分自身への送金はできません";

    default:
      // TypeScriptのexhaustive checkのため、この行は実行されないはず
      return "エラーが発生しました";
  }
}

/**
 * エラーの重要度を判定
 *
 * @param error - 判定対象のAppError
 * @returns エラーの重要度レベル
 */
export function getErrorSeverity(error: AppError): ErrorSeverity {
  switch (error.type) {
    // Low severity - ユーザー入力エラー、軽微な問題
    case "INVALID_EMAIL":
    case "INVALID_AMOUNT":
    case "REQUIRED_FIELD":
    case "INVALID_FORMAT":
    case "INVALID_PASSWORD":
    case "PASSWORD_MISMATCH":
    case "INVALID_RANGE":
    case "CHARGE_MINIMUM_NOT_MET":
    case "INVALID_QR_CODE":
    case "TRANSFER_TO_SELF":
      return "low";

    // Medium severity - 一時的な問題、再試行で解決可能
    case "NETWORK_ERROR":
    case "TIMEOUT_ERROR":
    case "NOT_FOUND":
    case "CONFLICT":
    case "BAD_REQUEST":
    case "INSUFFICIENT_BALANCE":
    case "CAMPAIGN_NOT_ACTIVE":
    case "DONATION_LIMIT_EXCEEDED":
    case "TRANSACTION_LIMIT_EXCEEDED":
      return "medium";

    // High severity - 重要な機能の障害、即座の対応が必要
    case "SERVER_ERROR":
    case "PAYMENT_FAILED":
    case "RATE_LIMIT_EXCEEDED":
      return "high";

    // Critical severity - セキュリティ関連、アカウント制限
    case "UNAUTHORIZED":
    case "FORBIDDEN":
    case "ACCOUNT_SUSPENDED":
    case "KYC_REQUIRED":
      return "critical";

    default:
      return "medium";
  }
}

/**
 * エラーが再試行可能かどうかを判定
 *
 * @param error - 判定対象のAppError
 * @returns 再試行可能な場合true
 */
export function isRetryableError(error: AppError): boolean {
  switch (error.type) {
    case "NETWORK_ERROR":
    case "TIMEOUT_ERROR":
    case "SERVER_ERROR":
    case "CONFLICT":
      return true;
    case "RATE_LIMIT_EXCEEDED":
      return true; // 時間をおいて再試行可能
    default:
      return false;
  }
}

/**
 * エラーからHTTPステータスコードを推定
 *
 * @param error - 対象のAppError
 * @returns 対応するHTTPステータスコード
 */
export function getHttpStatusFromError(error: AppError): number {
  switch (error.type) {
    case "UNAUTHORIZED":
      return 401;
    case "FORBIDDEN":
    case "KYC_REQUIRED":
      return 403;
    case "NOT_FOUND":
      return 404;
    case "CONFLICT":
      return 409;
    case "RATE_LIMIT_EXCEEDED":
      return 429;
    case "INVALID_EMAIL":
    case "INVALID_AMOUNT":
    case "REQUIRED_FIELD":
    case "INVALID_FORMAT":
    case "INVALID_PASSWORD":
    case "PASSWORD_MISMATCH":
    case "INVALID_RANGE":
    case "CHARGE_MINIMUM_NOT_MET":
    case "INVALID_QR_CODE":
    case "TRANSFER_TO_SELF":
    case "BAD_REQUEST":
      return 400;
    case "SERVER_ERROR":
      return 500;
    case "TIMEOUT_ERROR":
      return 504;
    default:
      return 500;
  }
}

/**
 * エラーコンテキストを作成
 *
 * @param userId - ユーザーID
 * @param transactionId - トランザクションID
 * @param additionalContext - 追加のコンテキスト情報
 * @returns エラーコンテキスト
 */
export function createErrorContext(
  userId?: string,
  transactionId?: string,
  additionalContext?: Partial<ErrorContext>,
): ErrorContext {
  return {
    userId,
    transactionId,
    timestamp: new Date(),
    userAgent:
      typeof navigator !== "undefined" ? navigator.userAgent : undefined,
    url: typeof window !== "undefined" ? window.location.href : undefined,
    sessionId:
      typeof window !== "undefined"
        ? sessionStorage.getItem("sessionId") || undefined
        : undefined,
    ...additionalContext,
  };
}

/**
 * 拡張エラー情報を作成
 *
 * @param error - AppError
 * @param context - エラーコンテキスト
 * @param stackTrace - スタックトレース
 * @returns 拡張エラー情報
 */
export function createExtendedError(
  error: AppError,
  context?: ErrorContext,
  stackTrace?: string,
): ExtendedError {
  return {
    error,
    severity: getErrorSeverity(error),
    context: context || createErrorContext(),
    stackTrace,
  };
}

/**
 * エラーをログ出力（開発環境のみ）
 *
 * @param error - AppError
 * @param context - エラーコンテキスト
 */
export function logError(error: AppError, context?: ErrorContext): void {
  if (process.env.NODE_ENV !== "development") {
    return;
  }

  const severity = getErrorSeverity(error);
  const message = getErrorMessage(error);
  const extendedError = createExtendedError(error, context);

  console.group(`🚫 Error (${severity.toUpperCase()})`);
  console.error("Message:", message);
  console.error("Error Details:", error);
  console.error("Context:", extendedError.context);

  if (extendedError.stackTrace) {
    console.error("Stack Trace:", extendedError.stackTrace);
  }

  console.groupEnd();
}

/**
 * バリデーションエラーの詳細メッセージを生成
 *
 * @param errors - バリデーションエラーの配列
 * @returns 結合されたエラーメッセージ
 */
export function formatValidationErrors(errors: AppError[]): string {
  const validationErrors = errors.filter((error) =>
    [
      "INVALID_EMAIL",
      "INVALID_AMOUNT",
      "REQUIRED_FIELD",
      "INVALID_FORMAT",
      "INVALID_PASSWORD",
      "PASSWORD_MISMATCH",
      "INVALID_RANGE",
    ].includes(error.type),
  );

  if (validationErrors.length === 0) {
    return "バリデーションエラーが発生しました";
  }

  if (validationErrors.length === 1) {
    return getErrorMessage(validationErrors[0]);
  }

  return `以下のエラーを修正してください:\n${validationErrors
    .map((error, index) => `${index + 1}. ${getErrorMessage(error)}`)
    .join("\n")}`;
}

if (import.meta.vitest) {
  const { test, expect, describe } = import.meta.vitest;

  describe("getErrorMessage", () => {
    test("INVALID_EMAIL returns appropriate message", () => {
      const error = {
        type: "INVALID_EMAIL",
        message: "Invalid email",
        field: "email",
      } as const;
      expect(getErrorMessage(error)).toBe(
        "有効なメールアドレスを入力してください",
      );
    });

    test("INSUFFICIENT_BALANCE returns formatted message with amounts", () => {
      const error = {
        type: "INSUFFICIENT_BALANCE",
        message: "Not enough balance",
        required: 1000,
        available: 500,
      } as const;
      expect(getErrorMessage(error)).toBe(
        "残高が不足しています。必要額: ¥1,000、利用可能額: ¥500",
      );
    });

    test("REQUIRED_FIELD returns field-specific message", () => {
      const error = {
        type: "REQUIRED_FIELD",
        message: "Field required",
        field: "username",
      } as const;
      expect(getErrorMessage(error)).toBe("usernameは必須項目です");
    });
  });

  describe("getErrorSeverity", () => {
    test("validation errors have low severity", () => {
      const error = {
        type: "INVALID_EMAIL",
        message: "Invalid email",
        field: "email",
      } as const;
      expect(getErrorSeverity(error)).toBe("low");
    });

    test("security errors have critical severity", () => {
      const error = {
        type: "UNAUTHORIZED",
        message: "Not authorized",
      } as const;
      expect(getErrorSeverity(error)).toBe("critical");
    });

    test("server errors have high severity", () => {
      const error = {
        type: "SERVER_ERROR",
        message: "Server error",
        statusCode: 500,
      } as const;
      expect(getErrorSeverity(error)).toBe("high");
    });
  });

  describe("isRetryableError", () => {
    test("network errors are retryable", () => {
      const error = {
        type: "NETWORK_ERROR",
        message: "Network failed",
      } as const;
      expect(isRetryableError(error)).toBe(true);
    });

    test("validation errors are not retryable", () => {
      const error = {
        type: "INVALID_EMAIL",
        message: "Invalid email",
        field: "email",
      } as const;
      expect(isRetryableError(error)).toBe(false);
    });
  });

  describe("getHttpStatusFromError", () => {
    test("returns correct status codes", () => {
      expect(
        getHttpStatusFromError({
          type: "UNAUTHORIZED",
          message: "Unauthorized",
        }),
      ).toBe(401);
      expect(
        getHttpStatusFromError({ type: "NOT_FOUND", message: "Not found" }),
      ).toBe(404);
      expect(
        getHttpStatusFromError({
          type: "SERVER_ERROR",
          message: "Server error",
          statusCode: 500,
        }),
      ).toBe(500);
    });
  });
}
</file>

<file path="src/lib/utils/result-utils.ts">
/**
 * Result型ユーティリティ
 *
 * このファイルは、neverthrowのResult型を扱うためのユーティリティ関数を提供します。
 * デバッグ用関数、変換関数、アダプター関数などが含まれます。
 */

import { Result, ok, err, ResultAsync } from "neverthrow";
import { AppError, ErrorContext } from "@/shared/types/errors";
import { getErrorMessage, logError, createErrorContext } from "./error-utils";

/**
 * Result型のデバッグ用ユーティリティ
 * 開発環境でResult型の値をコンソールに出力します
 *
 * @param result - デバッグ対象のResult
 * @param label - ログのラベル
 * @returns 元のResultをそのまま返す（チェーン可能）
 */
export function debugResult<T, E>(
  result: Result<T, E>,
  label: string,
): Result<T, E> {
  if (process.env.NODE_ENV === "development") {
    result.match(
      (value) => console.log(`${label} - Success:`, value),
      (error) => console.log(`${label} - Error:`, error),
    );
  }
  return result;
}

/**
 * ResultAsync型のデバッグ用ユーティリティ
 *
 * @param resultAsync - デバッグ対象のResultAsync
 * @param label - ログのラベル
 * @returns 元のResultAsyncをそのまま返す（チェーン可能）
 */
export function debugResultAsync<T, E>(
  resultAsync: ResultAsync<T, E>,
  label: string,
): ResultAsync<T, E> {
  if (process.env.NODE_ENV === "development") {
    return resultAsync
      .map((value) => {
        console.log(`${label} - Success:`, value);
        return value;
      })
      .mapErr((error) => {
        console.log(`${label} - Error:`, error);
        return error;
      });
  }
  return resultAsync;
}

/**
 * 複数のResultを組み合わせて、すべてが成功した場合のみ成功を返す
 *
 * @param results - Result型の配列
 * @returns すべて成功の場合は成功値の配列、一つでも失敗があれば最初のエラー
 */
export function combineResults<T, E>(results: Result<T, E>[]): Result<T[], E> {
  const values: T[] = [];

  for (const result of results) {
    if (result.isErr()) {
      return err(result.error);
    }
    values.push(result.value);
  }

  return ok(values);
}

/**
 * 複数のResultを組み合わせて、すべてのエラーを収集する
 *
 * @param results - Result型の配列
 * @returns すべて成功の場合は成功値の配列、エラーがある場合はすべてのエラーの配列
 */
export function combineResultsWithAllErrors<T, E>(
  results: Result<T, E>[],
): Result<T[], E[]> {
  const values: T[] = [];
  const errors: E[] = [];

  for (const result of results) {
    if (result.isErr()) {
      errors.push(result.error);
    } else {
      values.push(result.value);
    }
  }

  return errors.length > 0 ? err(errors) : ok(values);
}

/**
 * Promise<T>をResultAsync<T, AppError>に変換
 *
 * @param promise - 変換対象のPromise
 * @param errorMapper - エラーをAppErrorに変換する関数
 * @returns ResultAsync
 */
export function fromPromise<T>(
  promise: Promise<T>,
  errorMapper: (error: unknown) => AppError,
): ResultAsync<T, AppError> {
  return ResultAsync.fromPromise(promise, errorMapper);
}

/**
 * 従来の{ isValid: boolean; reason?: string }パターンをResult型に変換するアダプター
 *
 * @param legacyResult - 従来のパターンの結果
 * @param successValue - 成功時の値
 * @param errorType - エラー時のAppError type
 * @param field - エラーが発生したフィールド名
 * @returns Result型
 */
export function fromLegacyValidation<T>(
  legacyResult: { isValid: boolean; reason?: string },
  successValue: T,
  errorType: AppError["type"] = "INVALID_FORMAT",
  field: string = "unknown",
): Result<T, AppError> {
  if (legacyResult.isValid) {
    return ok(successValue);
  }

  // エラー型に応じて適切なAppErrorを生成
  const errorMessage = legacyResult.reason || "バリデーションエラー";

  switch (errorType) {
    case "INVALID_EMAIL":
      return err({
        type: "INVALID_EMAIL",
        message: errorMessage,
        field: "email",
      });
    case "INVALID_AMOUNT":
      return err({
        type: "INVALID_AMOUNT",
        message: errorMessage,
        field: "amount",
      });
    case "REQUIRED_FIELD":
      return err({
        type: "REQUIRED_FIELD",
        message: errorMessage,
        field,
      });
    default:
      return err({
        type: "INVALID_FORMAT",
        message: errorMessage,
        field,
        expected: "valid format",
      });
  }
}

/**
 * Result型を従来の{ isValid: boolean; reason?: string }パターンに変換するアダプター
 * 段階的移行時の互換性のために使用
 *
 * @param result - Result型
 * @returns 従来のパターンの結果
 */
export function toLegacyValidation<T>(result: Result<T, AppError>): {
  isValid: boolean;
  reason?: string;
} {
  return result.match(
    () => ({ isValid: true }),
    (error) => ({ isValid: false, reason: getErrorMessage(error) }),
  );
}

/**
 * Result型をPromiseに変換（従来のasync/await互換のため）
 *
 * @param result - Result型
 * @returns Promise（エラーの場合はreject）
 */
export function toPromise<T>(result: Result<T, AppError>): Promise<T> {
  return result.match(
    (value) => Promise.resolve(value),
    (error) => Promise.reject(new Error(getErrorMessage(error))),
  );
}

/**
 * ResultAsync型をPromiseに変換
 *
 * @param resultAsync - ResultAsync型
 * @returns Promise（エラーの場合はreject）
 */
export function resultAsyncToPromise<T>(
  resultAsync: ResultAsync<T, AppError>,
): Promise<T> {
  return resultAsync.match(
    (value) => value,
    (error) => {
      throw new Error(getErrorMessage(error));
    },
  );
}

/**
 * 条件に基づいてResultを生成
 *
 * @param condition - 判定条件
 * @param successValue - 成功時の値
 * @param errorValue - 失敗時のエラー
 * @returns Result型
 */
export function fromCondition<T, E>(
  condition: boolean,
  successValue: T,
  errorValue: E,
): Result<T, E> {
  return condition ? ok(successValue) : err(errorValue);
}

/**
 * 配列の各要素にResult型を返す関数を適用し、すべて成功した場合のみ成功を返す
 *
 * @param array - 処理対象の配列
 * @param fn - 各要素に適用する関数
 * @returns Result型
 */
export function mapArrayToResult<T, U, E>(
  array: T[],
  fn: (item: T, index: number) => Result<U, E>,
): Result<U[], E> {
  const results = array.map(fn);
  return combineResults(results);
}

/**
 * Result型の値が条件を満たすかチェック
 *
 * @param result - チェック対象のResult
 * @param predicate - チェック条件
 * @param errorValue - 条件を満たさない場合のエラー
 * @returns Result型
 */
export function filterResult<T, E>(
  result: Result<T, E>,
  predicate: (value: T) => boolean,
  errorValue: E,
): Result<T, E> {
  return result.andThen((value) =>
    predicate(value) ? ok(value) : err(errorValue),
  );
}

/**
 * Result型のエラーをログ出力して元のResultを返す（副作用のみ）
 *
 * @param result - Result型
 * @param context - エラーコンテキスト
 * @returns 元のResultをそのまま返す
 */
export function logErrorAndReturn<T>(
  result: Result<T, AppError>,
  context?: Partial<ErrorContext>,
): Result<T, AppError> {
  result.mapErr((error) => {
    const fullContext = context
      ? createErrorContext(context.userId, context.transactionId, context)
      : undefined;
    logError(error, fullContext);
    return error;
  });
  return result;
}

/**
 * 複数のResult型の値を並列で処理（Promise.allのResult版）
 *
 * @param results - ResultAsync型の配列
 * @returns すべて成功した場合は成功値の配列、一つでも失敗があれば最初のエラー
 */
export function combineResultsAsync<T, E>(
  results: ResultAsync<T, E>[],
): ResultAsync<T[], E> {
  return ResultAsync.combine(results);
}

/**
 * タイムアウト付きのResultAsync実行
 *
 * @param resultAsync - 実行するResultAsync
 * @param timeoutMs - タイムアウト時間（ミリ秒）
 * @param timeoutError - タイムアウト時のエラー
 * @returns Result型（タイムアウト時はエラー）
 */
export function withTimeout<T, E>(
  resultAsync: ResultAsync<T, E>,
  timeoutMs: number,
  timeoutError: E,
): ResultAsync<T, E> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(timeoutError), timeoutMs);
  });

  return ResultAsync.fromPromise(
    Promise.race([
      resultAsync.match(
        (value) => Promise.resolve(value),
        (error) => Promise.reject(error),
      ),
      timeoutPromise,
    ]),
    (error) => error as E,
  );
}

if (import.meta.vitest) {
  const { test, expect, describe } = import.meta.vitest;

  describe("combineResults", () => {
    test("combines successful results", () => {
      const results = [ok(1), ok(2), ok(3)];
      const combined = combineResults(results);

      expect(combined.isOk()).toBe(true);
      expect(combined.unwrapOr([])).toEqual([1, 2, 3]);
    });

    test("returns first error when any result fails", () => {
      const results = [ok(1), err("error1"), err("error2")];
      const combined = combineResults(results);

      expect(combined.isErr()).toBe(true);
      if (combined.isErr()) {
        expect(combined.error).toBe("error1");
      }
    });
  });

  describe("fromLegacyValidation", () => {
    test("converts valid legacy result to Ok", () => {
      const legacy = { isValid: true };
      const result = fromLegacyValidation(legacy, "success");

      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("success");
    });

    test("converts invalid legacy result to Err", () => {
      const legacy = { isValid: false, reason: "validation failed" };
      const result = fromLegacyValidation(
        legacy,
        "success",
        "REQUIRED_FIELD",
        "username",
      );

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("REQUIRED_FIELD");
        expect(result.error.message).toBe("validation failed");
      }
    });
  });

  describe("toLegacyValidation", () => {
    test("converts Ok result to valid legacy format", () => {
      const result = ok("success");
      const legacy = toLegacyValidation(result);

      expect(legacy.isValid).toBe(true);
      expect(legacy.reason).toBeUndefined();
    });

    test("converts Err result to invalid legacy format", () => {
      const error: AppError = {
        type: "REQUIRED_FIELD",
        message: "Field is required",
        field: "username",
      };
      const result = err(error);
      const legacy = toLegacyValidation(result);

      expect(legacy.isValid).toBe(false);
      expect(legacy.reason).toBe("usernameは必須項目です");
    });
  });

  describe("fromCondition", () => {
    test("returns Ok when condition is true", () => {
      const result = fromCondition(true, "success", "error");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("success");
    });

    test("returns Err when condition is false", () => {
      const result = fromCondition(false, "success", "error");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error).toBe("error");
      }
    });
  });

  describe("mapArrayToResult", () => {
    test("maps array successfully when all operations succeed", () => {
      const array = [1, 2, 3];
      const result = mapArrayToResult(array, (x) => ok(x * 2));

      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr([])).toEqual([2, 4, 6]);
    });

    test("returns error when any operation fails", () => {
      const array = [1, 2, 3];
      const result = mapArrayToResult(array, (x) =>
        x === 2 ? err("error") : ok(x * 2),
      );

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error).toBe("error");
      }
    });
  });
}
</file>

<file path="src/lib/auth-config.ts">
/**
 * 認証関連の設定を管理するファイル
 * - 認証タイプ別のルート設定
 * - パスタイプ判定ロジック
 * - リダイレクト設定
 */

export type RouteConfig = {
  type: "public" | "auth" | "protected";
  pattern: RegExp;
};

// パスタイプ別の設定
export const routes: RouteConfig[] = [
  // 公開パス（認証不要）
  { type: "public", pattern: /^\/splash\/?$/ },
  { type: "public", pattern: /^\/api\/?.*$/ },

  // 認証用パス
  { type: "auth", pattern: /^\/auth\/login\/?$/ },
  { type: "auth", pattern: /^\/auth\/register\/?$/ },
  { type: "auth", pattern: /^\/auth\/register-success\/?$/ },
  { type: "auth", pattern: /^\/auth\/forgot-password\/?$/ },

  // その他すべては保護されたパス（優先度が最も低い）
  { type: "protected", pattern: /.*/ },
];

/**
 * 指定されたパスのルートタイプを判定する
 * @param path - 判定するパス
 * @returns 'public' | 'auth' | 'protected'
 */
export function getRouteType(path: string): "public" | "auth" | "protected" {
  // 優先順位の高い順に判定
  for (const route of routes) {
    if (route.pattern.test(path)) {
      return route.type;
    }
  }

  // デフォルトでは保護されたパスと判断
  return "protected";
}

// リダイレクト設定
export const authRedirects = {
  // 認証済みユーザーが認証ページにアクセスした場合のリダイレクト先
  authenticatedVisitingAuthPage: "/",

  // 未認証ユーザーが保護ページにアクセスした場合のリダイレクト先
  unauthenticatedVisitingProtectedPage: "/auth/login",
};
</file>

<file path="src/lib/auth.ts">
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { userBalanceData } from "@/features/balance/data/user-profile-data";
import crypto from "crypto";

// 本番環境では安全なシークレットを使用する必要があります
const NEXTAUTH_SECRET =
  process.env.NEXTAUTH_SECRET || "unsafe_development_secret";

// パスワードのハッシュ化関数（実際のAPIがない場合のモック用）
const hashPassword = (password: string) => {
  return crypto
    .createHash("sha256")
    .update(`${password}${NEXTAUTH_SECRET}`)
    .digest("hex");
};

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30日間
  },
  secret: NEXTAUTH_SECRET,
  // CSRFトークンを付与して保護
  useSecureCookies: process.env.NODE_ENV === "production",
  // 本番環境でのみHTTPSを強制
  cookies: {
    sessionToken: {
      name:
        process.env.NODE_ENV === "production"
          ? `__Secure-next-auth.session-token`
          : `next-auth.session-token`, // 開発用
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: process.env.NODE_ENV === "production",
      },
    },
  },
  // ページのカスタマイズ
  pages: {
    signIn: "/auth/login",
    signOut: "/auth/login",
    error: "/auth/login",
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        // 本番環境ではここでAPIを呼び出してユーザー認証を行う
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // メールアドレスの適切な検証
        const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
        if (!emailRegex.test(credentials.email)) {
          return null;
        }

        // デモ用の認証ロジック（パスワードのハッシュ化を模擬）
        const demoUsers = [
          {
            id: userBalanceData.id,
            name: userBalanceData.name,
            email: "demo@example.com", // オーバーライド
            avatarUrl: userBalanceData.avatarUrl,
            balance: userBalanceData.balance,
            ecoRank: userBalanceData.ecoRank,
            passwordHash: hashPassword("P@ssw0rd"),
          },
          {
            // eco_user@example.comはuserBalanceDataと一致するのでスプレッド使用
            ...userBalanceData,
            passwordHash: hashPassword("P@ssw0rd"),
          },
        ];

        const user = demoUsers.find((u) => u.email === credentials.email);
        if (!user) return null;

        // パスワードの検証（ハッシュ値の比較）
        const isValid =
          hashPassword(credentials.password) === user.passwordHash;
        if (!isValid) return null;

        return {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.avatarUrl,
          balance: user.balance,
          ecoRank: user.ecoRank,
        };
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.balance = user.balance;
        token.ecoRank = user.ecoRank;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub || "";
        session.user.balance = token.balance;
        session.user.ecoRank = token.ecoRank;
      }
      return session;
    },
  },
};
</file>

<file path="src/services/api/balance.ts">
/**
 * 残高関連API関数
 *
 * ResultAsync<T, ApiError>を使用した型安全な残高API
 */

import { ResultAsync } from "neverthrow";
import { ApiError } from "@/shared/types/errors";
import { Transaction } from "@/shared/types/transaction";
import { apiGet, apiPost, apiPut } from "./base";

/**
 * 残高データ型
 */
export interface BalanceData {
  userId: string;
  currentBalance: number;
  availableBalance: number;
  pendingAmount: number;
  ecoContributionTotal: number;
  lastUpdated: string;
}

/**
 * チャージリクエスト型
 */
export interface ChargeRequest {
  amount: number;
  paymentMethod: "bank_transfer" | "credit_card" | "convenience_store" | "atm";
  paymentDetails?: Record<string, unknown>;
}

/**
 * チャージレスポンス型
 */
export interface ChargeResponse {
  transactionId: string;
  amount: number;
  status: "pending" | "completed" | "failed";
  estimatedCompletionTime?: string;
  paymentInstructions?: string;
}

/**
 * 決済リクエスト型
 */
export interface PaymentRequest {
  amount: number;
  merchantId: string;
  description: string;
  ecoContribution?: {
    enabled: boolean;
    percentage?: number;
    fixedAmount?: number;
    projectId?: string;
  };
}

/**
 * 決済レスポンス型
 */
export interface PaymentResponse {
  transactionId: string;
  amount: number;
  ecoContributionAmount: number;
  status: "success" | "failed" | "pending";
  newBalance: number;
}

/**
 * 送金リクエスト型
 */
export interface TransferRequest {
  recipientId: string;
  amount: number;
  message?: string;
  splitInfo?: {
    totalParticipants: number;
    description: string;
  };
}

/**
 * 送金レスポンス型
 */
export interface TransferResponse {
  transactionId: string;
  amount: number;
  recipientId: string;
  status: "success" | "failed" | "pending";
  newBalance: number;
}

/**
 * 残高制限情報型
 */
export interface BalanceLimits {
  dailyChargeLimit: number;
  monthlyChargeLimit: number;
  maxBalance: number;
  minTransactionAmount: number;
  maxTransactionAmount: number;
  dailyUsedCharge: number;
  monthlyUsedCharge: number;
}

/**
 * エコ貢献統計型
 */
export interface EcoContributionStats {
  totalContribution: number;
  monthlyContribution: number;
  contributionByProject: Record<string, number>;
  carbonOffsetKg: number;
  treesPlanted: number;
  rank: string;
  nextRankThreshold: number;
}

/**
 * 残高履歴取得オプション型
 */
export interface BalanceHistoryOptions {
  startDate?: string;
  endDate?: string;
  transactionType?: Transaction["type"];
  limit?: number;
  offset?: number;
}

/**
 * 残高履歴レスポンス型
 */
export interface BalanceHistoryResponse {
  transactions: Transaction[];
  totalCount: number;
  hasMore: boolean;
}

/**
 * 現在の残高を取得
 */
export function fetchBalance(
  userId?: string,
): ResultAsync<BalanceData, ApiError> {
  const endpoint = userId ? `/balance/${userId}` : "/balance/me";
  return apiGet<BalanceData>(endpoint);
}

/**
 * 残高制限情報を取得
 */
export function fetchBalanceLimits(): ResultAsync<BalanceLimits, ApiError> {
  return apiGet<BalanceLimits>("/balance/limits");
}

/**
 * 残高履歴を取得
 */
export function fetchBalanceHistory(
  options: BalanceHistoryOptions = {},
): ResultAsync<BalanceHistoryResponse, ApiError> {
  const queryParams = new URLSearchParams();

  if (options.startDate) queryParams.append("startDate", options.startDate);
  if (options.endDate) queryParams.append("endDate", options.endDate);
  if (options.transactionType)
    queryParams.append("type", options.transactionType);
  if (options.limit) queryParams.append("limit", options.limit.toString());
  if (options.offset) queryParams.append("offset", options.offset.toString());

  const endpoint = `/balance/history${queryParams.toString() ? `?${queryParams.toString()}` : ""}`;
  return apiGet<BalanceHistoryResponse>(endpoint);
}

/**
 * チャージを実行
 */
export function chargeBalance(
  request: ChargeRequest,
): ResultAsync<ChargeResponse, ApiError> {
  return apiPost<ChargeResponse>("/balance/charge", request);
}

/**
 * 決済を実行
 */
export function processPayment(
  request: PaymentRequest,
): ResultAsync<PaymentResponse, ApiError> {
  return apiPost<PaymentResponse>("/balance/payment", request);
}

/**
 * 送金を実行
 */
export function transferMoney(
  request: TransferRequest,
): ResultAsync<TransferResponse, ApiError> {
  return apiPost<TransferResponse>("/balance/transfer", request);
}

/**
 * エコ貢献統計を取得
 */
export function fetchEcoContributionStats(): ResultAsync<
  EcoContributionStats,
  ApiError
> {
  return apiGet<EcoContributionStats>("/balance/eco-stats");
}

/**
 * 残高を強制更新（管理者向け）
 */
export function forceUpdateBalance(
  userId: string,
  newBalance: number,
  reason: string,
): ResultAsync<BalanceData, ApiError> {
  return apiPut<BalanceData>(`/balance/${userId}/force-update`, {
    newBalance,
    reason,
  });
}

/**
 * チャージ取引のステータスを確認
 */
export function checkChargeStatus(
  transactionId: string,
): ResultAsync<ChargeResponse, ApiError> {
  return apiGet<ChargeResponse>(`/balance/charge/${transactionId}/status`);
}

/**
 * 決済取引のステータスを確認
 */
export function checkPaymentStatus(
  transactionId: string,
): ResultAsync<PaymentResponse, ApiError> {
  return apiGet<PaymentResponse>(`/balance/payment/${transactionId}/status`);
}

/**
 * 送金取引のステータスを確認
 */
export function checkTransferStatus(
  transactionId: string,
): ResultAsync<TransferResponse, ApiError> {
  return apiGet<TransferResponse>(`/balance/transfer/${transactionId}/status`);
}

/**
 * 残高不足チェック
 */
export function checkSufficientBalance(
  amount: number,
): ResultAsync<boolean, ApiError> {
  return apiPost<boolean>("/balance/check-sufficient", { amount });
}

// In Source Testing
if (import.meta.vitest) {
  const { describe, it, expect, vi, beforeEach } = import.meta.vitest;

  // API基盤関数のモック
  vi.mock("./base", () => ({
    apiGet: vi.fn(),
    apiPost: vi.fn(),
    apiPut: vi.fn(),
  }));

  describe("Balance API Functions", () => {
    const mockBalanceData: BalanceData = {
      userId: "usr_12345",
      currentBalance: 8500,
      availableBalance: 8500,
      pendingAmount: 0,
      ecoContributionTotal: 1250,
      lastUpdated: "2025-01-25T12:00:00Z",
    };

    const mockChargeResponse: ChargeResponse = {
      transactionId: "txn_charge_001",
      amount: 20000,
      status: "pending",
      estimatedCompletionTime: "2025-01-25T15:00:00Z",
      paymentInstructions: "ATMで入金してください",
    };

    const mockPaymentResponse: PaymentResponse = {
      transactionId: "txn_payment_001",
      amount: 580,
      ecoContributionAmount: 30,
      status: "success",
      newBalance: 7920,
    };

    const mockTransferResponse: TransferResponse = {
      transactionId: "txn_transfer_001",
      amount: 3000,
      recipientId: "usr_67890",
      status: "success",
      newBalance: 5500,
    };

    const mockBalanceLimits: BalanceLimits = {
      dailyChargeLimit: 50000,
      monthlyChargeLimit: 1000000,
      maxBalance: 500000,
      minTransactionAmount: 1,
      maxTransactionAmount: 50000,
      dailyUsedCharge: 10000,
      monthlyUsedCharge: 50000,
    };

    const mockEcoStats: EcoContributionStats = {
      totalContribution: 1250,
      monthlyContribution: 350,
      contributionByProject: {
        森林保全: 800,
        海洋プラスチック削減: 450,
      },
      carbonOffsetKg: 25.5,
      treesPlanted: 12,
      rank: "エコマイスター",
      nextRankThreshold: 2000,
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe("fetchBalance", () => {
      it("ユーザーIDなしで自分の残高を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockBalanceData),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchBalance();

        expect(mockApiGet).toHaveBeenCalledWith("/balance/me");
      });

      it("ユーザーIDありで他のユーザーの残高を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockBalanceData),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchBalance("usr_12345");

        expect(mockApiGet).toHaveBeenCalledWith("/balance/usr_12345");
      });
    });

    describe("fetchBalanceLimits", () => {
      it("残高制限情報を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockBalanceLimits),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchBalanceLimits();

        expect(mockApiGet).toHaveBeenCalledWith("/balance/limits");
      });
    });

    describe("fetchBalanceHistory", () => {
      it("オプションなしで残高履歴を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        const mockResponse = {
          transactions: [],
          totalCount: 0,
          hasMore: false,
        };

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchBalanceHistory();

        expect(mockApiGet).toHaveBeenCalledWith("/balance/history");
      });

      it("オプション付きで残高履歴を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        const mockResponse = {
          transactions: [],
          totalCount: 0,
          hasMore: false,
        };

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        const options = {
          startDate: "2025-01-01",
          endDate: "2025-01-31",
          transactionType: "payment" as const,
          limit: 20,
          offset: 0,
        };

        fetchBalanceHistory(options);

        expect(mockApiGet).toHaveBeenCalledWith(
          "/balance/history?startDate=2025-01-01&endDate=2025-01-31&type=payment&limit=20",
        );
      });
    });

    describe("chargeBalance", () => {
      it("チャージを実行", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const chargeRequest: ChargeRequest = {
          amount: 20000,
          paymentMethod: "bank_transfer",
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockChargeResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        chargeBalance(chargeRequest);

        expect(mockApiPost).toHaveBeenCalledWith(
          "/balance/charge",
          chargeRequest,
        );
      });
    });

    describe("processPayment", () => {
      it("決済を実行", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const paymentRequest: PaymentRequest = {
          amount: 580,
          merchantId: "merchant_eco_cafe",
          description: "エコカフェ 渋谷店",
          ecoContribution: {
            enabled: true,
            percentage: 5,
            projectId: "forest_conservation",
          },
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockPaymentResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        processPayment(paymentRequest);

        expect(mockApiPost).toHaveBeenCalledWith(
          "/balance/payment",
          paymentRequest,
        );
      });
    });

    describe("transferMoney", () => {
      it("送金を実行", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const transferRequest: TransferRequest = {
          recipientId: "usr_67890",
          amount: 3000,
          message: "ランチ代",
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransferResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        transferMoney(transferRequest);

        expect(mockApiPost).toHaveBeenCalledWith(
          "/balance/transfer",
          transferRequest,
        );
      });
    });

    describe("fetchEcoContributionStats", () => {
      it("エコ貢献統計を取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockEcoStats),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchEcoContributionStats();

        expect(mockApiGet).toHaveBeenCalledWith("/balance/eco-stats");
      });
    });

    describe("checkSufficientBalance", () => {
      it("残高不足チェック", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(true),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        checkSufficientBalance(5000);

        expect(mockApiPost).toHaveBeenCalledWith("/balance/check-sufficient", {
          amount: 5000,
        });
      });
    });

    describe("Status Check Functions", () => {
      it("チャージステータスを確認", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockChargeResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        checkChargeStatus("txn_charge_001");

        expect(mockApiGet).toHaveBeenCalledWith(
          "/balance/charge/txn_charge_001/status",
        );
      });

      it("決済ステータスを確認", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockPaymentResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        checkPaymentStatus("txn_payment_001");

        expect(mockApiGet).toHaveBeenCalledWith(
          "/balance/payment/txn_payment_001/status",
        );
      });

      it("送金ステータスを確認", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;

        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransferResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        checkTransferStatus("txn_transfer_001");

        expect(mockApiGet).toHaveBeenCalledWith(
          "/balance/transfer/txn_transfer_001/status",
        );
      });
    });
  });
}
</file>

<file path="src/services/api/base.ts">
/**
 * API基盤関数
 *
 * neverthrowのResultAsync<T, E>を使用した型安全なAPI呼び出し基盤
 * すべてのAPI関数で統一されたエラーハンドリングパターンを提供
 */

import { ResultAsync } from "neverthrow";
import { ApiError } from "@/shared/types/errors";

/**
 * HTTPメソッド型
 */
export type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

/**
 * API設定
 */
export interface ApiConfig {
  baseUrl?: string;
  timeout?: number;
  headers?: Record<string, string>;
}

/**
 * リクエストオプション
 */
export interface RequestOptions {
  method: HttpMethod;
  url: string;
  data?: unknown;
  headers?: Record<string, string>;
  timeout?: number;
}

/**
 * デフォルトAPI設定
 */
const DEFAULT_CONFIG: Required<ApiConfig> = {
  baseUrl: process.env.NEXT_PUBLIC_API_BASE_URL || "/api",
  timeout: 30000, // 30秒
  headers: {
    "Content-Type": "application/json",
  },
};

/**
 * 設定されたAPI設定
 */
let apiConfig: Required<ApiConfig> = { ...DEFAULT_CONFIG };

/**
 * API設定を更新
 */
export function configureApi(config: ApiConfig): void {
  apiConfig = { ...apiConfig, ...config };
}

/**
 * HTTPステータスコードからApiErrorを作成
 */
function createApiErrorFromStatus(
  status: number,
  statusText: string,
  url: string,
): ApiError {
  switch (status) {
    case 400:
      return {
        type: "BAD_REQUEST",
        message: `Bad Request: ${statusText}`,
      };
    case 401:
      return {
        type: "UNAUTHORIZED",
        message: "Unauthorized access",
      };
    case 403:
      return {
        type: "FORBIDDEN",
        message: "Access forbidden",
      };
    case 404:
      return {
        type: "NOT_FOUND",
        message: `Resource not found: ${url}`,
      };
    case 409:
      return {
        type: "CONFLICT",
        message: `Conflict: ${statusText}`,
      };
    case 429:
      return {
        type: "RATE_LIMIT_EXCEEDED",
        message: "Rate limit exceeded",
      };
    case 500:
    case 502:
    case 503:
    case 504:
      return {
        type: "SERVER_ERROR",
        message: `Server error: ${statusText}`,
        statusCode: status,
      };
    default:
      return {
        type: "SERVER_ERROR",
        message: `HTTP ${status}: ${statusText}`,
        statusCode: status,
      };
  }
}

/**
 * エラーオブジェクトからApiErrorを作成
 */
function createApiErrorFromError(error: Error, url: string): ApiError {
  // ネットワークエラーの判定
  if (error.name === "TypeError" && error.message.includes("fetch")) {
    return {
      type: "NETWORK_ERROR",
      message: "Network connection failed",
      cause: error,
    };
  }

  // タイムアウトエラーの判定
  if (error.name === "AbortError" || error.message.includes("timeout")) {
    return {
      type: "TIMEOUT_ERROR",
      message: `Request timeout for ${url}`,
      timeoutMs: apiConfig.timeout,
    };
  }

  // その他のエラー
  return {
    type: "NETWORK_ERROR",
    message: error.message || "Unknown network error",
    cause: error,
  };
}

/**
 * 共通APIリクエスト関数
 */
function makeRequest<T>(options: RequestOptions): ResultAsync<T, ApiError> {
  const {
    method,
    url,
    data,
    headers = {},
    timeout = apiConfig.timeout,
  } = options;
  const fullUrl = url.startsWith("http") ? url : `${apiConfig.baseUrl}${url}`;

  // リクエストヘッダーの構築
  const requestHeaders = {
    ...apiConfig.headers,
    ...headers,
  };

  // AbortControllerによるタイムアウト制御
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  // fetch設定
  const fetchOptions: RequestInit = {
    method,
    headers: requestHeaders,
    signal: controller.signal,
  };

  // POSTやPUTの場合はbodyを追加
  if (data && ["POST", "PUT", "PATCH"].includes(method)) {
    fetchOptions.body = JSON.stringify(data);
  }

  return ResultAsync.fromPromise(
    fetch(fullUrl, fetchOptions).then(async (response) => {
      clearTimeout(timeoutId);

      // HTTPステータスチェック
      if (!response.ok) {
        throw createApiErrorFromStatus(
          response.status,
          response.statusText,
          fullUrl,
        );
      }

      // レスポンスの解析
      const contentType = response.headers.get("content-type");
      if (contentType?.includes("application/json")) {
        return await response.json();
      } else {
        return await response.text();
      }
    }),
    (error) => {
      clearTimeout(timeoutId);

      // ApiErrorの場合はそのまま返す
      if (typeof error === "object" && error !== null && "type" in error) {
        return error as ApiError;
      }

      // ErrorオブジェクトからApiErrorを作成
      return createApiErrorFromError(error as Error, fullUrl);
    },
  );
}

/**
 * GET リクエスト
 */
export function apiGet<T>(
  url: string,
  headers?: Record<string, string>,
): ResultAsync<T, ApiError> {
  return makeRequest<T>({
    method: "GET",
    url,
    headers,
  });
}

/**
 * POST リクエスト
 */
export function apiPost<T>(
  url: string,
  data?: unknown,
  headers?: Record<string, string>,
): ResultAsync<T, ApiError> {
  return makeRequest<T>({
    method: "POST",
    url,
    data,
    headers,
  });
}

/**
 * PUT リクエスト
 */
export function apiPut<T>(
  url: string,
  data?: unknown,
  headers?: Record<string, string>,
): ResultAsync<T, ApiError> {
  return makeRequest<T>({
    method: "PUT",
    url,
    data,
    headers,
  });
}

/**
 * DELETE リクエスト
 */
export function apiDelete<T>(
  url: string,
  headers?: Record<string, string>,
): ResultAsync<T, ApiError> {
  return makeRequest<T>({
    method: "DELETE",
    url,
    headers,
  });
}

/**
 * PATCH リクエスト
 */
export function apiPatch<T>(
  url: string,
  data?: unknown,
  headers?: Record<string, string>,
): ResultAsync<T, ApiError> {
  return makeRequest<T>({
    method: "PATCH",
    url,
    data,
    headers,
  });
}

// In Source Testing
if (import.meta.vitest) {
  const { describe, it, expect, vi, beforeEach, afterEach } = import.meta
    .vitest;

  // グローバルfetchのモック
  const mockFetch = vi.fn();
  global.fetch = mockFetch;

  describe("API Base Functions", () => {
    beforeEach(() => {
      mockFetch.mockReset();
      // デフォルト設定にリセット
      configureApi(DEFAULT_CONFIG);
    });

    afterEach(() => {
      vi.clearAllTimers();
    });

    describe("configureApi", () => {
      it("API設定を正しく更新できる", () => {
        const customConfig = {
          baseUrl: "https://api.example.com",
          timeout: 5000,
          headers: { "X-Custom": "test" },
        };

        configureApi(customConfig);

        // 内部状態の確認は間接的にテスト
        expect(true).toBe(true); // 設定関数が正常に実行されることを確認
      });
    });

    describe("apiGet", () => {
      it("成功時にOkResultを返す", async () => {
        const mockData = { id: 1, name: "test" };
        mockFetch.mockResolvedValueOnce({
          ok: true,
          headers: { get: () => "application/json" },
          json: () => Promise.resolve(mockData),
        });

        const result = await apiGet<typeof mockData>("/test");

        expect(result.isOk()).toBe(true);
        if (result.isOk()) {
          expect(result.value).toEqual(mockData);
        }
      });

      it("404エラー時にNOT_FOUNDエラーを返す", async () => {
        mockFetch.mockResolvedValueOnce({
          ok: false,
          status: 404,
          statusText: "Not Found",
        });

        const result = await apiGet("/not-found");

        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.type).toBe("NOT_FOUND");
        }
      });

      it("ネットワークエラー時にNETWORK_ERRORを返す", async () => {
        const networkError = new TypeError("Failed to fetch");
        mockFetch.mockRejectedValueOnce(networkError);

        const result = await apiGet("/test");

        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.type).toBe("NETWORK_ERROR");
          if (result.error.type === "NETWORK_ERROR") {
            expect(result.error.cause).toBe(networkError);
          }
        }
      });
    });

    describe("apiPost", () => {
      it("データ付きPOSTリクエストが成功する", async () => {
        const requestData = { name: "test" };
        const responseData = { id: 1, ...requestData };

        mockFetch.mockResolvedValueOnce({
          ok: true,
          headers: { get: () => "application/json" },
          json: () => Promise.resolve(responseData),
        });

        const result = await apiPost("/test", requestData);

        expect(result.isOk()).toBe(true);
        if (result.isOk()) {
          expect(result.value).toEqual(responseData);
        }

        // fetchが正しいパラメータで呼ばれたことを確認
        expect(mockFetch).toHaveBeenCalledWith(
          "/api/test",
          expect.objectContaining({
            method: "POST",
            body: JSON.stringify(requestData),
            headers: expect.objectContaining({
              "Content-Type": "application/json",
            }),
          }),
        );
      });

      it("400エラー時にBAD_REQUESTエラーを返す", async () => {
        mockFetch.mockResolvedValueOnce({
          ok: false,
          status: 400,
          statusText: "Bad Request",
        });

        const result = await apiPost("/test", {});

        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.type).toBe("BAD_REQUEST");
        }
      });
    });

    describe("HTTP Status Code Handling", () => {
      const statusTests = [
        { status: 401, expectedType: "UNAUTHORIZED" },
        { status: 403, expectedType: "FORBIDDEN" },
        { status: 409, expectedType: "CONFLICT" },
        { status: 429, expectedType: "RATE_LIMIT_EXCEEDED" },
        { status: 500, expectedType: "SERVER_ERROR" },
        { status: 502, expectedType: "SERVER_ERROR" },
        { status: 503, expectedType: "SERVER_ERROR" },
      ];

      statusTests.forEach(({ status, expectedType }) => {
        it(`${status}ステータスで${expectedType}エラーを返す`, async () => {
          mockFetch.mockResolvedValueOnce({
            ok: false,
            status,
            statusText: `Status ${status}`,
          });

          const result = await apiGet("/test");

          expect(result.isErr()).toBe(true);
          if (result.isErr()) {
            expect(result.error.type).toBe(expectedType);
          }
        });
      });
    });

    describe("Timeout Handling", () => {
      it("タイムアウト時にTIMEOUT_ERRORを返す", async () => {
        // AbortErrorをシミュレート
        const abortError = new Error("The operation was aborted");
        abortError.name = "AbortError";
        mockFetch.mockRejectedValueOnce(abortError);

        const result = await apiGet("/test");

        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.type).toBe("TIMEOUT_ERROR");
        }
      });
    });
  });
}
</file>

<file path="src/services/api/transactions.ts">
import { ResultAsync } from "neverthrow";
import { ApiError } from "@/shared/types/errors";
import { Transaction } from "@/shared/types/transaction";
import { apiGet, apiPost, apiPut, apiDelete } from "./base";

/**
 * 取引一覧取得のリクエストパラメータ
 */
export interface FetchTransactionsParams {
  userId?: string;
  limit?: number;
  offset?: number;
  type?: string;
  dateFrom?: string;
  dateTo?: string;
}

/**
 * 取引一覧取得のレスポンス
 */
export interface TransactionsResponse {
  transactions: Transaction[];
  total: number;
  hasMore: boolean;
}

/**
 * 新規取引作成のリクエストデータ
 */
export interface CreateTransactionRequest {
  type: Transaction["type"];
  description: string;
  amount: number;
  ecoContribution?: Transaction["ecoContribution"];
  campaignInfo?: Transaction["campaignInfo"];
  splitInfo?: Transaction["splitInfo"];
}

/**
 * 取引更新のリクエストデータ
 */
export interface UpdateTransactionRequest {
  description?: string;
  ecoContribution?: Transaction["ecoContribution"];
  campaignInfo?: Transaction["campaignInfo"];
  splitInfo?: Transaction["splitInfo"];
}

/**
 * 取引一覧を取得する
 * @param params 取得パラメータ
 * @returns ResultAsync<TransactionsResponse, ApiError>
 */
export function fetchTransactions(
  params: FetchTransactionsParams = {},
): ResultAsync<TransactionsResponse, ApiError> {
  const queryParams = new URLSearchParams();

  if (params.userId) queryParams.set("userId", params.userId);
  if (params.limit) queryParams.set("limit", params.limit.toString());
  if (params.offset) queryParams.set("offset", params.offset.toString());
  if (params.type) queryParams.set("type", params.type);
  if (params.dateFrom) queryParams.set("dateFrom", params.dateFrom);
  if (params.dateTo) queryParams.set("dateTo", params.dateTo);

  const url = `/api/transactions${queryParams.toString() ? "?" + queryParams.toString() : ""}`;

  return apiGet<TransactionsResponse>(url);
}

/**
 * 特定の取引詳細を取得する
 * @param transactionId 取引ID
 * @returns ResultAsync<Transaction, ApiError>
 */
export function fetchTransactionById(
  transactionId: string,
): ResultAsync<Transaction, ApiError> {
  return apiGet<Transaction>(`/api/transactions/${transactionId}`);
}

/**
 * 新規取引を作成する
 * @param request 取引作成データ
 * @returns ResultAsync<Transaction, ApiError>
 */
export function createTransaction(
  request: CreateTransactionRequest,
): ResultAsync<Transaction, ApiError> {
  return apiPost<Transaction>("/api/transactions", request);
}

/**
 * 取引情報を更新する
 * @param transactionId 取引ID
 * @param request 更新データ
 * @returns ResultAsync<Transaction, ApiError>
 */
export function updateTransaction(
  transactionId: string,
  request: UpdateTransactionRequest,
): ResultAsync<Transaction, ApiError> {
  return apiPut<Transaction>(`/api/transactions/${transactionId}`, request);
}

/**
 * 取引を削除する
 * @param transactionId 取引ID
 * @returns ResultAsync<void, ApiError>
 */
export function deleteTransaction(
  transactionId: string,
): ResultAsync<void, ApiError> {
  return apiDelete<void>(`/api/transactions/${transactionId}`);
}

/**
 * ユーザーの取引統計を取得する
 * @param userId ユーザーID（省略時は現在のユーザー）
 * @param period 期間（'month' | 'year'）
 * @returns ResultAsync<TransactionStats, ApiError>
 */
export interface TransactionStats {
  totalTransactions: number;
  totalAmount: number;
  totalEcoContribution: number;
  typeBreakdown: Record<Transaction["type"], number>;
  monthlyTrend: Array<{
    month: string;
    count: number;
    amount: number;
  }>;
}

export function fetchTransactionStats(
  userId?: string,
  period: "month" | "year" = "month",
): ResultAsync<TransactionStats, ApiError> {
  const queryParams = new URLSearchParams();
  if (userId) queryParams.set("userId", userId);
  queryParams.set("period", period);

  const url = `/api/transactions/stats?${queryParams.toString()}`;
  return apiGet<TransactionStats>(url);
}

// =============================================================================
// In Source Testing
// =============================================================================

if (import.meta.vitest) {
  const { describe, it, expect, vi, beforeEach } = import.meta.vitest;

  // API基盤関数のモック
  vi.mock("./base", () => ({
    apiGet: vi.fn(),
    apiPost: vi.fn(),
    apiPut: vi.fn(),
    apiDelete: vi.fn(),
  }));

  describe("Transaction API Functions", () => {
    // テスト用のモックデータ
    const mockTransaction: Transaction = {
      id: "txn_test_01",
      type: "payment",
      description: "テスト取引",
      date: "2025/01/26",
      amount: -1000,
      ecoContribution: {
        enabled: true,
        amount: 50,
        project: "テストプロジェクト",
      },
    };

    const mockTransactionsResponse: TransactionsResponse = {
      transactions: [mockTransaction],
      total: 1,
      hasMore: false,
    };

    const mockTransactionStats: TransactionStats = {
      totalTransactions: 10,
      totalAmount: -50000,
      totalEcoContribution: 2500,
      typeBreakdown: {
        payment: 7,
        charge: 2,
        receive: 1,
        donation: 0,
        expired: 0,
      },
      monthlyTrend: [{ month: "2025-01", count: 10, amount: -50000 }],
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe("fetchTransactions", () => {
      it("取引一覧を正常に取得できる", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransactionsResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchTransactions();

        expect(mockApiGet).toHaveBeenCalledWith("/api/transactions");
      });

      it("クエリパラメータを正しく処理できる", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransactionsResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        const params: FetchTransactionsParams = {
          userId: "user123",
          limit: 10,
          type: "payment",
        };

        fetchTransactions(params);

        expect(mockApiGet).toHaveBeenCalledWith(
          "/api/transactions?userId=user123&limit=10&type=payment",
        );
      });
    });

    describe("fetchTransactionById", () => {
      it("IDで取引を正常に取得できる", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransaction),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchTransactionById("txn_test_01");

        expect(mockApiGet).toHaveBeenCalledWith(
          "/api/transactions/txn_test_01",
        );
      });
    });

    describe("createTransaction", () => {
      it("取引を正常に作成できる", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const request: CreateTransactionRequest = {
          type: "payment",
          description: "テスト取引",
          amount: -1000,
          ecoContribution: {
            enabled: true,
            amount: 50,
            project: "テストプロジェクト",
          },
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransaction),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        createTransaction(request);

        expect(mockApiPost).toHaveBeenCalledWith("/api/transactions", request);
      });
    });

    describe("updateTransaction", () => {
      it("取引を正常に更新できる", async () => {
        const mockApiPut = vi.mocked(await import("./base")).apiPut;
        const request: UpdateTransactionRequest = {
          description: "更新されたテスト取引",
        };

        mockApiPut.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransaction),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        updateTransaction("txn_test_01", request);

        expect(mockApiPut).toHaveBeenCalledWith(
          "/api/transactions/txn_test_01",
          request,
        );
      });
    });

    describe("deleteTransaction", () => {
      it("取引を正常に削除できる", async () => {
        const mockApiDelete = vi.mocked(await import("./base")).apiDelete;

        mockApiDelete.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        deleteTransaction("txn_test_01");

        expect(mockApiDelete).toHaveBeenCalledWith(
          "/api/transactions/txn_test_01",
        );
      });
    });

    describe("fetchTransactionStats", () => {
      it("取引統計を正常に取得できる", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransactionStats),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchTransactionStats("user123", "month");

        expect(mockApiGet).toHaveBeenCalledWith(
          "/api/transactions/stats?userId=user123&period=month",
        );
      });

      it("デフォルトパラメータを正しく使用できる", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockTransactionStats),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchTransactionStats();

        expect(mockApiGet).toHaveBeenCalledWith(
          "/api/transactions/stats?period=month",
        );
      });
    });
  });
}
</file>

<file path="src/services/api/user.ts">
/**
 * ユーザー関連API関数
 *
 * ResultAsync<T, ApiError>を使用した型安全なユーザーAPI
 */

import { ResultAsync } from "neverthrow";
import { ApiError } from "@/shared/types/errors";
import { apiGet, apiPost, apiPut, apiPatch } from "./base";

/**
 * ユーザープロフィール型（再エクスポート）
 */
export interface UserProfile {
  id: string;
  name: string;
  email: string;
  avatarUrl: string;
  avatarInitials: string;
  ecoRank: string;
  balance: number;
  joinDate: string;
}

/**
 * ユーザープロフィール更新データ型
 */
export interface UpdateUserProfileData {
  name?: string;
  email?: string;
  avatarUrl?: string;
}

/**
 * パスワード変更データ型
 */
export interface ChangePasswordData {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

/**
 * ユーザー認証データ型
 */
export interface AuthUserData {
  email: string;
  password: string;
}

/**
 * ユーザー登録データ型
 */
export interface RegisterUserData {
  name: string;
  email: string;
  password: string;
  confirmPassword: string;
}

/**
 * 認証レスポンス型
 */
export interface AuthResponse {
  user: UserProfile;
  token: string;
  refreshToken: string;
}

/**
 * ユーザープロフィールを取得
 */
export function fetchUserProfile(
  userId?: string,
): ResultAsync<UserProfile, ApiError> {
  const endpoint = userId ? `/users/${userId}` : "/users/me";
  return apiGet<UserProfile>(endpoint);
}

/**
 * ユーザープロフィールを更新
 */
export function updateUserProfile(
  userId: string,
  data: UpdateUserProfileData,
): ResultAsync<UserProfile, ApiError> {
  return apiPut<UserProfile>(`/users/${userId}`, data);
}

/**
 * 現在のユーザーのプロフィールを更新
 */
export function updateMyProfile(
  data: UpdateUserProfileData,
): ResultAsync<UserProfile, ApiError> {
  return apiPut<UserProfile>("/users/me", data);
}

/**
 * パスワードを変更
 */
export function changePassword(
  data: ChangePasswordData,
): ResultAsync<void, ApiError> {
  return apiPatch<void>("/users/me/password", data);
}

/**
 * ユーザーログイン
 */
export function loginUser(
  data: AuthUserData,
): ResultAsync<AuthResponse, ApiError> {
  return apiPost<AuthResponse>("/auth/login", data);
}

/**
 * ユーザー登録
 */
export function registerUser(
  data: RegisterUserData,
): ResultAsync<AuthResponse, ApiError> {
  return apiPost<AuthResponse>("/auth/register", data);
}

/**
 * ユーザーログアウト
 */
export function logoutUser(): ResultAsync<void, ApiError> {
  return apiPost<void>("/auth/logout");
}

/**
 * トークンリフレッシュ
 */
export function refreshToken(
  refreshToken: string,
): ResultAsync<AuthResponse, ApiError> {
  return apiPost<AuthResponse>("/auth/refresh", { refreshToken });
}

/**
 * パスワードリセット要求
 */
export function requestPasswordReset(
  email: string,
): ResultAsync<void, ApiError> {
  return apiPost<void>("/auth/forgot-password", { email });
}

/**
 * パスワードリセット実行
 */
export function resetPassword(
  token: string,
  newPassword: string,
  confirmPassword: string,
): ResultAsync<void, ApiError> {
  return apiPost<void>("/auth/reset-password", {
    token,
    newPassword,
    confirmPassword,
  });
}

/**
 * メールアドレス確認
 */
export function verifyEmail(token: string): ResultAsync<void, ApiError> {
  return apiPost<void>("/auth/verify-email", { token });
}

/**
 * メールアドレス確認再送
 */
export function resendEmailVerification(): ResultAsync<void, ApiError> {
  return apiPost<void>("/auth/resend-verification");
}

/**
 * ユーザーアカウント削除
 */
export function deleteUserAccount(
  password: string,
): ResultAsync<void, ApiError> {
  return apiPost<void>("/users/me/delete", { password });
}

// In Source Testing
if (import.meta.vitest) {
  const { describe, it, expect, vi, beforeEach } = import.meta.vitest;

  // API基盤関数のモック
  vi.mock("./base", () => ({
    apiGet: vi.fn(),
    apiPost: vi.fn(),
    apiPut: vi.fn(),
    apiPatch: vi.fn(),
  }));

  describe("User API Functions", () => {
    const mockUserProfile: UserProfile = {
      id: "usr_12345",
      name: "山田 太郎",
      email: "test@example.com",
      avatarUrl: "/api/placeholder/100/100",
      avatarInitials: "山田",
      ecoRank: "エコマイスター",
      balance: 8500,
      joinDate: "2024-12-01",
    };

    const mockAuthResponse: AuthResponse = {
      user: mockUserProfile,
      token: "mock-jwt-token",
      refreshToken: "mock-refresh-token",
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe("fetchUserProfile", () => {
      it("ユーザーIDなしで自分のプロフィールを取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockUserProfile),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchUserProfile();

        expect(mockApiGet).toHaveBeenCalledWith("/users/me");
      });

      it("ユーザーIDありで他のユーザーのプロフィールを取得", async () => {
        const mockApiGet = vi.mocked(await import("./base")).apiGet;
        mockApiGet.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockUserProfile),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        fetchUserProfile("usr_12345");

        expect(mockApiGet).toHaveBeenCalledWith("/users/usr_12345");
      });
    });

    describe("updateUserProfile", () => {
      it("他のユーザーのプロフィールを更新", async () => {
        const mockApiPut = vi.mocked(await import("./base")).apiPut;
        const updateData = { name: "佐藤 花子" };

        mockApiPut.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve({ ...mockUserProfile, ...updateData }),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        updateUserProfile("usr_12345", updateData);

        expect(mockApiPut).toHaveBeenCalledWith("/users/usr_12345", updateData);
      });
    });

    describe("updateMyProfile", () => {
      it("自分のプロフィールを更新", async () => {
        const mockApiPut = vi.mocked(await import("./base")).apiPut;
        const updateData = { name: "佐藤 花子" };

        mockApiPut.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve({ ...mockUserProfile, ...updateData }),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        updateMyProfile(updateData);

        expect(mockApiPut).toHaveBeenCalledWith("/users/me", updateData);
      });
    });

    describe("changePassword", () => {
      it("パスワードを変更", async () => {
        const mockApiPatch = vi.mocked(await import("./base")).apiPatch;
        const passwordData = {
          currentPassword: "oldpass123",
          newPassword: "newpass456",
          confirmPassword: "newpass456",
        };

        mockApiPatch.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        changePassword(passwordData);

        expect(mockApiPatch).toHaveBeenCalledWith(
          "/users/me/password",
          passwordData,
        );
      });
    });

    describe("loginUser", () => {
      it("ユーザーログイン", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const loginData = {
          email: "test@example.com",
          password: "password123",
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockAuthResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        loginUser(loginData);

        expect(mockApiPost).toHaveBeenCalledWith("/auth/login", loginData);
      });
    });

    describe("registerUser", () => {
      it("ユーザー登録", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const registerData = {
          name: "山田 太郎",
          email: "test@example.com",
          password: "password123",
          confirmPassword: "password123",
        };

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockAuthResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        registerUser(registerData);

        expect(mockApiPost).toHaveBeenCalledWith(
          "/auth/register",
          registerData,
        );
      });
    });

    describe("logoutUser", () => {
      it("ユーザーログアウト", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        logoutUser();

        expect(mockApiPost).toHaveBeenCalledWith("/auth/logout");
      });
    });

    describe("refreshToken", () => {
      it("トークンリフレッシュ", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const refreshTokenValue = "mock-refresh-token";

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(mockAuthResponse),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        refreshToken(refreshTokenValue);

        expect(mockApiPost).toHaveBeenCalledWith("/auth/refresh", {
          refreshToken: refreshTokenValue,
        });
      });
    });

    describe("requestPasswordReset", () => {
      it("パスワードリセット要求", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const email = "test@example.com";

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        requestPasswordReset(email);

        expect(mockApiPost).toHaveBeenCalledWith("/auth/forgot-password", {
          email,
        });
      });
    });

    describe("resetPassword", () => {
      it("パスワードリセット実行", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const token = "reset-token";
        const newPassword = "newpass123";
        const confirmPassword = "newpass123";

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        resetPassword(token, newPassword, confirmPassword);

        expect(mockApiPost).toHaveBeenCalledWith("/auth/reset-password", {
          token,
          newPassword,
          confirmPassword,
        });
      });
    });

    describe("verifyEmail", () => {
      it("メールアドレス確認", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const token = "verify-token";

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        verifyEmail(token);

        expect(mockApiPost).toHaveBeenCalledWith("/auth/verify-email", {
          token,
        });
      });
    });

    describe("deleteUserAccount", () => {
      it("ユーザーアカウント削除", async () => {
        const mockApiPost = vi.mocked(await import("./base")).apiPost;
        const password = "password123";

        mockApiPost.mockReturnValue(
          ResultAsync.fromPromise(
            Promise.resolve(undefined),
            () =>
              ({ type: "NETWORK_ERROR", message: "Network error" }) as ApiError,
          ),
        );

        deleteUserAccount(password);

        expect(mockApiPost).toHaveBeenCalledWith("/users/me/delete", {
          password,
        });
      });
    });
  });
}
</file>

<file path="src/shared/hooks/index.ts">
// Shared hooks
export { useFormValidation } from "./useFormValidation";
export { useFormattedCurrency } from "./useFormattedCurrency";
</file>

<file path="src/shared/hooks/useFormattedCurrency.ts">
"use client";

/**
 * 通貨フォーマット用のカスタムフック
 */
import { useMemo } from "react";
import { formatCurrency } from "@/shared/utils/formats";

/**
 * 通貨フォーマットに関するカスタムフック
 *
 * @param amount 金額
 * @param options フォーマットオプション
 * @returns フォーマット済み通貨文字列
 */
export function useFormattedCurrency(
  amount: number,
  options?: {
    withSymbol?: boolean;
    withPlus?: boolean;
    compactDisplay?: boolean;
    locale?: string;
    currency?: string;
  },
): string {
  return useMemo(() => formatCurrency(amount, options), [amount, options]);
}
</file>

<file path="src/shared/hooks/useFormValidation.ts">
"use client";

import { useState, useCallback } from "react";

export type ValidationRules = {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  email?: boolean;
  custom?: (value: string) => boolean;
};

export type ValidationErrors = Record<string, string | null>;

export function useFormValidation() {
  const [errors, setErrors] = useState<ValidationErrors>({});

  const validateField = useCallback(
    (name: string, value: string, rules: ValidationRules): string | null => {
      if (rules.required && !value) {
        return "この項目は必須です";
      }

      if (rules.minLength && value.length < rules.minLength) {
        return `${rules.minLength}文字以上入力してください`;
      }

      if (rules.maxLength && value.length > rules.maxLength) {
        return `${rules.maxLength}文字以内で入力してください`;
      }

      if (rules.email && !/\S+@\S+\.\S+/.test(value)) {
        return "有効なメールアドレスを入力してください";
      }

      if (rules.pattern && !rules.pattern.test(value)) {
        return "入力形式が正しくありません";
      }

      if (rules.custom && !rules.custom(value)) {
        return "入力内容を確認してください";
      }

      return null;
    },
    [],
  );

  const validateForm = useCallback(
    (
      formData: Record<string, string>,
      rulesMap: Record<string, ValidationRules>,
    ): boolean => {
      const newErrors: ValidationErrors = {};
      let isValid = true;

      Object.entries(rulesMap).forEach(([fieldName, rules]) => {
        const error = validateField(
          fieldName,
          formData[fieldName] || "",
          rules,
        );
        newErrors[fieldName] = error;
        if (error) isValid = false;
      });

      setErrors(newErrors);
      return isValid;
    },
    [validateField],
  );

  return { errors, validateField, validateForm, setErrors };
}
</file>

<file path="src/shared/utils/formats.ts">
/**
 * 共通のフォーマット関連ユーティリティ関数
 */

/**
 * 金額を日本円形式でフォーマットする
 * @param amount 金額
 * @param options フォーマットオプション
 * @returns フォーマットされた金額文字列
 */
export function formatCurrency(
  amount: number,
  options?: {
    withSymbol?: boolean;
    withPlus?: boolean;
    compactDisplay?: boolean;
    locale?: string;
    currency?: string;
  },
): string {
  const {
    withSymbol = true,
    withPlus = false,
    compactDisplay = false,
    locale = "ja-JP",
    currency = "JPY",
  } = options || {};

  const formatter = new Intl.NumberFormat(locale, {
    style: withSymbol ? "currency" : "decimal",
    currency: withSymbol ? currency : undefined,
    currencyDisplay: "symbol",
    notation: compactDisplay ? "compact" : "standard",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  });

  const formatted = formatter.format(Math.abs(amount));
  const prefix = amount < 0 ? "-" : withPlus ? "+" : "";

  return `${prefix}${formatted}`;
}

/**
 * 日付を日本形式でフォーマットする
 * @param date 日付文字列または日付オブジェクト
 * @param includeTime 時間を含めるかどうか
 * @returns フォーマットされた日付文字列
 */
export function formatDate(date: string | Date, includeTime = false): string {
  const dateObj =
    typeof date === "string" ? new Date(date.replace(/\//g, "-")) : date;

  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  };

  if (includeTime) {
    options.hour = "2-digit";
    options.minute = "2-digit";
  }

  return new Intl.DateTimeFormat("ja-JP", options)
    .format(dateObj)
    .replace(/\//g, "/");
}

/**
 * 日付の差分を計算する (残り日数など)
 * @param endDate 終了日
 * @param startDate 開始日 (デフォルトは現在)
 * @returns 日数の差分
 */
export function calculateDateDifference(
  endDate: string | Date,
  startDate?: string | Date,
): number {
  const end =
    typeof endDate === "string"
      ? new Date(endDate.replace(/\//g, "-"))
      : endDate;
  const start = startDate
    ? typeof startDate === "string"
      ? new Date(startDate.replace(/\//g, "-"))
      : startDate
    : new Date();

  const diffTime = end.getTime() - start.getTime();
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}
</file>

<file path="src/middleware.ts">
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { getToken } from "next-auth/jwt";
import { getRouteType, authRedirects } from "@/lib/auth-config";

export async function middleware(request: NextRequest) {
  // NextAuthのトークンを取得
  const token = await getToken({ req: request });
  const isAuthenticated = !!token;

  // パスのタイプを判定
  const path = request.nextUrl.pathname;
  const routeType = getRouteType(path);

  // 認証ロジックの適用
  if (isAuthenticated && routeType === "auth") {
    // 認証済みユーザーが認証ページにアクセスした場合はホームにリダイレクト
    return NextResponse.redirect(
      new URL(authRedirects.authenticatedVisitingAuthPage, request.url),
    );
  }

  if (!isAuthenticated && routeType === "protected") {
    // 未認証ユーザーが保護されたページにアクセスした場合はログインにリダイレクト
    return NextResponse.redirect(
      new URL(authRedirects.unauthenticatedVisitingProtectedPage, request.url),
    );
  }

  return NextResponse.next();
}

// 特定のパスに対してのみミドルウェアを適用（静的アセットは除外）
export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
const config = {
  darkMode: ["class", ".dark *"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        // デザインガイドラインに沿った色定義
        teal: {
          50: "#e6fffa",
          100: "#E0F2F1", // ライトティール（環境関連情報の背景）
          200: "#81e6d9",
          300: "#4fd1c5",
          400: "#38b2ac",
          500: "#319795",
          600: "#0F766E", // プライマリカラー: ティール
          700: "#0E6760", // ダークティール (ホバー状態)
          800: "#234e52",
          900: "#1d4044",
        },
        stone: {
          50: "#fafaf9",
          100: "#F5F5F4", // ライトストーン（ページ背景）
          200: "#e7e5e4",
          300: "#d6d3d1",
          400: "#a8a29e",
          500: "#78716C", // セカンダリーカラー: ストーン
          600: "#57534e",
          700: "#44403c",
          800: "#292524",
          900: "#1c1917",
        },
        amber: {
          100: "#FEF3C7", // ライトアンバー（キャンペーン情報背景）
          500: "#F59E0B",
          600: "#D97706", // アクセントカラー: アンバー
          700: "#B45309", // ダークアンバー
        },
        blue: {
          600: "#2563EB", // アクセントカラー: ブルー (入金、増加)
        },
        red: {
          100: "#FEE2E2", // ライトレッド
          600: "#DC2626", // アクセントカラー: レッド (エラー、警告)
          700: "#B91C1C", // ダークレッド
        },
        green: {
          600: "#16A34A", // アクセントカラー: グリーン (CO2削減)
        },
        border: "var(--border)",
        input: "var(--input)",
        ring: "var(--ring)",
        background: "var(--background)",
        foreground: "var(--foreground)",
        primary: {
          DEFAULT: "var(--primary)",
          foreground: "var(--primary-foreground)",
        },
        secondary: {
          DEFAULT: "var(--secondary)",
          foreground: "var(--secondary-foreground)",
        },
        destructive: {
          DEFAULT: "var(--destructive)",
          foreground: "var(--destructive-foreground)",
        },
        muted: {
          DEFAULT: "var(--muted)",
          foreground: "var(--muted-foreground)",
        },
        accent: {
          DEFAULT: "var(--accent)",
          foreground: "var(--accent-foreground)",
        },
        popover: {
          DEFAULT: "var(--popover)",
          foreground: "var(--popover-foreground)",
        },
        card: {
          DEFAULT: "var(--card)",
          foreground: "var(--card-foreground)",
        },
      },
      borderRadius: {
        lg: "var(--radius-lg)",
        md: "var(--radius-md)",
        sm: "var(--radius-sm)",
        xl: "var(--radius-xl)",
      },
    },
  },
};

export default config;
</file>

<file path="vitest.config.ts">
import { defineConfig } from "vitest/config";
import path from "path";

export default defineConfig({
  test: {
    // テスト環境の設定（Node.jsがデフォルト）
    environment: "node",

    // In Source Testingを有効化
    includeSource: ["src/**/*.{js,ts,tsx}"],

    // グローバルテストAPIsを有効にする場合（Jest互換性向上）
    // globals: true,

    // その他の設定
    // coverage: {
    //   provider: 'v8', // または 'istanbul'
    // },
  },

  // In Source TestingでTypeScriptの型定義を有効化
  define: {
    "import.meta.vitest": "undefined",
  },

  // パスエイリアスの設定（Next.jsプロジェクトとの整合性）
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="src/app/auth/forgot-password/page.tsx">
"use client";

import Link from "next/link";
import { useState } from "react";
import { AuthLayout } from "@/features/layout";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { ErrorDisplay } from "@/components/ui/error-display";
import { CheckCircle } from "lucide-react";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateForgotPasswordForm } from "@/features/auth/utils/validation";
import { requestPasswordReset } from "@/services/api/user";
import { Result, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

export default function ForgotPasswordPage() {
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [submittedEmail, setSubmittedEmail] = useState("");

  // パスワードリセット処理
  const handlePasswordResetSubmit = async (
    values: Record<string, string>,
  ): Promise<Result<void, AppError>> => {
    try {
      const result = await requestPasswordReset(values.email);

      return result.map(() => {
        // 成功時の処理
        setSubmittedEmail(values.email);
        setIsSubmitted(true);
      });
    } catch (error) {
      return err({
        type: "SERVER_ERROR",
        message:
          error instanceof Error ? error.message : "リクエストに失敗しました",
        statusCode: 500,
      });
    }
  };

  const {
    values,
    fieldErrors,
    isLoading,
    error,
    handleChange,
    handleSubmit,
    clearFieldError,
  } = useAuthForm({
    initialValues: {
      email: "",
    },
    validateForm: validateForgotPasswordForm,
    onSubmit: handlePasswordResetSubmit,
  });

  return (
    <AuthLayout
      title="パスワードをリセット"
      subtitle="シンプルで環境に優しい決済サービス"
    >
      {!isSubmitted ? (
        <form onSubmit={handleSubmit} className="space-y-4">
          <p className="text-sm text-stone-600 text-left">
            アカウントに登録されているメールアドレスを入力してください。パスワードリセット用のリンクを送信します。
          </p>

          <div className="space-y-2 text-left">
            <Label htmlFor="email">メールアドレス</Label>
            <Input
              id="email"
              name="email"
              type="email"
              placeholder="your@email.com"
              value={values.email}
              onChange={handleChange}
              onFocus={() => clearFieldError("email")}
            />
            {fieldErrors.email && <ErrorDisplay error={fieldErrors.email} />}
          </div>

          {error && <ErrorDisplay error={error} />}

          <Button
            type="submit"
            className="w-full bg-teal-700 hover:bg-teal-800 text-white"
            disabled={isLoading}
          >
            {isLoading ? "リクエスト中..." : "リセットリンクを送信"}
          </Button>

          <div className="text-center text-sm text-stone-600">
            <Link href="/auth/login" className="text-teal-700 hover:underline">
              ログイン画面に戻る
            </Link>
          </div>
        </form>
      ) : (
        <div className="space-y-4">
          <div className="flex flex-col items-center justify-center text-center">
            <div className="h-12 w-12 bg-teal-100 rounded-full flex items-center justify-center mb-4">
              <CheckCircle className="h-6 w-6 text-teal-700" />
            </div>
            <h3 className="text-lg font-medium text-stone-800">
              メールを送信しました
            </h3>
            <p className="text-sm text-stone-600 mt-2">
              {submittedEmail}{" "}
              宛にパスワードリセットリンクを送信しました。メールをご確認ください。
            </p>
          </div>

          <Button
            onClick={() => setIsSubmitted(false)}
            variant="outline"
            className="w-full border-stone-200"
          >
            メールアドレスを変更する
          </Button>

          <div className="text-center text-sm text-stone-600">
            <Link href="/auth/login" className="text-teal-700 hover:underline">
              ログイン画面に戻る
            </Link>
          </div>
        </div>
      )}
    </AuthLayout>
  );
}
</file>

<file path="src/app/auth/register/page.tsx">
"use client";

import Link from "next/link";
import { useState, useEffect, Suspense } from "react";
import { useSearchParams } from "next/navigation";
import { AuthLayout } from "@/features/layout";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { ErrorDisplay } from "@/components/ui/error-display";
import { Leaf, Users } from "lucide-react";
import { useRouter } from "next/navigation";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateRegisterForm } from "@/features/auth/utils/validation";
import { registerUser } from "@/services/api/user";
import { Result, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

function RegisterFormContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [referrerInfo, setReferrerInfo] = useState<{ name: string } | null>(
    null,
  );

  // 登録処理
  const handleRegisterSubmit = async (
    values: Record<string, string>,
  ): Promise<Result<void, AppError>> => {
    try {
      const result = await registerUser({
        name: values.name,
        email: values.email,
        password: values.password,
        confirmPassword: values.confirmPassword,
      });

      return result.map(() => {
        // 登録成功時の処理
        router.push(
          `/auth/register-success?email=${encodeURIComponent(values.email)}`,
        );
      });
    } catch (error) {
      return err({
        type: "SERVER_ERROR",
        message: error instanceof Error ? error.message : "登録に失敗しました",
        statusCode: 500,
      });
    }
  };

  const {
    values,
    setValues,
    fieldErrors,
    isLoading,
    error,
    handleChange,
    handleSubmit,
    clearFieldError,
  } = useAuthForm({
    initialValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
      referralCode: "",
      agreeTerms: "",
    },
    validateForm: validateRegisterForm,
    onSubmit: handleRegisterSubmit,
  });

  // URLからリファラルコードを取得
  useEffect(() => {
    const ref = searchParams.get("ref");
    if (ref) {
      console.log("Referral from:", ref);
      // モック実装：リファラルコードがある場合の処理
      if (ref.startsWith("ECO")) {
        setValues((prev) => ({ ...prev, referralCode: ref }));
      } else {
        // ユーザーIDからリファラル情報を取得する処理（モック）
        setReferrerInfo({ name: "招待したユーザー" });
      }
    }
  }, [searchParams, setValues]);

  const handleCheckboxChange = (checked: boolean) => {
    const event = {
      target: {
        name: "agreeTerms",
        value: checked ? "true" : "",
      },
    } as React.ChangeEvent<HTMLInputElement>;
    handleChange(event);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {referrerInfo && (
        <div className="bg-teal-50 p-3 rounded-md border border-teal-100 mb-4 text-center">
          <div className="flex items-center justify-center mb-2">
            <Users className="h-5 w-5 text-teal-600 mr-2" />
            <span className="text-sm font-medium text-teal-800">
              友達からの招待
            </span>
          </div>
          <p className="text-xs text-teal-700">
            {referrerInfo.name}
            さんから招待されました。登録すると、あなたも招待した方も1,000円分のエコポイントが獲得できます！
          </p>
        </div>
      )}

      <div className="space-y-2 text-left">
        <Label htmlFor="name">お名前</Label>
        <Input
          id="name"
          name="name"
          placeholder="山田 太郎"
          value={values.name}
          onChange={handleChange}
          onFocus={() => clearFieldError("name")}
        />
        {fieldErrors.name && <ErrorDisplay error={fieldErrors.name} />}
      </div>

      <div className="space-y-2 text-left">
        <Label htmlFor="email">メールアドレス</Label>
        <Input
          id="email"
          name="email"
          type="email"
          placeholder="your@email.com"
          value={values.email}
          onChange={handleChange}
          onFocus={() => clearFieldError("email")}
        />
        {fieldErrors.email && <ErrorDisplay error={fieldErrors.email} />}
      </div>

      <div className="space-y-2 text-left">
        <Label htmlFor="password">パスワード</Label>
        <Input
          id="password"
          name="password"
          type="password"
          placeholder="********"
          value={values.password}
          onChange={handleChange}
          onFocus={() => clearFieldError("password")}
        />
        <p className="text-xs text-stone-500">
          8文字以上で、英数字と記号を含めてください
        </p>
        {fieldErrors.password && <ErrorDisplay error={fieldErrors.password} />}
      </div>

      <div className="space-y-2 text-left">
        <Label htmlFor="confirmPassword">パスワード（確認）</Label>
        <Input
          id="confirmPassword"
          name="confirmPassword"
          type="password"
          placeholder="********"
          value={values.confirmPassword}
          onChange={handleChange}
          onFocus={() => clearFieldError("confirmPassword")}
        />
        {fieldErrors.confirmPassword && (
          <ErrorDisplay error={fieldErrors.confirmPassword} />
        )}
      </div>

      <div className="space-y-2 text-left">
        <Label htmlFor="referralCode" className="text-sm">
          招待コード（任意）
        </Label>
        <Input
          id="referralCode"
          name="referralCode"
          placeholder="例：ECO1234"
          value={values.referralCode}
          onChange={handleChange}
          onFocus={() => clearFieldError("referralCode")}
          className="border-stone-200"
        />
        {fieldErrors.referralCode && (
          <ErrorDisplay error={fieldErrors.referralCode} />
        )}
      </div>

      <div className="flex items-start space-x-2 text-left">
        <Checkbox
          id="terms"
          checked={values.agreeTerms === "true"}
          onCheckedChange={handleCheckboxChange}
          className="mt-1"
        />
        <Label htmlFor="terms" className="text-sm text-stone-700">
          <span>
            <Link href="/terms" className="text-teal-700 hover:underline">
              利用規約
            </Link>
            と
            <Link href="/privacy" className="text-teal-700 hover:underline">
              プライバシーポリシー
            </Link>
            に同意します
          </span>
        </Label>
      </div>
      {fieldErrors.agreeTerms && (
        <ErrorDisplay error={fieldErrors.agreeTerms} />
      )}

      {error && <ErrorDisplay error={error} />}

      <Button
        type="submit"
        className="w-full bg-teal-700 hover:bg-teal-800 text-white"
        disabled={isLoading}
      >
        {isLoading ? "登録中..." : "登録する"}
      </Button>

      <div className="text-center text-sm text-stone-600">
        アカウントをお持ちの方は
        <Link href="/auth/login" className="text-teal-700 hover:underline ml-1">
          ログイン
        </Link>
      </div>

      <div className="flex items-center pt-3 mt-2">
        <Leaf className="h-4 w-4 text-teal-600 mr-2" />
        <p className="text-xs text-stone-600">
          登録すると、毎月の環境貢献レポートを受け取れます。
        </p>
      </div>
    </form>
  );
}

// フォールバックコンポーネント（ローディング状態を表示）
function LoadingForm() {
  return <div>ロード中...</div>;
}

// メインコンポーネント
export default function RegisterPage() {
  return (
    <AuthLayout title="新規登録" subtitle="シンプルで環境に優しい決済サービス">
      <Suspense fallback={<LoadingForm />}>
        <RegisterFormContent />
      </Suspense>
    </AuthLayout>
  );
}
</file>

<file path="src/app/eco-news/page.tsx">
import { NewsPage } from "@/features/eco-news";

export default function EcoNewsPageRoute() {
  return <NewsPage />;
}
</file>

<file path="src/app/notifications/page.tsx">
"use client";

import { useRouter } from "next/navigation";
import Link from "next/link";
import { PageContainer } from "@/features/layout";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Bell, Settings, ChevronRight } from "lucide-react";
import {
  NotificationList,
  useNotificationStore,
  type Notification,
} from "@/features/notifications";

export default function NotificationsPage() {
  const router = useRouter();
  const {
    notifications,
    markAsRead,
    markAllAsRead,
    setNotifications,
    getUnreadCount,
  } = useNotificationStore();

  // 未読の通知数をカウント
  const unreadCount = getUnreadCount();

  // 通知をクリックしたときの処理
  const handleNotificationClick = (notification: Notification) => {
    // 未読を既読に変更
    if (!notification.isRead) {
      markAsRead(notification.id);
    }

    // リンクがあればリダイレクト
    if (notification.link) {
      router.push(notification.link);
    } else {
      // 詳細ページがあれば詳細ページに遷移
      router.push(`/notifications/${notification.id}`);
    }
  };

  return (
    <PageContainer title="通知" showNotifications={false}>
      <div className="flex justify-between items-center mb-2">
        <h2 className="text-xl font-semibold text-stone-800 flex items-center">
          <Bell className="h-5 w-5 mr-2 text-stone-600" />
          通知
          {unreadCount > 0 && (
            <Badge className="ml-2 bg-teal-100 text-teal-800">
              {unreadCount}件の未読
            </Badge>
          )}
        </h2>

        {unreadCount > 0 && (
          <Button
            variant="ghost"
            size="sm"
            className="text-xs text-stone-600"
            onClick={markAllAsRead}
          >
            すべて既読にする
          </Button>
        )}
      </div>

      <NotificationList
        notifications={notifications}
        onNotificationClick={handleNotificationClick}
        onNotificationsUpdate={setNotifications}
      />

      <div className="mt-4">
        <Link href="/settings?tab=notifications">
          <Button
            variant="outline"
            className="w-full text-sm border-stone-200 flex items-center justify-between"
          >
            <div className="flex items-center">
              <Settings className="h-4 w-4 mr-2" />
              通知設定を変更する
            </div>
            <ChevronRight className="h-4 w-4" />
          </Button>
        </Link>
      </div>
    </PageContainer>
  );
}
</file>

<file path="src/features/auth/components/LoginForm/index.ts">
// Result型対応版（推奨）
export { LoginFormContainer } from "./LoginFormContainer";
export { LoginFormView } from "./LoginFormView";

// 従来版（後方互換性のため残存）
export { LoginForm } from "./LoginForm";

// デフォルトエクスポート（Result型対応版）
export { LoginFormContainer as default } from "./LoginFormContainer";
</file>

<file path="src/features/auth/hooks/useAuthForm.ts">
"use client";

import { useState, FormEvent } from "react";
import { Result } from "neverthrow";
import { AppError } from "@/shared/types/errors";

// Result型対応のバリデーション型定義
export interface ValidationResult {
  isValid: boolean;
  errors: Record<string, AppError | null>;
}

// フォームバリデーション関数の型定義
export type FormValidationFunction = (
  values: Record<string, string>,
) => ValidationResult;

interface UseAuthFormConfig {
  initialValues: Record<string, string>;
  validateForm: FormValidationFunction;
  onSubmit: (values: Record<string, string>) => Promise<Result<void, AppError>>;
}

export function useAuthForm({
  initialValues,
  validateForm,
  onSubmit,
}: UseAuthFormConfig) {
  const [values, setValues] = useState(initialValues);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<AppError | null>(null);
  const [fieldErrors, setFieldErrors] = useState<
    Record<string, AppError | null>
  >({});

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues((prev) => ({ ...prev, [name]: value }));

    // フィールド変更時にそのフィールドのエラーをクリア
    if (fieldErrors[name]) {
      setFieldErrors((prev) => ({ ...prev, [name]: null }));
    }
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError(null);

    // フォームバリデーション
    const validation = validateForm(values);
    setFieldErrors(validation.errors);

    if (!validation.isValid) {
      return;
    }

    setIsLoading(true);

    try {
      const result = await onSubmit(values);

      result.match(
        () => {
          // 成功時の処理（何もしない、呼び出し元で処理）
        },
        (err) => {
          setError(err);
        },
      );
    } catch (err) {
      // 予期しないエラーの場合
      setError({
        type: "SERVER_ERROR",
        message:
          err instanceof Error ? err.message : "予期しないエラーが発生しました",
        statusCode: 500,
      });
    } finally {
      setIsLoading(false);
    }
  };

  const clearError = () => {
    setError(null);
  };

  const clearFieldError = (fieldName: string) => {
    setFieldErrors((prev) => ({ ...prev, [fieldName]: null }));
  };

  const clearAllErrors = () => {
    setError(null);
    setFieldErrors({});
  };

  return {
    values,
    setValues,
    fieldErrors,
    isLoading,
    error,
    handleChange,
    handleSubmit,
    clearError,
    clearFieldError,
    clearAllErrors,
  };
}
</file>

<file path="src/features/auth/utils/validation.ts">
/**
 * 認証フォーム用のバリデーション関数
 */

import { AppError } from "@/shared/types/errors";
import {
  validateEmailResult,
  validatePasswordResult,
  validateRequiredField,
  validatePasswordConfirmation,
  validatePhoneResult,
  validateAmountResult,
} from "@/lib/utils/validation";
import { ValidationResult } from "../hooks/useAuthForm";

/**
 * ログインフォームのバリデーション
 */
export function validateLoginForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // メールアドレスの検証
  const emailResult = validateEmailResult(values.email || "");
  if (emailResult.isErr()) {
    errors.email = emailResult.error;
    isValid = false;
  } else {
    errors.email = null;
  }

  // パスワードの検証（ログイン時は必須チェックのみ）
  const passwordResult = validateRequiredField(
    values.password || "",
    "パスワード",
  );
  if (passwordResult.isErr()) {
    errors.password = passwordResult.error;
    isValid = false;
  } else {
    errors.password = null;
  }

  return { isValid, errors };
}

/**
 * 寄付フォームのバリデーション
 */
export function validateDonationForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // 金額の検証
  const amountResult = validateAmountResult(values.amount || "", 1, 1000000);
  if (amountResult.isErr()) {
    errors.amount = amountResult.error;
    isValid = false;
  } else {
    errors.amount = null;
  }

  return { isValid, errors };
}

/**
 * 登録フォームのバリデーション
 */
export function validateRegisterForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // 名前の検証
  const nameResult = validateRequiredField(values.name || "", "お名前");
  if (nameResult.isErr()) {
    errors.name = nameResult.error;
    isValid = false;
  } else {
    errors.name = null;
  }

  // メールアドレスの検証
  const emailResult = validateEmailResult(values.email || "");
  if (emailResult.isErr()) {
    errors.email = emailResult.error;
    isValid = false;
  } else {
    errors.email = null;
  }

  // パスワードの検証
  const passwordResult = validatePasswordResult(values.password || "");
  if (passwordResult.isErr()) {
    errors.password = passwordResult.error;
    isValid = false;
  } else {
    errors.password = null;
  }

  // パスワード確認の検証
  const confirmPasswordResult = validatePasswordConfirmation(
    values.password || "",
    values.confirmPassword || "",
  );
  if (confirmPasswordResult.isErr()) {
    errors.confirmPassword = confirmPasswordResult.error;
    isValid = false;
  } else {
    errors.confirmPassword = null;
  }

  // 利用規約同意の検証
  if (!values.agreeTerms || values.agreeTerms !== "true") {
    errors.agreeTerms = {
      type: "REQUIRED_FIELD",
      message: "利用規約とプライバシーポリシーに同意してください",
      field: "agreeTerms",
    };
    isValid = false;
  } else {
    errors.agreeTerms = null;
  }

  // 招待コードの検証（任意項目だが、入力されている場合は形式チェック）
  if (values.referralCode && values.referralCode.trim() !== "") {
    if (!values.referralCode.startsWith("ECO")) {
      errors.referralCode = {
        type: "INVALID_FORMAT",
        message: "招待コードはECOから始まる英数字である必要があります",
        field: "referralCode",
        expected: "ECOから始まる英数字",
      };
      isValid = false;
    } else {
      errors.referralCode = null;
    }
  } else {
    errors.referralCode = null;
  }

  return { isValid, errors };
}

/**
 * パスワードリセットフォームのバリデーション
 */
export function validateForgotPasswordForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // メールアドレスの検証
  const emailResult = validateEmailResult(values.email || "");
  if (emailResult.isErr()) {
    errors.email = emailResult.error;
    isValid = false;
  } else {
    errors.email = null;
  }

  return { isValid, errors };
}

/**
 * パスワード変更フォームのバリデーション
 */
export function validateChangePasswordForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // 現在のパスワードの検証
  const currentPasswordResult = validateRequiredField(
    values.currentPassword || "",
    "現在のパスワード",
  );
  if (currentPasswordResult.isErr()) {
    errors.currentPassword = currentPasswordResult.error;
    isValid = false;
  } else {
    errors.currentPassword = null;
  }

  // 新しいパスワードの検証
  const newPasswordResult = validatePasswordResult(values.newPassword || "");
  if (newPasswordResult.isErr()) {
    errors.newPassword = newPasswordResult.error;
    isValid = false;
  } else {
    errors.newPassword = null;
  }

  // 新しいパスワード確認の検証
  const confirmNewPasswordResult = validatePasswordConfirmation(
    values.newPassword || "",
    values.confirmNewPassword || "",
  );
  if (confirmNewPasswordResult.isErr()) {
    errors.confirmNewPassword = confirmNewPasswordResult.error;
    isValid = false;
  } else {
    errors.confirmNewPassword = null;
  }

  return { isValid, errors };
}

/**
 * プロフィール更新フォームのバリデーション
 */
export function validateProfileForm(
  values: Record<string, string>,
): ValidationResult {
  const errors: Record<string, AppError | null> = {};
  let isValid = true;

  // 名前の検証
  const nameResult = validateRequiredField(values.name || "", "氏名");
  if (nameResult.isErr()) {
    errors.name = nameResult.error;
    isValid = false;
  } else {
    errors.name = null;
  }

  // メールアドレスの検証
  const emailResult = validateEmailResult(values.email || "");
  if (emailResult.isErr()) {
    errors.email = emailResult.error;
    isValid = false;
  } else {
    errors.email = null;
  }

  // 電話番号の検証
  const phoneResult = validatePhoneResult(values.phone || "");
  if (phoneResult.isErr()) {
    errors.phone = phoneResult.error;
    isValid = false;
  } else {
    errors.phone = null;
  }

  // 地域の検証
  const locationResult = validateRequiredField(values.location || "", "地域");
  if (locationResult.isErr()) {
    errors.location = locationResult.error;
    isValid = false;
  } else {
    errors.location = null;
  }

  return { isValid, errors };
}
</file>

<file path="src/features/balance/components/BalanceOverview/BalanceOverview.tsx">
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useBalanceStore } from "@/features/balance/store/balance.slice";
import { formatCurrency } from "@/shared/utils/formats";

export function BalanceOverview() {
  const { regularBalance, campaignBalances, getTotalBalance } =
    useBalanceStore();

  // 合計残高を取得
  const totalBalanceResult = getTotalBalance();
  const totalBalance = totalBalanceResult.isOk() ? totalBalanceResult.value : 0;

  // キャンペーン残高の合計を計算
  const campaignTotal = campaignBalances.reduce(
    (sum, campaign) => sum + campaign.amount,
    0,
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle>残高概要</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div>
            <p className="text-sm text-muted-foreground">合計残高</p>
            <p className="text-2xl font-bold">{formatCurrency(totalBalance)}</p>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <p className="text-sm text-muted-foreground">通常残高</p>
              <p className="text-lg font-semibold">
                {formatCurrency(regularBalance)}
              </p>
            </div>
            <div>
              <p className="text-sm text-muted-foreground">キャンペーン残高</p>
              <p className="text-lg font-semibold text-green-600">
                +{formatCurrency(campaignTotal)}
              </p>
            </div>
          </div>
          {campaignBalances.length > 0 && (
            <div className="pt-2 border-t">
              <p className="text-xs text-muted-foreground mb-2">
                キャンペーン残高の内訳
              </p>
              <div className="space-y-1">
                {campaignBalances.map((campaign) => (
                  <div
                    key={campaign.campaignId}
                    className="flex justify-between text-sm"
                  >
                    <span>{campaign.campaignName}</span>
                    <span className="font-medium">
                      {formatCurrency(campaign.amount)}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/balance/index.ts">
/**
 * 残高機能の公開API
 */

// 型定義のエクスポート
export * from "./types/balance";

// ストアのエクスポート
export { useBalanceStore } from "./store/balance.slice";
export type { BalanceState } from "./store/balance.slice";

// コンポーネントのエクスポート
export {
  BalanceCardContainer,
  BalanceCardView,
} from "./components/BalanceCard";
export { BalanceOverview } from "./components/BalanceOverview";

// フックのエクスポート（将来追加予定）
// export { useBalanceHistory } from "./hooks/useBalanceHistory";
// export { useCampaignBalances } from "./hooks/useCampaignBalances";

// ユーティリティのエクスポート（将来追加予定）
// export { formatBalanceAmount } from "./utils/formatters";
</file>

<file path="src/features/campaigns/index.ts">
// キャンペーン機能の公開API

// 型定義のエクスポート
export * from "./types/campaign";

// ストアのエクスポート
export { useCampaignStore } from "./store/campaign.slice";
export type { CampaignSlice } from "./store/campaign.slice";

// ユーティリティ関数のエクスポート
export {
  findCampaignById,
  filterActiveCampaigns,
  filterPopularCampaigns,
  filterCampaignsByType,
} from "./utils/campaign-utils";

// コンポーネントのエクスポート
export { CampaignCard } from "./components/CampaignCard";
export type { CampaignCardProps } from "./components/CampaignCard";
export { FeaturedCampaignSection } from "./components/FeaturedCampaign";
export { NotificationCampaignCard } from "./components/NotificationCampaignCard";
export type { NotificationCampaignCardProps } from "./components/NotificationCampaignCard";
export { ReferralCampaignCard } from "./components/ReferralCampaignCard";

// データのエクスポート（必要に応じて）
export { campaignsData } from "./data/campaigns-data";
</file>

<file path="src/features/charge/components/BankTransferSection/BankTransferSection.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, Leaf } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";

/**
 * 銀行振込セクションのプロパティ（AppError型対応）
 */
export interface BankTransferSectionProps {
  /** メールアドレス */
  email: string;
  /** メールアドレス更新関数 */
  setEmail: (value: string) => void;
  /** 振込金額 */
  amount: string;
  /** 振込金額更新関数 */
  setAmount: (value: string) => void;
  /** メール送信済みフラグ */
  emailSent: boolean;
  /** メール送信済みフラグ更新関数 */
  setEmailSent: (value: boolean) => void;
  /** ローディング状態 */
  isLoading: boolean;
  /** メールアドレス有効性 */
  isValidEmail: boolean;
  /** 金額有効性 */
  isValidAmount: boolean;
  /** エラー状態 */
  error: AppError | null;
  /** 金額選択ハンドラー */
  handleSelectAmount: (value: string) => void;
  /** 銀行振込メール送信ハンドラー */
  handleSendBankTransferEmail: () => void;
  /** 振込コード */
  transferCode: string;
  /** 振込コード更新関数 */
  setTransferCode: (value: string) => void;
  /** 振込確認処理中フラグ */
  processingVerification: boolean;
  /** 振込通知ハンドラー */
  handleNotifyBankTransfer: () => void;
}

/**
 * 銀行振込用の入力と表示を行うコンポーネント
 */
export function BankTransferSection({
  email,
  setEmail,
  amount,
  setAmount,
  emailSent,
  setEmailSent,
  isLoading,
  isValidEmail,
  isValidAmount,
  error,
  handleSelectAmount,
  handleSendBankTransferEmail,
  transferCode,
  setTransferCode,
  processingVerification,
  handleNotifyBankTransfer,
}: BankTransferSectionProps) {
  /**
   * メール入力フォームの表示
   */
  const renderEmailForm = () => (
    <>
      <div className="text-sm text-stone-700 space-y-2">
        <p>銀行振込の詳細を送信するメールアドレスを入力してください:</p>
        <div className="space-y-2">
          <Label htmlFor="email" className="text-sm">
            メールアドレス
          </Label>
          <Input
            id="email"
            type="email"
            placeholder="your@email.com"
            className="border-stone-300"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="bank-amount" className="text-sm">
            振込金額
          </Label>
          <div className="flex items-center space-x-2">
            <Input
              id="bank-amount"
              type="number"
              placeholder="5,000"
              className="border-stone-300"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
            />
            <span className="text-sm text-stone-600">円</span>
          </div>
        </div>

        <div className="flex justify-between text-sm text-stone-600 px-1">
          <span>おすすめ金額:</span>
          <div className="space-x-2">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
              onClick={() => handleSelectAmount("5000")}
            >
              5,000円
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
              onClick={() => handleSelectAmount("10000")}
            >
              10,000円
            </Button>
          </div>
        </div>

        {error && <ErrorDisplay error={error} />}
      </div>

      <Button
        className="w-full bg-teal-700 hover:bg-teal-800 text-white"
        onClick={handleSendBankTransferEmail}
        disabled={isLoading || !isValidEmail || !isValidAmount}
      >
        {isLoading ? (
          <>
            <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-white rounded-full"></div>
            送信中...
          </>
        ) : (
          "振込情報を取得する"
        )}
      </Button>
    </>
  );

  /**
   * 振込情報の表示
   */
  const renderTransferInfo = () => (
    <>
      <div className="bg-green-50 p-3 rounded-md border border-green-100 mb-4">
        <div className="flex items-start">
          <CheckCircle className="h-4 w-4 text-green-600 mt-0.5 mr-2" />
          <div className="text-sm text-green-700">
            メールを送信しました。以下の情報をもとに銀行振込を行ってください。
          </div>
        </div>
      </div>

      <div className="text-sm text-stone-700 space-y-2">
        <p>以下の口座へお振込みください:</p>
        <div className="bg-stone-100 p-3 rounded-md text-stone-800 font-mono text-xs">
          <div>銀行名: エコバンク</div>
          <div>支店名: 環境支店（001）</div>
          <div>口座番号: 12345678</div>
          <div>振込コード: {transferCode}</div>
          <div>振込金額: ¥{Number(amount).toLocaleString()}</div>
        </div>
        <p className="text-xs text-red-600 mt-2">
          ※振込時の「お客様情報」欄に必ず上記の振込コードをご入力ください
        </p>
        <p className="text-xs text-teal-600 mt-2 flex items-center">
          <Leaf className="h-3 w-3 mr-1" />
          振込時に「エコ寄付」と入れていただくと、金額の1%が環境保全に寄付されます
        </p>
      </div>

      <Separator className="my-4" />

      <div className="text-sm text-stone-700">
        <p>振込完了後、通常1-2営業日以内に自動的に残高に反映されます。</p>

        {error && <ErrorDisplay error={error} />}
      </div>

      <Button
        variant="outline"
        className="w-full text-stone-600 mt-3"
        onClick={handleNotifyBankTransfer}
        disabled={processingVerification}
      >
        {processingVerification ? (
          <>
            <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-stone-600 rounded-full"></div>
            確認中...
          </>
        ) : (
          "反映されない場合はこちらをお試しください"
        )}
      </Button>

      <Button
        variant="ghost"
        className="w-full text-stone-500 mt-2"
        onClick={() => {
          setEmailSent(false);
          setTransferCode("");
        }}
        disabled={processingVerification}
      >
        振込情報をやり直す
      </Button>
    </>
  );

  // メール送信前か送信後かで表示を切り替え
  return emailSent ? renderTransferInfo() : renderEmailForm();
}
</file>

<file path="src/features/charge/components/ChargeConfirm/ChargeConfirm.tsx">
import { Button } from "@/components/ui/button";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { ArrowLeft, Leaf } from "lucide-react";
import { Session } from "next-auth";
import { ErrorDisplay } from "@/components/ui/error-display";
import type { AppError } from "@/shared/types/errors";

interface ChargeConfirmProps {
  amount: string;
  paymentMethod: "credit-card" | "bank";
  session: Session | null;
  isLoading: boolean;
  error: AppError | null;
  handleConfirmCharge: () => Promise<void>;
  handleBackToInput: () => void;
}

export function ChargeConfirm({
  amount,
  paymentMethod,
  session,
  isLoading,
  error,
  handleConfirmCharge,
  handleBackToInput,
}: ChargeConfirmProps) {
  return (
    <>
      <CardHeader className="pb-2">
        <div className="flex items-center">
          <Button
            variant="ghost"
            size="sm"
            className="mr-2 h-8 w-8 p-0"
            onClick={handleBackToInput}
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>
          <div>
            <CardTitle className="text-xl text-teal-800">
              チャージ確認
            </CardTitle>
            <CardDescription>内容をご確認ください</CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="bg-stone-50 p-4 rounded-md">
          <div className="flex justify-between mb-2">
            <span className="text-sm text-stone-600">チャージ方法:</span>
            <span className="text-sm font-medium text-stone-800">
              {paymentMethod === "credit-card"
                ? "クレジットカード"
                : "銀行振込"}
            </span>
          </div>
          <div className="flex justify-between mb-2">
            <span className="text-sm text-stone-600">チャージ金額:</span>
            <span className="text-lg font-bold text-teal-800">
              ¥{Number(amount).toLocaleString()}
            </span>
          </div>
          <Separator className="my-3" />
          <div className="flex justify-between">
            <span className="text-sm text-stone-600">チャージ後残高:</span>
            <span className="text-sm font-medium text-stone-800">
              ¥
              {(
                (session?.user?.balance || 0) + Number(amount)
              ).toLocaleString()}
            </span>
          </div>
        </div>

        <div className="bg-teal-50 p-3 rounded-md border border-teal-100">
          <div className="flex items-start">
            <Leaf className="h-4 w-4 text-teal-600 mt-0.5 mr-2" />
            <div className="text-xs text-teal-700">
              Eco Walletでは、全ての取引で環境に配慮した電子決済を採用し、
              紙の使用を削減しています。また、チャージ金額の0.5%を自動的に環境保全団体へ寄付します。
            </div>
          </div>
        </div>

        {error && <ErrorDisplay error={error} variant="inline" />}
      </CardContent>
      <CardFooter className="flex flex-col space-y-2">
        <Button
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          onClick={handleConfirmCharge}
          disabled={isLoading}
        >
          {isLoading ? (
            <>
              <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-white rounded-full"></div>
              処理中...
            </>
          ) : (
            "チャージを確定する"
          )}
        </Button>
        <Button
          variant="ghost"
          className="w-full text-stone-600 hover:text-stone-800 hover:bg-stone-100"
          onClick={handleBackToInput}
          disabled={isLoading}
        >
          戻る
        </Button>
      </CardFooter>
    </>
  );
}
</file>

<file path="src/features/charge/components/ChargeInput/BankTransferInput.tsx">
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, Leaf } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";

/**
 * 銀行振込入力フォームのプロパティ（AppError型対応）
 */
export interface BankTransferInputProps {
  /** メールアドレス */
  email: string;
  /** メールアドレス更新関数 */
  setEmail: (value: string) => void;
  /** 振込金額 */
  amount: string;
  /** 振込金額更新関数 */
  setAmount: (value: string) => void;
  /** メール送信済みフラグ */
  emailSent: boolean;
  /** ローディング状態 */
  isLoading: boolean;
  /** メールアドレス有効性 */
  isValidEmail: boolean;
  /** 金額有効性 */
  isValidAmount: boolean;
  /** エラー状態 */
  error: AppError | null;
  /** 金額選択ハンドラー */
  handleSelectAmount: (value: string) => void;
  /** 銀行振込メール送信ハンドラー */
  handleSendBankTransferEmail: () => void;
  /** 振込コード */
  transferCode: string;
  /** 振込コード更新関数 */
  setTransferCode: (value: string) => void;
  /** 振込確認処理中フラグ */
  processingVerification: boolean;
  /** 振込通知ハンドラー */
  handleNotifyBankTransfer: () => void;
}

/**
 * 銀行振込入力フォームを表示するプレゼンテーションコンポーネント
 *
 * ユーザーが銀行振込の詳細を入力し、振込情報を取得・表示する
 */
export const BankTransferInput = React.memo(
  ({
    email,
    setEmail,
    amount,
    setAmount,
    emailSent,
    isLoading,
    isValidEmail,
    isValidAmount,
    error,
    handleSelectAmount,
    handleSendBankTransferEmail,
    transferCode,
    setTransferCode,
    processingVerification,
    handleNotifyBankTransfer,
  }: BankTransferInputProps) => {
    /**
     * メール送信前のフォームを表示
     */
    const renderEmailForm = () => (
      <>
        <div className="text-sm text-stone-700 space-y-2">
          <p>銀行振込の詳細を送信するメールアドレスを入力してください:</p>
          <div className="space-y-2">
            <Label htmlFor="email" className="text-sm">
              メールアドレス
            </Label>
            <Input
              id="email"
              type="email"
              placeholder="your@email.com"
              className="border-stone-300"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="bank-amount" className="text-sm">
              振込金額
            </Label>
            <div className="flex items-center space-x-2">
              <Input
                id="bank-amount"
                type="number"
                placeholder="5,000"
                className="border-stone-300"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
              />
              <span className="text-sm text-stone-600">円</span>
            </div>
          </div>

          <div className="flex justify-between text-sm text-stone-600 px-1">
            <span>おすすめ金額:</span>
            <div className="space-x-2">
              <Button
                variant="outline"
                size="sm"
                className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
                onClick={() => handleSelectAmount("5000")}
              >
                5,000円
              </Button>
              <Button
                variant="outline"
                size="sm"
                className="h-7 px-2 py-0 bg-stone-100 hover:bg-teal-50 border-stone-200"
                onClick={() => handleSelectAmount("10000")}
              >
                10,000円
              </Button>
            </div>
          </div>

          {error && <ErrorDisplay error={error} />}
        </div>

        <Button
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          onClick={handleSendBankTransferEmail}
          disabled={isLoading || !isValidEmail || !isValidAmount}
        >
          {isLoading ? (
            <>
              <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-white rounded-full"></div>
              送信中...
            </>
          ) : (
            "振込情報を取得する"
          )}
        </Button>
      </>
    );

    /**
     * 振込情報の表示
     */
    const renderTransferInfo = () => (
      <>
        <div className="bg-green-50 p-3 rounded-md border border-green-100 mb-4">
          <div className="flex items-start">
            <CheckCircle className="h-4 w-4 text-green-600 mt-0.5 mr-2" />
            <div className="text-sm text-green-700">
              メールを送信しました。以下の情報をもとに銀行振込を行ってください。
            </div>
          </div>
        </div>

        <div className="text-sm text-stone-700 space-y-2">
          <p>以下の口座へお振込みください:</p>
          <div className="bg-stone-100 p-3 rounded-md text-stone-800 font-mono text-xs">
            <div>銀行名: エコバンク</div>
            <div>支店名: 環境支店（001）</div>
            <div>口座番号: 12345678</div>
            <div>振込コード: {transferCode}</div>
            <div>振込金額: ¥{Number(amount).toLocaleString()}</div>
          </div>
          <p className="text-xs text-red-600 mt-2">
            ※振込時の「お客様情報」欄に必ず上記の振込コードをご入力ください
          </p>
          <p className="text-xs text-teal-600 mt-2 flex items-center">
            <Leaf className="h-3 w-3 mr-1" />
            振込時に「エコ寄付」と入れていただくと、金額の1%が環境保全に寄付されます
          </p>
        </div>

        <Separator className="my-4" />

        <div className="text-sm text-stone-700">
          <p>振込完了後、通常1-2営業日以内に自動的に残高に反映されます。</p>

          {error && <ErrorDisplay error={error} />}
        </div>

        <Button
          variant="outline"
          className="w-full text-stone-600 mt-3"
          onClick={handleNotifyBankTransfer}
          disabled={processingVerification}
        >
          {processingVerification ? (
            <>
              <div className="animate-spin mr-2 h-4 w-4 border-t-2 border-stone-600 rounded-full"></div>
              確認中...
            </>
          ) : (
            "反映されない場合はこちらをお試しください"
          )}
        </Button>

        <Button
          variant="ghost"
          className="w-full text-stone-500 mt-2"
          onClick={() => {
            // emailSent を false に戻す処理は親コンポーネントに移譲
            setTransferCode("");
          }}
          disabled={processingVerification}
        >
          振込情報をやり直す
        </Button>
      </>
    );

    // メール送信済みかどうかで表示内容を切り替え
    return emailSent ? renderTransferInfo() : renderEmailForm();
  },
);

BankTransferInput.displayName = "BankTransferInput";
</file>

<file path="src/features/charge/index.ts">
// チャージ機能の公開API

// 型定義のエクスポート
export * from "./types/charge";

// コンポーネントのエクスポート
export {
  ChargeInputContainer,
  ChargeInputForm,
  AmountInput,
  BankTransferInput,
} from "./components/ChargeInput";

export { BankTransferSection } from "./components/BankTransferSection";

export { ChargeConfirm } from "./components/ChargeConfirm";
export { ChargeComplete } from "./components/ChargeComplete";

export type {
  ChargeInputContainerProps,
  ChargeInputFormProps,
  AmountInputProps,
  BankTransferInputProps,
} from "./components/ChargeInput";

export type { BankTransferSectionProps } from "./components/BankTransferSection";

// ユーティリティ関数のエクスポート（将来追加予定）
// export { validateChargeAmount } from "./utils/validation";

// ストアのエクスポート（将来追加予定）
// export { useChargeStore } from "./store/charge.slice";
// export type { ChargeSlice } from "./store/charge.slice";
</file>

<file path="src/features/donation/components/DonateConfirm/DonateConfirm.tsx">
import { Button } from "@/components/ui/button";
import {
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
  CardFooter,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { ArrowLeft, Leaf } from "lucide-react";
import { Session } from "next-auth";
import { formatCurrency } from "@/shared/utils/formats";
import { DonationProject } from "@/features/donation/types/donation";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";

interface DonateConfirmProps {
  project: DonationProject;
  amount: string;
  session: Session | null;
  isLoading: boolean;
  error: AppError | null;
  handleConfirmDonation: () => Promise<void>;
  handleBackToInput: () => void;
}

export function DonateConfirm({
  project,
  amount,
  session,
  isLoading,
  error,
  handleConfirmDonation,
  handleBackToInput,
}: DonateConfirmProps) {
  const estimatedImpact = {
    forestArea:
      project.imageType === "mountain"
        ? Number(amount) * 0.0007
        : Number(amount) * 0.0003,
    waterSaved:
      project.imageType === "ocean"
        ? Number(amount) * 0.4
        : Number(amount) * 0.2,
    co2Reduction: Number(amount) * 0.015,
  };

  return (
    <>
      <CardHeader className="pb-2">
        <div className="flex items-center">
          <Button
            variant="ghost"
            size="sm"
            className="mr-2 h-8 w-8 p-0"
            onClick={handleBackToInput}
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>
          <div>
            <CardTitle className="text-xl text-teal-800">寄付確認</CardTitle>
            <CardDescription>内容をご確認ください</CardDescription>
          </div>
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        <div className="bg-stone-50 p-4 rounded-md">
          <div className="flex justify-between mb-2">
            <span className="text-sm text-stone-600">寄付先:</span>
            <span className="text-sm font-medium text-stone-800">
              {project.title}
            </span>
          </div>
          <div className="flex justify-between mb-2">
            <span className="text-sm text-stone-600">寄付金額:</span>
            <span className="text-lg font-bold text-teal-800">
              {formatCurrency(Number(amount))}
            </span>
          </div>
          <Separator className="my-3" />
          <div className="flex justify-between">
            <span className="text-sm text-stone-600">寄付後残高:</span>
            <span className="text-sm font-medium text-stone-800">
              {formatCurrency((session?.user?.balance || 0) - Number(amount))}
            </span>
          </div>
        </div>

        <div className="bg-teal-50 p-3 rounded-md border border-teal-100">
          <h3 className="text-sm font-medium text-teal-800 mb-2 flex items-center">
            <Leaf className="h-4 w-4 mr-2 text-teal-600" />
            寄付による環境貢献効果の予測
          </h3>

          <div className="space-y-2 text-xs text-teal-700">
            <div className="flex justify-between">
              <span>森林保全面積:</span>
              <span className="font-medium">
                {estimatedImpact.forestArea.toFixed(2)} m²
              </span>
            </div>
            <div className="flex justify-between">
              <span>水資源保全:</span>
              <span className="font-medium">
                {Math.round(estimatedImpact.waterSaved)} L
              </span>
            </div>
            <div className="flex justify-between">
              <span>CO2削減量:</span>
              <span className="font-medium">
                {estimatedImpact.co2Reduction.toFixed(1)} kg
              </span>
            </div>
          </div>
        </div>

        {error && (
          <ErrorDisplay error={error} variant="inline" className="mb-2" />
        )}
      </CardContent>

      <CardFooter className="flex flex-col space-y-2">
        <Button
          className="w-full bg-teal-700 hover:bg-teal-800 text-white"
          onClick={handleConfirmDonation}
          disabled={isLoading}
        >
          {isLoading ? (
            <div className="flex items-center justify-center">
              <LoadingSpinner size="sm" light className="mr-2" />
              処理中...
            </div>
          ) : (
            "寄付を確定する"
          )}
        </Button>
        <Button
          variant="ghost"
          className="w-full text-stone-600 hover:text-stone-800 hover:bg-stone-100"
          onClick={handleBackToInput}
          disabled={isLoading}
        >
          戻る
        </Button>
      </CardFooter>
    </>
  );
}
</file>

<file path="src/features/donation/types/donation.ts">
import { AppError } from "../../../shared/types/errors";

// 寄付プロジェクトの型定義
export interface DonationProject {
  id: string;
  title: string;
  description: string;
  category: string;
  targetAmount: number;
  currentAmount: number;
  progressPercent: number;
  imageType?: "forest" | "ocean" | "mountain" | "city";
  organization: string;
  endDate: string;
  impact: {
    forestArea?: number;
    co2Reduction?: number;
    waterSaved?: number;
    beneficiaries?: number;
  };
}

// 寄付情報の型定義
export interface DonationInfo {
  projectId: string;
  amount: number;
  donorName?: string;
  message?: string;
  isAnonymous: boolean;
  paymentMethod: "balance" | "credit" | "bank";
}

// 寄付の状態（AppError型対応）
export interface DonationState {
  currentProject: DonationProject | null;
  donationAmount: number;
  step: "input" | "confirm" | "complete";
  isLoading: boolean;
  error: AppError | null;
}

// 寄付フォームのデータ
export interface DonationFormData {
  amount: number;
  donorName: string;
  message: string;
  isAnonymous: boolean;
  paymentMethod: "balance" | "credit" | "bank";
}

// 寄付完了情報
export interface DonationCompleteInfo {
  transactionId: string;
  project: DonationProject;
  amount: number;
  donatedAt: string;
  ecoImpact: {
    forestArea: number;
    co2Reduction: number;
    waterSaved: number;
  };
}
</file>

<file path="src/features/donation/utils/project-converter.ts">
import { ProjectItem } from "@/features/eco-news";
import { DonationProject } from "../types/donation";

/**
 * ProjectItem を DonationProject に変換する関数
 */
export function convertProjectItemToDonationProject(
  projectItem: ProjectItem,
): DonationProject {
  return {
    id: projectItem.id,
    title: projectItem.title,
    description: projectItem.description,
    category: projectItem.category,
    targetAmount: projectItem.targetFunding,
    currentAmount: projectItem.currentFunding,
    progressPercent: projectItem.progressPercent,
    imageType:
      projectItem.imageType === "default"
        ? "forest"
        : projectItem.imageType || "forest",
    organization: "環境保全団体", // デフォルト値
    endDate: "2025/12/31", // デフォルト値
    impact: {
      // プロジェクトの種類に基づいてデフォルトの環境インパクトを設定
      forestArea:
        projectItem.imageType === "forest" ||
        projectItem.imageType === "mountain"
          ? 100
          : 0,
      co2Reduction: 50,
      waterSaved: projectItem.imageType === "ocean" ? 1000 : 500,
      beneficiaries: 1000,
    },
  };
}
</file>

<file path="src/features/donation/index.ts">
// 型定義のエクスポート
export * from "./types/donation";

// ユーティリティ関数のエクスポート
export { convertProjectItemToDonationProject } from "./utils/project-converter";

// コンポーネントのエクスポート
export {
  DonateInputContainer,
  DonateInputForm,
  AmountSelector,
  ProjectInfo,
} from "./components/DonateInput";

export { DonateConfirm } from "./components/DonateConfirm";
export { DonateComplete } from "./components/DonateComplete";
</file>

<file path="src/features/eco-impact/components/EcoImpact/EcoImpactDisplay.tsx">
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";
import { Leaf, TreePine, Droplets, Globe, ArrowRight } from "lucide-react";
import { useEcoImpact } from "@/features/eco-impact/hooks/useEcoImpact";
import { useFormattedCurrency } from "@/shared/hooks/useFormattedCurrency";

type EcoImpactVariant = "compact" | "detailed" | "transaction";

interface EcoImpactDisplayProps {
  contributionAmount: number;
  variant?: EcoImpactVariant;
  clickable?: boolean;
  className?: string;
}

export function EcoImpactDisplay({
  contributionAmount,
  variant = "detailed",
  clickable = false,
  className = "",
}: EcoImpactDisplayProps) {
  // useEcoImpactフックを使用して環境インパクト情報を取得
  const { forestArea, waterSaved, co2Reduction, impactPercent } =
    useEcoImpact(contributionAmount);
  // 金額のフォーマットを取得（ここでは直接インラインで金額を表示）
  useFormattedCurrency(contributionAmount); // フックを呼び出すが結果は使わない
  const isCompact = variant === "compact";

  // 視覚的に強化されたコンテンツ
  const ecoContent = (
    <>
      {isCompact ? (
        <div className="flex items-center justify-between">
          <div className="flex items-center text-xs">
            <Leaf className="h-3 w-3 mr-1 text-teal-600" />
            <span className="text-teal-700 font-medium">
              環境貢献：¥{contributionAmount}
            </span>
          </div>
          <div className="flex items-center text-xs text-teal-700 space-x-2">
            <div className="flex items-center">
              <TreePine className="h-3 w-3 mr-0.5 text-teal-600" />
              <span>{forestArea}m²</span>
            </div>
            <div className="flex items-center">
              <Globe className="h-3 w-3 mr-0.5 text-green-600" />
              <span>{co2Reduction}kg</span>
            </div>
          </div>
        </div>
      ) : (
        <>
          <div className="flex justify-between items-center">
            <div className="flex items-center">
              <Leaf className="h-4 w-4 text-teal-600 mr-2" />
              <span className="text-sm font-medium text-teal-800">
                環境への貢献
              </span>
            </div>
            <span className="text-xs bg-teal-100 text-teal-700 px-2 py-0.5 rounded-full">
              ¥{contributionAmount.toLocaleString()}
            </span>
          </div>

          <div className="mt-3 text-xs text-teal-700">
            <div className="mt-1">
              <div className="flex justify-between text-xs mb-1">
                <span>環境貢献度</span>
                <span className="text-teal-600 font-medium">
                  {impactPercent}%
                </span>
              </div>
              <Progress value={impactPercent} className="h-1.5 bg-teal-100" />
            </div>
          </div>

          <div className="grid grid-cols-3 gap-2 mt-3">
            <div className="bg-white bg-opacity-60 p-2 rounded-md text-center">
              <TreePine className="h-4 w-4 mx-auto text-teal-600 mb-1" />
              <p className="text-xs font-medium text-teal-800">
                {forestArea} m²
              </p>
              <p className="text-[10px] text-teal-600">森林保全</p>
            </div>

            <div className="bg-white bg-opacity-60 p-2 rounded-md text-center">
              <Droplets className="h-4 w-4 mx-auto text-blue-500 mb-1" />
              <p className="text-xs font-medium text-teal-800">
                {waterSaved} L
              </p>
              <p className="text-[10px] text-teal-600">水資源保全</p>
            </div>

            <div className="bg-white bg-opacity-60 p-2 rounded-md text-center">
              <Globe className="h-4 w-4 mx-auto text-green-600 mb-1" />
              <p className="text-xs font-medium text-teal-800">
                {co2Reduction} kg
              </p>
              <p className="text-[10px] text-teal-600">CO2削減</p>
            </div>
          </div>

          <p className="text-xs text-teal-700 mt-3 text-center">
            あなたの{contributionAmount}
            円の貢献が、地球環境の保全に繋がっています
          </p>
        </>
      )}
    </>
  );

  // コンテナクラスの設定
  // ガイドラインに準拠した色とトランジション効果
  const containerClass = cn(
    `${isCompact ? "p-2" : "p-4"} 
    bg-teal-50 border border-teal-100 rounded-md 
    eco-transition ${clickable ? "hover:bg-teal-100 hover:border-teal-200" : ""}`,
    className,
  );

  // クリック可能な場合はリンクでラップ
  if (clickable) {
    return (
      <Link href="/impact" className={containerClass}>
        {ecoContent}
      </Link>
    );
  }

  return (
    <div className={containerClass}>
      {ecoContent}
      {/* ボタンは詳細表示かつクリック不可の時のみ表示 */}
      {!isCompact && (
        <Link href="/impact" className="w-full block mt-3">
          <Button
            variant="outline"
            size="sm"
            className="w-full text-teal-700 border-teal-200 bg-white hover:bg-teal-50 eco-transition"
          >
            環境インパクト詳細を見る
            <ArrowRight className="h-3 w-3 ml-1" />
          </Button>
        </Link>
      )}
    </div>
  );
}
</file>

<file path="src/features/eco-impact/components/NewsAndProjects/NewsAndProjects.tsx">
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Newspaper, ExternalLink, TreePine, Droplets } from "lucide-react";
import { newsAndProjects, ContentItem } from "@/features/eco-news";

export function NewsAndProjects() {
  const router = useRouter();
  // 最新の2件を表示
  const latestItems = newsAndProjects.slice(0, 2);

  // 背景画像を決定する関数
  const getBackgroundImage = (item: ContentItem) => {
    // imageTypeプロパティが存在するかチェック
    if (item.imageType) {
      switch (item.imageType) {
        case "forest":
          return <TreePine className="h-12 w-12 text-teal-700 opacity-30" />;
        case "ocean":
          return <Droplets className="h-12 w-12 text-blue-500 opacity-30" />;
        case "mountain":
          return <TreePine className="h-12 w-12 text-green-700 opacity-30" />;
        default:
          return <TreePine className="h-12 w-12 text-teal-700 opacity-30" />;
      }
    }
    return <TreePine className="h-12 w-12 text-teal-700 opacity-30" />;
  };

  // バッジカラーを決定する関数
  const getBadgeColor = (item: ContentItem) => {
    if (item.type === "news") {
      return "bg-blue-100 text-blue-800";
    } else {
      return "bg-green-100 text-green-800";
    }
  };

  // ニュース詳細ページへのナビゲーション
  const navigateToNewsDetail = (id: string) => {
    router.push(`/eco-news/${id}`);
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-sm font-medium text-stone-800 flex items-center">
          <Newspaper className="h-4 w-4 mr-1 text-stone-600" />
          エコニュースとプロジェクト
        </h3>
        <Link href="/eco-news">
          <Button
            variant="ghost"
            size="sm"
            className="h-7 text-xs text-stone-500"
          >
            もっと見る
          </Button>
        </Link>
      </div>

      <div className="grid grid-cols-1 gap-3">
        {latestItems.map((item) => (
          <Card
            key={item.id}
            className="border-0 shadow-md bg-white overflow-hidden"
          >
            {item.type === "news" ? (
              <>
                <div className="aspect-[2/1] bg-teal-100 relative">
                  <div className="absolute inset-0 flex items-center justify-center">
                    {getBackgroundImage(item)}
                  </div>
                </div>
                <CardContent className="p-3">
                  <Badge className={getBadgeColor(item) + " mb-2"}>
                    {item.category}
                  </Badge>
                  <h4 className="text-sm font-medium text-stone-800">
                    {item.title}
                  </h4>
                  <p className="text-xs text-stone-600 mt-1 line-clamp-2">
                    {item.content}
                  </p>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="w-full mt-2 text-xs text-teal-700"
                    onClick={() => navigateToNewsDetail(item.id)}
                  >
                    詳細を読む
                    <ExternalLink className="h-3 w-3 ml-1" />
                  </Button>
                </CardContent>
              </>
            ) : (
              <div className="p-3">
                <Badge className={getBadgeColor(item) + " mb-2"}>
                  {item.category}
                </Badge>
                <h4 className="text-sm font-medium text-stone-800">
                  {item.title}
                </h4>
                <p className="text-xs text-stone-600 mt-1">
                  {item.description}
                </p>
                <div className="mt-2 flex justify-between items-center">
                  <div className="text-xs">
                    <span className="text-teal-700 font-medium">
                      ¥{item.currentFunding.toLocaleString()}
                    </span>
                    <span className="text-stone-500">
                      {" "}
                      / ¥{item.targetFunding.toLocaleString()}
                    </span>
                  </div>
                  <Progress
                    value={item.progressPercent}
                    className="h-1.5 w-1/2"
                  />
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full mt-2 text-xs border-teal-200 text-teal-700"
                  onClick={() => router.push(`/donate/${item.id}`)}
                >
                  寄付する
                </Button>
              </div>
            )}
          </Card>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/features/eco-impact/components/RecommendedAction/RecommendedAction.tsx">
import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Leaf } from "lucide-react";
import { recommendedActions } from "@/features/eco-impact/data/recommended-actions-data";

interface RecommendedActionProps {
  actionId?: string;
  title?: string;
  description?: string;
  actionLabel?: string;
  actionLink?: string;
}

export function RecommendedAction({
  actionId,
  title,
  description,
  actionLabel,
  actionLink,
}: RecommendedActionProps) {
  // actionIdが指定されている場合は、そのアクションを表示
  // そうでない場合は、パラメータに基づいてカスタムアクションを表示、
  // または最優先のアクションを表示
  let actionToShow;

  if (actionId) {
    actionToShow = recommendedActions.find((action) => action.id === actionId);
  } else if (title && description) {
    actionToShow = {
      id: "custom",
      title,
      description,
      actionLabel: actionLabel || "詳細を見る",
      actionLink: actionLink || "#",
      icon: "leaf",
      priority: 0,
    };
  } else {
    // 優先度順にソートして最初のアクションを取得
    actionToShow = [...recommendedActions].sort(
      (a, b) => a.priority - b.priority,
    )[0];
  }

  if (!actionToShow) return null;

  return (
    <Card className="border shadow-md bg-teal-50 p-4 border-teal-100">
      <div className="flex items-start space-x-3">
        <Leaf className="h-5 w-5 text-teal-700 mt-0.5" />
        <div>
          <h3 className="text-sm font-medium text-teal-800">
            {actionToShow.title}
          </h3>
          <p className="text-xs text-teal-700 mt-1">
            {actionToShow.description}
          </p>
          <Link href={actionToShow.actionLink}>
            <Button className="w-full mt-3 bg-teal-700 hover:bg-teal-800 text-white text-xs">
              {actionToShow.actionLabel}
            </Button>
          </Link>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/invite/index.ts">
// 招待機能の公開API

// 型定義のエクスポート
export * from "./types/invite";

// コンポーネントのエクスポート
export { QRCodeDisplay } from "./components/QRCodeDisplay";
export type { QRCodeDisplayProps } from "./components/QRCodeDisplay";

export { SocialShareButtons } from "./components/SocialShareButtons";
export type { SocialShareButtonsProps } from "./components/SocialShareButtons";

export { InviteCard } from "./components/InviteCard";

// ユーティリティ関数のエクスポート（将来追加予定）
// export { createInviteLink, validateInviteCode } from "./utils/invite-utils";

// ストアのエクスポート（将来追加予定）
// export { useInviteStore } from "./store/invite.slice";
// export type { InviteSlice } from "./store/invite.slice";
</file>

<file path="src/features/payment/components/PaymentMethodSelector/index.ts">
export { PaymentMethodSelector } from "./PaymentMethodSelector";
export { PaymentMethodSelectorContainer } from "./PaymentMethodSelectorContainer";
</file>

<file path="src/features/payment/components/PaymentMethodSelector/PaymentMethodSelector.tsx">
import React from "react";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { formatCurrency } from "@/shared/utils/formats";
import { Wallet, CreditCard as CreditCardIcon } from "lucide-react";
import type { PaymentMethod, PaymentMethodDetail } from "../../types/payment";

interface PaymentMethodSelectorProps {
  methods: PaymentMethodDetail[];
  selectedMethod: PaymentMethod;
  onMethodChange: (method: PaymentMethod) => void;
}

/**
 * 支払い方法を選択するコンポーネント
 */
export const PaymentMethodSelector: React.FC<PaymentMethodSelectorProps> = ({
  methods,
  selectedMethod,
  onMethodChange,
}) => {
  const getIcon = (method: PaymentMethod) => {
    switch (method) {
      case "wallet":
        return <Wallet className="h-5 w-5 text-teal-600" />;
      case "card":
        return <CreditCardIcon className="h-5 w-5 text-stone-600" />;
      default:
        return null;
    }
  };

  return (
    <RadioGroup
      value={selectedMethod}
      onValueChange={(value) => onMethodChange(value as PaymentMethod)}
      className="space-y-3"
    >
      {methods.map((method) => {
        const formattedBalance = method.balance
          ? formatCurrency(method.balance)
          : undefined;
        const isSelected = selectedMethod === method.type;

        return (
          <div
            key={method.type}
            className={`
              relative rounded-lg border p-4 transition-all duration-200 cursor-pointer
              ${
                isSelected
                  ? "border-teal-500 bg-teal-50 shadow-sm"
                  : "border-stone-200 hover:border-stone-300 hover:shadow-sm"
              }
              ${
                method.isDisabled
                  ? "opacity-50 cursor-not-allowed"
                  : "hover:bg-stone-50"
              }
            `}
          >
            <Label
              htmlFor={method.type}
              className={`
                flex items-start space-x-3 cursor-pointer
                ${method.isDisabled ? "cursor-not-allowed" : ""}
              `}
            >
              <RadioGroupItem
                value={method.type}
                id={method.type}
                disabled={method.isDisabled}
                className="mt-0.5"
              />
              <div className="flex-1 flex items-center space-x-3">
                {getIcon(method.type)}
                <div className="flex-1">
                  <div className="flex justify-between items-center">
                    <span
                      className={`
                      font-medium 
                      ${isSelected ? "text-teal-800" : "text-stone-800"}
                    `}
                    >
                      {method.label}
                    </span>
                    {method.type === "wallet" && formattedBalance && (
                      <span
                        className={`
                        text-sm font-semibold
                        ${isSelected ? "text-teal-700" : "text-stone-700"}
                      `}
                      >
                        {formattedBalance}
                      </span>
                    )}
                    {method.cardLast4 && (
                      <span className="text-sm text-stone-500">
                        {method.cardBrand} ****{method.cardLast4}
                      </span>
                    )}
                  </div>
                  {method.type === "wallet" && formattedBalance && (
                    <p className="text-xs text-stone-500 mt-1">
                      現在の残高から支払います
                    </p>
                  )}
                  {method.isDisabled && (
                    <p className="text-xs text-red-600 mt-1">
                      残高が不足しています
                    </p>
                  )}
                </div>
              </div>
            </Label>
          </div>
        );
      })}
    </RadioGroup>
  );
};
</file>

<file path="src/features/payment/store/payment.slice.ts">
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { PaymentStore, PaymentStatus } from "../types/payment";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { processPayment as businessProcessPayment } from "@/lib/business/payment";
import { getErrorMessage } from "@/lib/utils/error-utils";

const initialState = {
  paymentInfo: null,
  paymentStatus: "idle" as PaymentStatus,
  error: null,
};

export const usePaymentStore = create<PaymentStore>()(
  devtools(
    (set, get) => ({
      ...initialState,

      setPaymentInfo: (info) => set({ paymentInfo: info, error: null }),

      setPaymentMethod: (method) =>
        set((state) => ({
          paymentInfo: state.paymentInfo
            ? { ...state.paymentInfo, selectedPaymentMethod: method }
            : null,
        })),

      setPaymentOptions: (options) =>
        set((state) => {
          if (!state.paymentInfo) return state;

          const updatedOptions = { ...state.paymentInfo.options, ...options };
          const donationAmount = updatedOptions.includeDonation
            ? updatedOptions.donationAmount
            : 0;
          const total = state.paymentInfo.subtotal + donationAmount;

          return {
            paymentInfo: {
              ...state.paymentInfo,
              options: updatedOptions,
              donationAmount,
              total,
            },
          };
        }),

      processPayment: async () => {
        const state = get();
        if (!state.paymentInfo) {
          return { success: false, error: "Payment info not set" };
        }

        // paymentInfoを変数に保存してnullチェック問題を回避
        const paymentInfo = state.paymentInfo;

        set({ paymentStatus: "processing", error: null });

        // ビジネスロジック層への決済パラメータ作成
        const paymentParams = {
          amount: paymentInfo.total,
          paymentMethod:
            paymentInfo.selectedPaymentMethod === "wallet"
              ? ("bank_transfer" as const)
              : ("credit_card" as const),
          description: paymentInfo.product.name,
          metadata: {
            productId: paymentInfo.product.id,
            ecoFriendly: paymentInfo.product.isEcoFriendly,
            donationIncluded: paymentInfo.options.includeDonation,
            donationAmount: paymentInfo.donationAmount,
          },
        };

        // ビジネスロジック層の決済処理を実行
        const result = await businessProcessPayment(paymentParams);

        return result.match(
          (paymentState) => {
            // 成功時の処理
            // トランザクションストアから関数を取得
            const addTransaction =
              useTransactionStore.getState().addTransaction;

            // 新しいトランザクションを作成
            const newTransaction = {
              type: "payment" as const,
              description: paymentInfo.product.name,
              date: new Date()
                .toLocaleDateString("ja-JP", {
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                })
                .replace(/\//g, "/"),
              amount: -paymentInfo.total,
              ecoContribution: paymentInfo.options.includeDonation
                ? {
                    enabled: true,
                    amount: paymentInfo.donationAmount,
                  }
                : undefined,
              badges: paymentInfo.product.isEcoFriendly ? ["環境貢献"] : [],
            };

            // トランザクションをストアに追加して、生成されたIDを取得
            const transactionId = addTransaction(newTransaction);

            set({ paymentStatus: "success" });

            return {
              success: true,
              transactionId: paymentState.transactionId || transactionId,
            };
          },
          (businessError) => {
            // エラー時の処理
            const errorMessage = getErrorMessage(businessError);
            set({ paymentStatus: "error", error: errorMessage });
            return { success: false, error: errorMessage };
          },
        );
      },

      resetPayment: () => set(initialState),
    }),
    {
      name: "payment-store",
    },
  ),
);
</file>

<file path="src/features/payment/index.ts">
// Types
export type {
  Product,
  PaymentMethod,
  PaymentMethodDetail,
  PaymentOptions,
  PaymentInfo,
  PaymentStatus,
  PaymentStore,
} from "./types/payment";

// Components
export { ProductInfo } from "./components/ProductInfo";
export { PaymentSummary } from "./components/PaymentSummary";
export {
  PaymentMethodSelector,
  PaymentMethodSelectorContainer,
} from "./components/PaymentMethodSelector";
export { PaymentOptions as PaymentOptionsComponent } from "./components/PaymentOptions";

// Store
export { usePaymentStore } from "./store/payment.slice";

// Data
export {
  mockProducts,
  mockPaymentMethods,
  defaultPaymentOptions,
} from "./data/payment-data";
</file>

<file path="src/features/qrcode/hooks/index.ts">
export { useQRCodeGenerator } from "./useQRCodeGenerator";
export { useQRCodeScanner } from "./useQRCodeScanner";
</file>

<file path="src/features/qrcode/hooks/useQRCodeGenerator.ts">
"use client";

/**
 * QRコード生成用のカスタムフック
 */

import { useState, useEffect, useCallback, useRef } from "react";
import { QRCodeType, QRCodeContent } from "../types/qrcode";
import {
  createQRCodeContent,
  formatTimeLeft,
  isQRCodeValid,
  QR_CODE_EXPIRATION,
} from "../utils/qrcode-utils";

interface UseQRCodeGeneratorProps {
  type: QRCodeType;
  initialData?: string;
  autoRefresh?: boolean;
}

interface UseQRCodeGeneratorReturn {
  qrContent: QRCodeContent | null;
  timeLeft: number;
  formattedTimeLeft: string;
  isExpired: boolean;
  isGenerating: boolean;
  error: string | null;
  generateNewCode: () => void;
  resetTimer: () => void;
}

export const useQRCodeGenerator = ({
  type,
  initialData = "",
  autoRefresh = true,
}: UseQRCodeGeneratorProps): UseQRCodeGeneratorReturn => {
  const [qrContent, setQrContent] = useState<QRCodeContent | null>(null);
  const [timeLeft, setTimeLeft] = useState(0);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // QRコードを生成
  const generateNewCode = useCallback(() => {
    try {
      setIsGenerating(true);
      setError(null);

      const expirationMinutes =
        QR_CODE_EXPIRATION[
          type.toUpperCase() as keyof typeof QR_CODE_EXPIRATION
        ] / 60;
      const content = createQRCodeContent(type, initialData, expirationMinutes);

      setQrContent(content);
      setTimeLeft(expirationMinutes * 60);
    } catch (err) {
      setError("QRコードの生成に失敗しました");
      console.error("QR code generation error:", err);
    } finally {
      setIsGenerating(false);
    }
  }, [type, initialData]);

  // タイマーをリセット
  const resetTimer = useCallback(() => {
    if (qrContent?.expiresAt) {
      const now = new Date();
      const expiresAt = new Date(qrContent.expiresAt);
      const secondsLeft = Math.max(
        0,
        Math.floor((expiresAt.getTime() - now.getTime()) / 1000),
      );
      setTimeLeft(secondsLeft);
    }
  }, [qrContent]);

  // 初回生成
  useEffect(() => {
    generateNewCode();
  }, [generateNewCode]);

  // タイマー処理
  useEffect(() => {
    if (!qrContent) return;

    // 既存のタイマーをクリア
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }

    // 新しいタイマーを設定
    intervalRef.current = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev <= 1) {
          // 自動更新が有効な場合は新しいコードを生成
          if (autoRefresh) {
            generateNewCode();
            return 0;
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    // クリーンアップ
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [qrContent, autoRefresh, generateNewCode]);

  // 有効期限チェック
  const isExpired = qrContent ? !isQRCodeValid(qrContent.expiresAt) : false;

  return {
    qrContent,
    timeLeft,
    formattedTimeLeft: formatTimeLeft(timeLeft),
    isExpired,
    isGenerating,
    error,
    generateNewCode,
    resetTimer,
  };
};
</file>

<file path="src/features/qrcode/hooks/useQRCodeScanner.ts">
"use client";

import { useState, useCallback, useRef, useEffect, RefObject } from "react";
import type { QRCodeScanResult } from "../types/qrcode";

interface UseQRCodeScannerProps {
  videoRef: RefObject<HTMLVideoElement | null>;
  canvasRef: RefObject<HTMLCanvasElement | null>;
  onScan?: (result: QRCodeScanResult) => void;
  scanInterval?: number;
}

export const useQRCodeScanner = ({
  videoRef,
  canvasRef,
  onScan,
  scanInterval = 100,
}: UseQRCodeScannerProps) => {
  const [scanResult, setScanResult] = useState<QRCodeScanResult | null>(null);
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [isCameraLoading, setIsCameraLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const streamRef = useRef<MediaStream | null>(null);
  const scanIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastScannedDataRef = useRef<string | null>(null);

  // スキャンを停止
  const stopScanning = useCallback(() => {
    if (scanIntervalRef.current) {
      clearInterval(scanIntervalRef.current);
      scanIntervalRef.current = null;
    }
  }, []);

  // QRコードのスキャンを開始
  const startScanning = useCallback(() => {
    if (!videoRef.current || !canvasRef.current) return;

    const video = videoRef.current;
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");

    if (!context) return;

    // キャンバスのサイズをビデオに合わせる
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // 定期的にスキャンを実行
    scanIntervalRef.current = setInterval(() => {
      if (!video.videoWidth || !video.videoHeight) return;

      // ビデオフレームをキャンバスに描画
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // QRコードのスキャンを試みる（実際の実装では専用のライブラリを使用）
      // ここではモックデータを使用
      // const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

      // 実際の実装では、jsQRなどのライブラリを使用してQRコードをデコード
      // import jsQR from 'jsqr';
      // const code = jsQR(imageData.data, imageData.width, imageData.height);

      // モック実装：5秒後に自動的にスキャン成功
      if (Date.now() % 5000 < scanInterval && Math.random() > 0.95) {
        const mockData = `ecowallet://payment/${Math.floor(100000 + Math.random() * 900000)}`;

        // 同じデータを連続してスキャンしないようにする
        if (mockData !== lastScannedDataRef.current) {
          lastScannedDataRef.current = mockData;
          const result: QRCodeScanResult = {
            data: mockData,
            timestamp: new Date(),
            format: "QR_CODE",
          };

          setScanResult(result);
          if (onScan) {
            onScan(result);
          }

          // スキャン成功後は自動的に停止
          stopScanning();
        }
      }
    }, scanInterval);
  }, [videoRef, canvasRef, scanInterval, onScan, stopScanning]);

  // カメラを開始
  const startCamera = useCallback(async () => {
    try {
      setIsCameraLoading(true);
      setError(null);

      // カメラへのアクセスを要求
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment", // 背面カメラを優先
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
      });

      streamRef.current = stream;

      if (videoRef.current) {
        videoRef.current.srcObject = stream;

        // ビデオの準備ができたらスキャンを開始
        videoRef.current.onloadedmetadata = () => {
          setIsCameraActive(true);
          setIsCameraLoading(false);
          startScanning();
        };
      }
    } catch (err) {
      console.error("Camera access error:", err);
      setError(
        "カメラへのアクセスができませんでした。カメラの使用を許可してください。",
      );
      setIsCameraLoading(false);
      throw err;
    }
  }, [videoRef, startScanning]);

  // カメラを停止
  const stopCamera = useCallback(() => {
    stopScanning();

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }

    setIsCameraActive(false);
    lastScannedDataRef.current = null;
  }, [videoRef, stopScanning]);

  // スキャン結果をリセット
  const resetScan = useCallback(() => {
    setScanResult(null);
    lastScannedDataRef.current = null;
    setError(null);
  }, []);

  // コンポーネントのアンマウント時にクリーンアップ
  useEffect(() => {
    return () => {
      stopCamera();
    };
  }, [stopCamera]);

  // カメラの利用可能状態をチェック
  const checkCameraAvailability = useCallback(async () => {
    try {
      await navigator.mediaDevices.getUserMedia({ video: true });
      return true;
    } catch {
      return false;
    }
  }, []);

  return {
    scanResult,
    isCameraActive,
    isCameraLoading,
    error,
    startCamera,
    stopCamera,
    resetScan,
    checkCameraAvailability,
  };
};
</file>

<file path="src/features/qrcode/types/qrcode.ts">
/**
 * QRコード関連の型定義
 */

// QRコードのタイプ
export type QRCodeType = "payment" | "transfer" | "invitation" | "general";

// QRコードの内容
export interface QRCodeContent {
  type: QRCodeType;
  data: string;
  securityCode?: string;
  expiresAt?: Date;
}

// QRコード生成オプション
export interface QRCodeGeneratorOptions {
  size?: number;
  level?: "L" | "M" | "Q" | "H";
  fgColor?: string;
  bgColor?: string;
  includeMargin?: boolean;
}

// QRコード支払い情報
export interface QRCodePaymentData {
  securityCode: string;
  amount?: number;
  merchantId?: string;
  orderId?: string;
  timestamp: Date;
}

// QRコードスキャン結果
export interface QRCodeScanResult {
  data: string;
  timestamp: Date;
  format: "QR_CODE" | "DATA_MATRIX" | "CODE_128" | "EAN_13" | "UPC_A";
}

// QRコードの状態
export interface QRCodeState {
  isGenerating: boolean;
  isScanning: boolean;
  currentCode?: QRCodeContent;
  timeLeft?: number;
  error?: string;
}

// バーコード情報
export interface BarcodeData {
  type: "CODE128" | "EAN13" | "UPC";
  value: string;
  displayValue: string;
}

// QRコード履歴
export interface QRCodeHistory {
  id: string;
  type: QRCodeType;
  data: string;
  createdAt: Date;
  usedAt?: Date;
  status: "active" | "used" | "expired";
}
</file>

<file path="src/features/qrcode/README.md">
# QRコード機能

QRコードの生成、表示、スキャン機能を提供するfeatureモジュールです。

## 機能概要

- QRコード生成（支払い、送金、招待など）
- バーコード表示
- セキュリティコードの自動生成
- 有効期限管理とタイマー表示
- QRコードスキャン（実装予定）

## ディレクトリ構成

```
features/qrcode/
├── types/              # 型定義
├── components/         # UIコンポーネント
│   ├── QRCodeGenerator/    # QRコード生成コンポーネント
│   ├── QRCodeDisplay/      # QRコード表示コンポーネント
│   ├── BarCodeDisplay/     # バーコード表示コンポーネント
│   ├── QRCodeScanner/      # QRコードスキャナー
│   └── QRCodePage/         # QRコード決済ページ
├── hooks/              # カスタムフック
├── utils/              # ユーティリティ関数
└── data/               # モックデータ（必要に応じて）
```

## 主要コンポーネント

### QRCodeGenerator

- QRコードの生成と表示を行うメインコンポーネント
- セキュリティコード、タイマー、更新機能を含む
- 支払い、送金、招待など複数のタイプに対応

### QRCodeDisplay

- QRコードの表示のみを行うプレゼンテーショナルコンポーネント
- サイズ、色、レベルなどをカスタマイズ可能

### BarCodeDisplay

- バーコードの表示を行うコンポーネント
- 店舗での決済時に使用

### QRCodePage

- QRコード決済画面全体を構成するページコンポーネント
- ヘッダー、QRコード、バーコード、アクションボタンを含む

## 使用例

### 基本的なQRコード生成

```tsx
import { QRCodeGenerator } from "@/features/qrcode";

function PaymentPage() {
  return (
    <QRCodeGenerator
      type="payment"
      showHeader={true}
      showSecurityCode={true}
      showTimer={true}
    />
  );
}
```

### カスタムQRコード表示

```tsx
import { QRCodeDisplay } from "@/features/qrcode";

function CustomQRCode() {
  return (
    <QRCodeDisplay
      value="https://example.com"
      size={250}
      fgColor="#007bff"
      level="M"
    />
  );
}
```

### QRコード生成フックの使用

```tsx
import { useQRCodeGenerator } from "@/features/qrcode";

function CustomComponent() {
  const { qrContent, timeLeft, formattedTimeLeft, isExpired, generateNewCode } =
    useQRCodeGenerator({
      type: "payment",
      autoRefresh: true,
    });

  return (
    <div>
      {qrContent && <QRCodeDisplay value={qrContent.data} />}
      <p>残り時間: {formattedTimeLeft}</p>
      <button onClick={generateNewCode}>更新</button>
    </div>
  );
}
```

## 型定義

### QRCodeType

```typescript
type QRCodeType = "payment" | "transfer" | "invitation" | "general";
```

### QRCodeContent

```typescript
interface QRCodeContent {
  type: QRCodeType;
  data: string;
  securityCode?: string;
  expiresAt?: Date;
}
```

### QRCodeGeneratorOptions

```typescript
interface QRCodeGeneratorOptions {
  size?: number;
  level?: "L" | "M" | "Q" | "H";
  fgColor?: string;
  bgColor?: string;
  includeMargin?: boolean;
}
```

## ユーティリティ関数

- `generateSecurityCode()`: ランダムなセキュリティコードを生成
- `generateQRCodeUrl()`: QRコードのURLを生成
- `formatTimeLeft()`: 残り時間をフォーマット
- `isQRCodeValid()`: QRコードの有効期限をチェック
- `parseQRCodeData()`: QRコードのデータをパース
- `generateBarcodeNumber()`: バーコード番号を生成

## 今後の実装予定

- QRコードスキャナー機能
- スキャン履歴の保存
- オフライン対応
- カメラ権限の管理
- スキャンエラーハンドリングの強化
</file>

<file path="src/features/settings/components/PageHeader/PageHeader.tsx">
"use client";

import Link from "next/link";
import { LogoutButton } from "@/features/auth";

/**
 * 設定ページのヘッダーコンポーネント
 */
export function PageHeader() {
  return (
    <div className="flex items-center justify-between">
      <div className="flex items-center space-x-3">
        <Link href="/">
          <svg viewBox="0 0 100 40" className="h-8 w-auto fill-teal-700">
            <path d="M50,0 L75,20 L65,40 H35 L25,20 L50,0z" />
            <path d="M45,15 L55,15 L55,25 L45,25 L45,15z" fill="white" />
          </svg>
        </Link>
        <h1 className="text-xl font-bold tracking-tight text-stone-900">
          Eco Wallet
        </h1>
      </div>
      <LogoutButton />
    </div>
  );
}
</file>

<file path="src/features/settings/index.ts">
// 設定機能の公開API

// 型定義のエクスポート
export * from "./types/settings";

// コンポーネントのエクスポート
export { PageHeader } from "./components/PageHeader";
export { SettingSection } from "./components/SettingSection";
export type { SettingSectionProps } from "./components/SettingSection";
export { ProfileCard } from "./components/ProfileCard";
export type { ProfileCardProps } from "./components/ProfileCard";

// タブコンポーネントのエクスポート
export {
  EcoTab,
  ProfileTab,
  NotificationsTab,
  PaymentTab,
  SecurityTab,
} from "./components/tabs";

// ユーティリティ関数のエクスポート（将来追加予定）
// export { validateEmail, formatPhoneNumber } from "./utils/validation";

// ストアのエクスポート（将来追加予定）
// export { useSettingsStore } from "./store/settings.slice";
// export type { SettingsSlice } from "./store/settings.slice";
</file>

<file path="src/features/transactions/components/TransactionDetail/ReceiptDialog.tsx">
"use client";

import React from "react";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Download, Share2, Leaf } from "lucide-react";
import { ReceiptItem } from "@/features/transactions/types/receipt";

// Define EcoContribution locally until it's available in the exported types
interface EcoContribution {
  enabled: boolean;
  amount: number;
}

interface ReceiptSavings {
  paperSaved: string;
  co2Reduction: string;
}

interface ReceiptDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  transactionId: string;
  date: string;
  items: ReceiptItem[];
  total: number;
  ecoContribution?: EcoContribution;
  receiptSavings: ReceiptSavings;
  onDownload: () => void;
  onShare: () => void;
}

export const ReceiptDialog = React.memo(
  ({
    open,
    onOpenChange,
    transactionId,
    date,
    items,
    total,
    ecoContribution,
    receiptSavings,
    onDownload,
    onShare,
  }: ReceiptDialogProps) => {
    return (
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent className="sm:max-w-md p-0 bg-white overflow-hidden">
          <div className="p-4 bg-white">
            <div className="flex justify-between mb-4">
              <div>
                <DialogTitle className="text-lg font-bold text-stone-800">
                  電子レシート
                </DialogTitle>
                <p className="text-sm text-stone-600">{date}</p>
              </div>
              <div className="text-xs text-right text-stone-500">
                <div>取引 ID:</div>
                <div className="font-mono">{transactionId}</div>
              </div>
            </div>

            <div className="border-t border-b border-stone-200 py-3 my-3">
              {items.map((item, index) => (
                <div key={index} className="flex justify-between mb-2">
                  <div className="flex-1">
                    <div className="flex items-center">
                      {item.isEco && (
                        <Leaf className="h-3 w-3 text-emerald-600 mr-1" />
                      )}
                      <span className="text-sm">{item.name}</span>
                    </div>
                    {item.quantity > 1 && (
                      <div className="text-xs text-stone-500">
                        {item.quantity} × ¥
                        {(item.price / item.quantity).toLocaleString()}
                      </div>
                    )}
                  </div>
                  <div className="text-sm font-medium">
                    ¥{item.price.toLocaleString()}
                  </div>
                </div>
              ))}
            </div>

            <div className="flex justify-between mb-1">
              <div className="text-sm text-stone-600">小計</div>
              <div className="text-sm font-medium">
                ¥{total.toLocaleString()}
              </div>
            </div>

            {ecoContribution?.enabled && (
              <div className="flex justify-between text-xs bg-emerald-50 p-2 rounded-md mb-3">
                <div className="text-emerald-700 flex items-center">
                  <Leaf className="h-3 w-3 mr-1" />
                  環境貢献
                </div>
                <div className="text-emerald-700 font-medium">
                  ¥{ecoContribution.amount.toLocaleString()}
                </div>
              </div>
            )}

            <div className="flex justify-between mb-4">
              <div className="text-base font-medium text-stone-800">合計</div>
              <div className="text-base font-bold">
                ¥{total.toLocaleString()}
              </div>
            </div>

            <div className="text-xs text-stone-500 bg-stone-50 p-3 rounded-md mb-4">
              <div className="flex justify-between mb-1">
                <div>紙の節約:</div>
                <div>{receiptSavings.paperSaved}</div>
              </div>
              <div className="flex justify-between">
                <div>CO₂削減:</div>
                <div>{receiptSavings.co2Reduction}</div>
              </div>
            </div>

            <div className="flex space-x-2">
              <Button
                variant="outline"
                size="sm"
                className="flex-1 border-stone-200 hover:bg-stone-50"
                onClick={onDownload}
              >
                <Download className="h-4 w-4 mr-1" />
                保存
              </Button>
              <Button
                variant="outline"
                size="sm"
                className="flex-1 border-stone-200 hover:bg-stone-50"
                onClick={onShare}
              >
                <Share2 className="h-4 w-4 mr-1" />
                共有
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    );
  },
);

ReceiptDialog.displayName = "ReceiptDialog";
</file>

<file path="src/features/transactions/components/TransactionDetail/TransactionInfo.tsx">
"use client";

import React from "react";
import { TransactionType } from "@/shared/types/transaction";

// Define EcoContribution locally until it's available in the exported types
interface EcoContribution {
  enabled: boolean;
  amount: number;
}

interface TransactionInfoProps {
  transactionId: string;
  type: TransactionType;
  date: string;
  badges?: string[];
  ecoContribution?: EcoContribution;
  formattedAmount: string;
  textColor: string;
}

export const TransactionInfo = React.memo(
  ({
    transactionId,
    type,
    date,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    badges = [],
    ecoContribution,
    formattedAmount,
    textColor,
  }: TransactionInfoProps) => {
    return (
      <div className="mb-4">
        <div className="flex justify-between items-center mb-2">
          <div>
            <p className="text-sm text-stone-600">取引番号</p>
            <p className="text-sm font-mono">{transactionId}</p>
          </div>
          <div>
            <p className={`text-2xl font-bold ${textColor} text-right`}>
              {formattedAmount}円
            </p>
            {ecoContribution?.enabled && (
              <p className="text-xs text-right text-emerald-600">
                うち環境貢献 {ecoContribution.amount}円
              </p>
            )}
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4 text-sm mt-4">
          <div>
            <p className="text-stone-600">取引種別</p>
            <p className="font-medium">
              {{
                payment: "支払い",
                charge: "チャージ",
                transfer: "送金",
                donation: "寄付",
                receive: "受取",
                expired: "期限切れ",
              }[type] || "その他"}
            </p>
          </div>
          <div>
            <p className="text-stone-600">日時</p>
            <p className="font-medium">{date}</p>
          </div>

          {type === "payment" && (
            <>
              <div>
                <p className="text-stone-600">支払方法</p>
                <p className="font-medium">エコウォレット</p>
              </div>
              <div>
                <p className="text-stone-600">ステータス</p>
                <p className="text-emerald-600 font-medium">完了</p>
              </div>
            </>
          )}
        </div>
      </div>
    );
  },
);

TransactionInfo.displayName = "TransactionInfo";
</file>

<file path="src/features/transactions/components/TransactionFilters/TransactionFilters.tsx">
import React from "react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { CalendarIcon, Filter } from "lucide-react";
import { format } from "date-fns";
import { ja } from "date-fns/locale";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";

interface TransactionFiltersProps {
  selectedTab: "all" | "in" | "out" | "campaign" | "eco";
  onTabChange: (value: "all" | "in" | "out" | "campaign" | "eco") => void;
  startDate: Date;
  setStartDate: (date: Date) => void;
  endDate: Date;
  setEndDate: (date: Date) => void;
}

export function TransactionFilters({
  selectedTab,
  onTabChange,
  startDate,
  setStartDate,
  endDate,
  setEndDate,
}: TransactionFiltersProps) {
  return (
    <div className="space-y-4">
      {/* タブフィルター - よりシンプルで洗練されたデザイン */}
      <Tabs
        value={selectedTab}
        onValueChange={(value) => onTabChange(value as typeof selectedTab)}
      >
        <TabsList className="grid w-full grid-cols-5 bg-stone-100 p-1 h-10">
          <TabsTrigger
            value="all"
            className="data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm text-xs font-medium"
          >
            すべて
          </TabsTrigger>
          <TabsTrigger
            value="in"
            className="data-[state=active]:bg-white data-[state=active]:text-blue-600 data-[state=active]:shadow-sm text-xs font-medium"
          >
            入金
          </TabsTrigger>
          <TabsTrigger
            value="out"
            className="data-[state=active]:bg-white data-[state=active]:text-stone-700 data-[state=active]:shadow-sm text-xs font-medium"
          >
            支払い
          </TabsTrigger>
          <TabsTrigger
            value="campaign"
            className="data-[state=active]:bg-white data-[state=active]:text-amber-600 data-[state=active]:shadow-sm text-xs font-medium"
          >
            特典
          </TabsTrigger>
          <TabsTrigger
            value="eco"
            className="data-[state=active]:bg-white data-[state=active]:text-green-600 data-[state=active]:shadow-sm text-xs font-medium"
          >
            環境
          </TabsTrigger>
        </TabsList>
      </Tabs>

      {/* 日付フィルター - より洗練されたデザイン */}
      <div className="flex items-center gap-2 bg-stone-50 p-3 rounded-lg">
        <Filter className="h-4 w-4 text-stone-500" />
        <span className="text-xs text-stone-600">期間:</span>

        <Popover>
          <PopoverTrigger asChild>
            <Button
              variant="ghost"
              className="h-8 px-3 text-xs font-normal text-stone-700 hover:bg-white hover:text-teal-700 justify-start"
            >
              <CalendarIcon className="mr-1.5 h-3.5 w-3.5" />
              {format(startDate, "MM/dd", { locale: ja })}
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <Calendar
              mode="single"
              selected={startDate}
              onSelect={(date) => date && setStartDate(date)}
              initialFocus
              locale={ja}
            />
          </PopoverContent>
        </Popover>

        <span className="text-xs text-stone-500">〜</span>

        <Popover>
          <PopoverTrigger asChild>
            <Button
              variant="ghost"
              className="h-8 px-3 text-xs font-normal text-stone-700 hover:bg-white hover:text-teal-700 justify-start"
            >
              <CalendarIcon className="mr-1.5 h-3.5 w-3.5" />
              {format(endDate, "MM/dd", { locale: ja })}
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <Calendar
              mode="single"
              selected={endDate}
              onSelect={(date) => date && setEndDate(date)}
              initialFocus
              locale={ja}
            />
          </PopoverContent>
        </Popover>
      </div>
    </div>
  );
}
</file>

<file path="src/features/transactions/components/TransactionList/TransactionList.tsx">
"use client";

import React, { useState, useMemo } from "react";
import { Transaction } from "@/shared/types/transaction";
import {
  TransactionItem,
  StyledTransaction,
} from "@/features/transactions/components/TransactionItem";
import { getTransactionStyle } from "@/features/transactions/hooks/transactionStyling";
import { formatCurrency } from "@/shared/utils/formats";
import { Button } from "@/components/ui/button";
import { ChevronDown } from "lucide-react";

interface TransactionListProps {
  transactions: Transaction[];
  initialLimit?: number;
}

export function TransactionList({
  transactions,
  initialLimit = 10,
}: TransactionListProps) {
  const [displayLimit, setDisplayLimit] = useState(initialLimit);

  const handleShowMore = () => {
    setDisplayLimit((prev) => prev + 10);
  };

  const displayedTransactions = transactions.slice(0, displayLimit);
  const hasMore = transactions.length > displayLimit;

  // トランザクションをスタイル付きトランザクションに変換
  const styledTransactions: StyledTransaction[] = useMemo(() => {
    return displayedTransactions.map((transaction) => {
      // トランザクションタイプとバッジに基づいてスタイルを計算
      const style = getTransactionStyle(
        transaction.type,
        transaction.badges || [],
      );
      const formattedAmount = formatCurrency(transaction.amount);

      return {
        transaction,
        style,
        formattedAmount,
      };
    });
  }, [displayedTransactions]);

  if (transactions.length === 0) {
    return (
      <div className="bg-stone-50 rounded-lg p-8 text-center">
        <svg
          className="w-12 h-12 mx-auto text-stone-400 mb-3"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={1.5}
            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
          />
        </svg>
        <p className="text-sm text-stone-600 font-medium">
          取引履歴はまだありません
        </p>
        <p className="text-xs text-stone-500 mt-1">
          取引を開始すると、ここに表示されます
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {/* 取引リスト */}
      <div className="space-y-2">
        {styledTransactions.map((item) => (
          <TransactionItem key={item.transaction.id} item={item} />
        ))}
      </div>

      {/* もっと見るボタン */}
      {hasMore && (
        <div className="pt-4">
          <Button
            variant="ghost"
            onClick={handleShowMore}
            className="w-full h-10 text-sm font-medium text-stone-600 hover:text-teal-700 hover:bg-stone-50 group"
          >
            さらに表示
            <span className="ml-1 text-xs text-stone-500">
              ({transactions.length - displayLimit}件)
            </span>
            <ChevronDown className="ml-2 h-4 w-4 transition-transform group-hover:translate-y-0.5" />
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/features/transactions/data/transactions-data.ts">
import { Transaction } from "@/shared/types/transaction";

export const transactionsData: Transaction[] = [
  // 最新の取引
  {
    id: "txn_eco_cafe_01",
    type: "payment",
    description: "エコカフェ 渋谷店",
    date: "2025/01/25",
    amount: -580,
    ecoContribution: {
      enabled: true,
      amount: 30,
      project: "森林保全プロジェクト",
    },
    badges: ["環境貢献"],
  },
  {
    id: "txn_charge_bank_01",
    type: "charge",
    description: "銀行口座からチャージ",
    date: "2025/01/24",
    amount: 20000,
  },
  {
    id: "txn_outdoor_gear_01",
    type: "payment",
    description: "パタゴニア リサイクルフリース",
    date: "2025/01/23",
    amount: -15800,
    ecoContribution: {
      enabled: true,
      amount: 790,
      project: "海洋プラスチック削減",
    },
    badges: ["環境貢献", "5%還元"],
  },
  {
    id: "txn_campaign_winter_01",
    type: "receive",
    description: "冬のエコキャンペーン特典",
    date: "2025/01/22",
    amount: 2000,
    badges: ["特典"],
    campaignInfo: {
      name: "冬のエコ活動応援キャンペーン",
      expiryDate: "2025/02/28",
    },
  },
  {
    id: "split_ski_trip_01",
    type: "payment",
    description: "スキー旅行費用（幹事立替）",
    date: "2025/01/20",
    amount: -45000,
    ecoContribution: {
      enabled: true,
      amount: 450,
    },
    badges: ["割り勘", "進行中"],
    splitInfo: {
      participants: 5,
      collected: 2,
      remaining: 3,
    },
  },
  {
    id: "txn_organic_market_01",
    type: "payment",
    description: "オーガニックマーケット 青山",
    date: "2025/01/18",
    amount: -3280,
    ecoContribution: {
      enabled: true,
      amount: 164,
      project: "地産地消推進プロジェクト",
    },
    badges: ["環境貢献"],
  },
  {
    id: "txn_eco_transport_01",
    type: "payment",
    description: "エコシェアサイクル 月額プラン",
    date: "2025/01/15",
    amount: -2980,
    ecoContribution: {
      enabled: true,
      amount: 149,
      project: "都市交通のCO2削減",
    },
    badges: ["定期支払い", "環境貢献"],
  },
  {
    id: "txn_friend_bonus_01",
    type: "receive",
    description: "友達紹介ボーナス（田中さん）",
    date: "2025/01/12",
    amount: 1500,
    badges: ["特典"],
    campaignInfo: {
      name: "友達紹介プログラム",
      expiryDate: "2025/04/30",
    },
  },
  {
    id: "txn_eco_hotel_01",
    type: "payment",
    description: "エコホテル東京 宿泊費",
    date: "2025/01/10",
    amount: -12000,
    ecoContribution: {
      enabled: true,
      amount: 600,
      project: "持続可能な観光推進",
    },
    badges: ["環境貢献"],
  },
  {
    id: "txn_expired_points_01",
    type: "expired",
    description: "年末キャンペーンポイント",
    date: "2025/01/05",
    amount: -800,
    badges: ["期限切れ"],
    campaignInfo: {
      name: "年末年始エコ活動キャンペーン",
      expiredDate: "2025/01/05",
    },
  },
  // 12月の取引
  {
    id: "txn_charge_atm_02",
    type: "charge",
    description: "コンビニATMからチャージ",
    date: "2024/12/28",
    amount: 10000,
  },
  {
    id: "txn_eco_grocery_01",
    type: "payment",
    description: "無印良品 エコバッグ・食品",
    date: "2024/12/25",
    amount: -2450,
    ecoContribution: {
      enabled: true,
      amount: 123,
      project: "プラスチック削減プロジェクト",
    },
    badges: ["環境貢献"],
  },
  {
    id: "split_year_end_party",
    type: "payment",
    description: "忘年会費用（幹事立替）",
    date: "2024/12/22",
    amount: -36000,
    ecoContribution: {
      enabled: true,
      amount: 360,
    },
    badges: ["割り勘", "完了"],
    splitInfo: {
      participants: 12,
      collected: 12,
      remaining: 0,
    },
  },
  {
    id: "txn_sustainable_fashion_01",
    type: "payment",
    description: "ステラマッカートニー エコレザーバッグ",
    date: "2024/12/20",
    amount: -48000,
    ecoContribution: {
      enabled: true,
      amount: 2400,
      project: "サステナブルファッション推進",
    },
    badges: ["環境貢献", "10%還元"],
  },
  {
    id: "txn_year_end_bonus",
    type: "receive",
    description: "年末特別ボーナス",
    date: "2024/12/15",
    amount: 5000,
    badges: ["特典"],
    campaignInfo: {
      name: "年末感謝キャンペーン",
      expiryDate: "2025/01/31",
    },
  },
  {
    id: "txn_eco_subscription_01",
    type: "payment",
    description: "エコ洗剤定期便",
    date: "2024/12/10",
    amount: -2800,
    ecoContribution: {
      enabled: true,
      amount: 140,
      project: "水資源保全プロジェクト",
    },
    badges: ["定期支払い", "環境貢献"],
  },
  {
    id: "txn_green_energy_01",
    type: "payment",
    description: "グリーン電力証書購入",
    date: "2024/12/05",
    amount: -5000,
    ecoContribution: {
      enabled: true,
      amount: 500,
      project: "再生可能エネルギー推進",
    },
    badges: ["環境貢献", "CO2オフセット"],
  },
  {
    id: "txn_eco_restaurant_01",
    type: "payment",
    description: "ベジタリアンレストラン GREEN",
    date: "2024/12/03",
    amount: -3200,
    ecoContribution: {
      enabled: true,
      amount: 160,
      project: "フードロス削減",
    },
    badges: ["環境貢献"],
  },
  // 11月の取引
  {
    id: "txn_charge_credit_01",
    type: "charge",
    description: "クレジットカードからチャージ",
    date: "2024/11/30",
    amount: 30000,
  },
  {
    id: "txn_eco_event_01",
    type: "payment",
    description: "エコフェスタ2024 参加費",
    date: "2024/11/25",
    amount: -2000,
    ecoContribution: {
      enabled: true,
      amount: 200,
      project: "環境教育プログラム",
    },
    badges: ["環境貢献", "イベント"],
  },
  {
    id: "txn_autumn_campaign",
    type: "receive",
    description: "秋のエコ活動キャンペーン",
    date: "2024/11/20",
    amount: 3000,
    badges: ["特典"],
    campaignInfo: {
      name: "秋の森林保全キャンペーン",
      expiryDate: "2024/12/31",
    },
  },
  {
    id: "txn_reusable_products",
    type: "payment",
    description: "エコストア リユース製品セット",
    date: "2024/11/15",
    amount: -6800,
    ecoContribution: {
      enabled: true,
      amount: 340,
      project: "循環型社会推進",
    },
    badges: ["環境貢献"],
  },
  {
    id: "split_camping_gear",
    type: "payment",
    description: "キャンプ用品レンタル（グループ）",
    date: "2024/11/10",
    amount: -18000,
    ecoContribution: {
      enabled: true,
      amount: 180,
    },
    badges: ["割り勘", "完了"],
    splitInfo: {
      participants: 6,
      collected: 6,
      remaining: 0,
    },
  },
  {
    id: "txn_eco_cosmetics",
    type: "payment",
    description: "オーガニックコスメ LUSH",
    date: "2024/11/05",
    amount: -4200,
    ecoContribution: {
      enabled: true,
      amount: 210,
      project: "動物実験廃止推進",
    },
    badges: ["環境貢献"],
  },
  {
    id: "txn_tree_planting",
    type: "payment",
    description: "植樹活動支援寄付",
    date: "2024/11/01",
    amount: -10000,
    ecoContribution: {
      enabled: true,
      amount: 10000,
      project: "100本の木プロジェクト",
    },
    badges: ["環境貢献", "寄付"],
  },
];
</file>

<file path="src/features/transactions/hooks/index.ts">
export * from "./transactionStyling";
export * from "./useTransactionFilters";
</file>

<file path="src/features/transactions/hooks/useTransactionFilters.ts">
"use client";

/**
 * トランザクションフィルタリング用カスタムフック
 */
import { useState, useMemo, useCallback } from "react";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { TransactionType, Transaction } from "@/shared/types/transaction";

interface DateRange {
  startDate: string;
  endDate: string;
}

/**
 * トランザクションフィルタリングのためのカスタムフック
 */
export function useTransactionFilters() {
  // フィルター状態
  const [typeFilter, setTypeFilter] = useState<TransactionType | "all">("all");
  const [dateRange, setDateRange] = useState<DateRange | null>(null);
  const [showEcoOnly, setShowEcoOnly] = useState<boolean>(false);

  // トランザクションストアからデータ取得
  const transactions = useTransactionStore((state) => state.transactions);
  const getTransactionsByType = useTransactionStore(
    (state) => state.getTransactionsByType,
  );
  const getTransactionsWithEcoContribution = useTransactionStore(
    (state) => state.getTransactionsWithEcoContribution,
  );
  const getTransactionsByDateRange = useTransactionStore(
    (state) => state.getTransactionsByDateRange,
  );

  // フィルター設定ハンドラー
  const handleTypeFilterChange = useCallback(
    (type: TransactionType | "all") => {
      setTypeFilter(type);
    },
    [],
  );

  const handleDateRangeChange = useCallback((range: DateRange | null) => {
    setDateRange(range);
  }, []);

  const handleEcoFilterChange = useCallback((showEco: boolean) => {
    setShowEcoOnly(showEco);
  }, []);

  // フィルター適用済みトランザクションを計算
  const filteredTransactions = useMemo<Transaction[]>(() => {
    // ベーストランザクション（タイプフィルター適用）
    const typeResult =
      typeFilter === "all"
        ? [...transactions]
        : getTransactionsByType(typeFilter);
    let result = Array.isArray(typeResult)
      ? typeResult
      : typeResult.isOk()
        ? typeResult.value
        : [];

    // 日付範囲フィルター適用
    if (dateRange) {
      const dateRangeResult = getTransactionsByDateRange(
        dateRange.startDate,
        dateRange.endDate,
      );
      const dateTransactions = dateRangeResult.isOk()
        ? dateRangeResult.value
        : [];
      result = result.filter((tx) =>
        dateTransactions.some((dateTx) => dateTx.id === tx.id),
      );
    }

    // エコ貢献フィルター適用
    if (showEcoOnly) {
      const ecoTransactionsResult = getTransactionsWithEcoContribution();
      const ecoTransactions = ecoTransactionsResult.isOk()
        ? ecoTransactionsResult.value
        : [];
      result = result.filter((tx) =>
        ecoTransactions.some((ecoTx) => ecoTx.id === tx.id),
      );
    }

    return result;
  }, [
    transactions,
    typeFilter,
    dateRange,
    showEcoOnly,
    getTransactionsByType,
    getTransactionsByDateRange,
    getTransactionsWithEcoContribution,
  ]);

  return {
    // 状態
    typeFilter,
    dateRange,
    showEcoOnly,
    // 結果
    filteredTransactions,
    // アクション
    setTypeFilter: handleTypeFilterChange,
    setDateRange: handleDateRangeChange,
    setShowEcoOnly: handleEcoFilterChange,
  };
}
</file>

<file path="src/features/transfer/components/RecipientSelector/index.ts">
export { RecipientSelector } from "./RecipientSelector";
export { RecipientSelectorModal } from "./RecipientSelectorModal";
</file>

<file path="src/features/transfer/components/SplitForm/SplitForm.tsx">
"use client";

import React from "react";
import { Plus, Users, Divide, Leaf } from "lucide-react";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ErrorDisplay } from "@/components/ui/error-display";
import { useSplitForm } from "../../hooks/useSplitForm";
import { SuccessMessage } from "../SuccessMessage";
import { formatCurrency } from "@/shared/utils/formats";
import { cn } from "@/lib/utils";

// 参加者アイテムコンポーネント
const ParticipantItem: React.FC<{
  participant: {
    id: string;
    name: string;
    isPayor?: boolean;
    isEcoUser?: boolean;
    amount: string;
    email: string;
  };
  onAmountChange: (id: string, amount: string) => void;
  onEmailChange: (id: string, email: string) => void;
  onRemove: (id: string) => void;
  canRemove: boolean;
}> = ({ participant, onAmountChange, onEmailChange, onRemove, canRemove }) => {
  return (
    <div className="flex items-center gap-3 py-3">
      <div className="flex-1">
        <div className="flex items-center gap-2">
          <span className="font-medium text-stone-700">{participant.name}</span>
          {participant.isPayor && (
            <Badge variant="secondary" className="text-xs">
              立替者
            </Badge>
          )}
          {participant.isEcoUser && (
            <Badge className="bg-teal-100 text-teal-700 text-xs">
              <Leaf className="h-3 w-3 mr-1" />
              Eco
            </Badge>
          )}
        </div>
        {!participant.isEcoUser && !participant.isPayor && (
          <Input
            type="email"
            placeholder="メールアドレス"
            value={participant.email}
            onChange={(e) => onEmailChange(participant.id, e.target.value)}
            className="mt-2 text-sm"
          />
        )}
      </div>
      <div className="w-32">
        <Input
          type="number"
          placeholder="金額"
          value={participant.amount}
          onChange={(e) => onAmountChange(participant.id, e.target.value)}
          className="text-right"
        />
      </div>
      {canRemove && (
        <Button
          variant="ghost"
          size="sm"
          onClick={() => onRemove(participant.id)}
          className="text-stone-500 hover:text-stone-700"
        >
          ×
        </Button>
      )}
    </div>
  );
};

export const SplitForm: React.FC = () => {
  const {
    formData,
    updateField,
    updateParticipantAmount,
    updateParticipantEmail,
    distributeEvenly,
    addParticipant,
    removeParticipant,
    handleSplitRequest,
    isProcessing,
    error,
    clearError,
    isSuccess,
    totalAmount,
    donationAmount,
  } = useSplitForm();

  // 新しい参加者を追加するためのローカル状態
  const [newParticipantName, setNewParticipantName] = React.useState("");
  const [showAddForm, setShowAddForm] = React.useState(false);

  const handleAddParticipant = () => {
    if (newParticipantName.trim()) {
      addParticipant(newParticipantName.trim());
      setNewParticipantName("");
      setShowAddForm(false);
    }
  };

  // 合計金額が参加者の金額の合計と一致しているかチェック
  const participantTotal = formData.participants.reduce(
    (sum, p) => sum + (Number(p.amount) || 0),
    0,
  );
  const isAmountMatched = totalAmount > 0 && participantTotal === totalAmount;

  if (isSuccess) {
    return (
      <SuccessMessage
        title="割り勘リクエストを送信しました"
        message={`${formData.participants.length}人に割り勘リクエストを送信しました`}
      />
    );
  }

  return (
    <div className="space-y-6">
      {/* タイトル入力 */}
      <div>
        <Label htmlFor="splitTitle">割り勘タイトル</Label>
        <Input
          id="splitTitle"
          placeholder="例：キャンプ用品費用"
          value={formData.splitTitle}
          onChange={(e) => updateField("splitTitle", e.target.value)}
          className="mt-2"
        />
      </div>

      {/* 合計金額入力 */}
      <div>
        <Label htmlFor="totalAmount">合計金額</Label>
        <Input
          id="totalAmount"
          type="number"
          placeholder="¥0"
          value={formData.totalAmount}
          onChange={(e) => updateField("totalAmount", e.target.value)}
          className="mt-2"
        />
      </div>

      {/* 参加者リスト */}
      <Card className="p-4">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <Users className="h-5 w-5 text-stone-600" />
            <h3 className="font-medium">参加者</h3>
            <Badge variant="secondary">{formData.participants.length}人</Badge>
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={distributeEvenly}
            disabled={!totalAmount || totalAmount <= 0}
            className="gap-2"
          >
            <Divide className="h-4 w-4" />
            均等に分ける
          </Button>
        </div>

        <div className="space-y-2">
          {formData.participants.map((participant) => (
            <div key={participant.id}>
              <ParticipantItem
                participant={participant}
                onAmountChange={updateParticipantAmount}
                onEmailChange={updateParticipantEmail}
                onRemove={removeParticipant}
                canRemove={
                  !participant.isPayor && formData.participants.length > 2
                }
              />
              <Separator className="last:hidden" />
            </div>
          ))}
        </div>

        {/* 参加者追加フォーム */}
        {showAddForm ? (
          <div className="mt-4 flex gap-2">
            <Input
              placeholder="参加者の名前"
              value={newParticipantName}
              onChange={(e) => setNewParticipantName(e.target.value)}
              onKeyPress={(e) => e.key === "Enter" && handleAddParticipant()}
            />
            <Button onClick={handleAddParticipant} size="sm">
              追加
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                setShowAddForm(false);
                setNewParticipantName("");
              }}
            >
              キャンセル
            </Button>
          </div>
        ) : (
          <Button
            variant="ghost"
            className="mt-4 w-full"
            onClick={() => setShowAddForm(true)}
          >
            <Plus className="h-4 w-4 mr-2" />
            参加者を追加
          </Button>
        )}
      </Card>

      {/* 金額の確認 */}
      {totalAmount > 0 && (
        <Alert
          className={cn(
            "border-l-4",
            isAmountMatched ? "border-teal-600" : "border-amber-600",
          )}
        >
          <AlertDescription>
            <div className="space-y-1">
              <div className="flex justify-between">
                <span>合計金額:</span>
                <span className="font-medium">
                  {formatCurrency(totalAmount)}
                </span>
              </div>
              <div className="flex justify-between">
                <span>参加者合計:</span>
                <span
                  className={cn(
                    "font-medium",
                    isAmountMatched ? "text-teal-600" : "text-amber-600",
                  )}
                >
                  {formatCurrency(participantTotal)}
                </span>
              </div>
              {!isAmountMatched && (
                <div className="text-sm text-amber-600 mt-2">
                  ※ 合計金額と参加者の金額が一致していません
                </div>
              )}
            </div>
          </AlertDescription>
        </Alert>
      )}

      {/* 送金方法の選択 */}
      <div>
        <Label>送金方法</Label>
        <RadioGroup
          value={formData.splitMethod}
          onValueChange={(value) =>
            updateField("splitMethod", value as "wallet" | "bank" | "qr")
          }
          className="mt-3 space-y-3"
        >
          <div className="flex items-center space-x-3">
            <RadioGroupItem value="wallet" id="wallet" />
            <Label htmlFor="wallet" className="cursor-pointer">
              Eco Wallet残高から送金
            </Label>
          </div>
          <div className="flex items-center space-x-3">
            <RadioGroupItem value="bank" id="bank" />
            <Label htmlFor="bank" className="cursor-pointer">
              銀行振込で送金
            </Label>
          </div>
          <div className="flex items-center space-x-3">
            <RadioGroupItem value="qr" id="qr" />
            <Label htmlFor="qr" className="cursor-pointer">
              QRコードで送金
            </Label>
          </div>
        </RadioGroup>
      </div>

      {/* 環境保全への寄付 */}
      <Card className="p-4 bg-teal-50 border-teal-200">
        <div className="flex items-start gap-3">
          <Leaf className="h-5 w-5 text-teal-600 mt-0.5" />
          <div className="flex-1">
            <h4 className="font-medium text-teal-900">環境保全への寄付</h4>
            <p className="text-sm text-teal-700 mt-1">
              立替金額の0.1%（{formatCurrency(donationAmount)}
              ）が環境保全団体に寄付されます
            </p>
          </div>
        </div>
      </Card>

      {/* エラーメッセージ */}
      {error && <ErrorDisplay error={error} onRetry={clearError} />}

      {/* 送信ボタン */}
      <Button
        onClick={handleSplitRequest}
        disabled={isProcessing || !isAmountMatched}
        className="w-full bg-teal-600 hover:bg-teal-700"
      >
        {isProcessing ? "処理中..." : "割り勘リクエストを送信"}
      </Button>
    </div>
  );
};
</file>

<file path="src/features/transfer/components/SuccessMessage/SuccessMessage.tsx">
import React from "react";
import { CheckCircle } from "lucide-react";
import { formatCurrency } from "@/shared/utils/formats";

interface SuccessMessageProps {
  title?: string;
  message?: string;
  recipientName?: string;
  transferAmount?: number;
  donationAmount?: number;
  totalDeduction?: number;
}

export const SuccessMessage: React.FC<SuccessMessageProps> = ({
  title,
  message,
  recipientName,
  transferAmount,
  donationAmount,
  totalDeduction,
}) => {
  // 送金完了メッセージの場合
  if (recipientName && transferAmount !== undefined) {
    return (
      <div className="bg-teal-50 p-6 rounded-lg border border-teal-100 max-w-md mx-auto">
        <div className="flex items-center mb-4">
          <div className="mr-3 bg-teal-100 rounded-full p-2">
            <CheckCircle className="h-8 w-8 text-teal-600" />
          </div>
          <div>
            <h3 className="text-lg font-medium text-teal-800">
              送金が完了しました
            </h3>
            <p className="text-sm text-teal-700">
              {recipientName}への送金が正常に処理されました
            </p>
          </div>
        </div>

        <div className="space-y-2 bg-white p-4 rounded-lg">
          <div className="flex justify-between text-sm">
            <span className="text-stone-600">送金額</span>
            <span className="font-medium">
              {formatCurrency(transferAmount)}
            </span>
          </div>
          {donationAmount !== undefined && donationAmount > 0 && (
            <div className="flex justify-between text-sm">
              <span className="text-stone-600">環境保全寄付</span>
              <span className="text-teal-600">
                {formatCurrency(donationAmount)}
              </span>
            </div>
          )}
          {totalDeduction !== undefined && (
            <div className="flex justify-between text-sm pt-2 border-t">
              <span className="text-stone-600">合計</span>
              <span className="font-medium">
                {formatCurrency(totalDeduction)}
              </span>
            </div>
          )}
        </div>

        <p className="text-xs text-teal-600 mt-4 text-center">
          まもなく詳細画面へ移動します...
        </p>
      </div>
    );
  }

  // 汎用メッセージの場合
  return (
    <div className="bg-teal-50 p-4 rounded-md border border-teal-100 flex items-center mb-4">
      <div className="mr-3 bg-teal-100 rounded-full p-2">
        <CheckCircle className="h-6 w-6 text-teal-600" />
      </div>
      <div>
        <h3 className="text-sm font-medium text-teal-800">{title}</h3>
        <p className="text-xs text-teal-700">{message}</p>
      </div>
    </div>
  );
};
</file>

<file path="src/features/transfer/components/TransferForm/TransferForm.tsx">
"use client";

import { useState } from "react";
import { Leaf } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { ErrorDisplay } from "@/components/ui/error-display";
import { RecipientSelectorModal } from "../RecipientSelector";
import { SuccessMessage } from "../SuccessMessage";
import { useTransferForm } from "../../hooks/useTransferForm";
import { formatCurrency } from "@/shared/utils/formats";
import { Recipient } from "../../types/transfer";

export const TransferForm = () => {
  const {
    formData,
    updateField,
    selectRecipient,
    handleTransfer,
    isProcessing,
    error,
    fieldErrors,
    isSuccess,
    transferAmount,
    donationAmount,
    totalAmount,
  } = useTransferForm();

  const [showRecipientSelector, setShowRecipientSelector] = useState(false);

  const handleRecipientSelect = (recipient: Recipient) => {
    selectRecipient(recipient);
    setShowRecipientSelector(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await handleTransfer();
  };

  // 成功メッセージを表示
  if (isSuccess) {
    return (
      <SuccessMessage
        recipientName={formData.selectedRecipient?.name || formData.recipient}
        transferAmount={transferAmount}
        donationAmount={donationAmount}
        totalDeduction={totalAmount}
      />
    );
  }

  return (
    <>
      {/* 受取人選択モーダル */}
      <RecipientSelectorModal
        isOpen={showRecipientSelector}
        onSelectRecipient={handleRecipientSelect}
        onClose={() => setShowRecipientSelector(false)}
      />

      <Card className="w-full max-w-2xl mx-auto">
        <CardHeader>
          <CardTitle>送金</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* 受取人選択 */}
            <div className="space-y-2">
              <Label htmlFor="recipient">受取人</Label>
              <div className="flex gap-2">
                <Input
                  id="recipient"
                  type="text"
                  placeholder="受取人を選択してください"
                  value={formData.recipient}
                  onChange={(e) => updateField("recipient", e.target.value)}
                  className="flex-1"
                  readOnly={!!formData.selectedRecipient}
                />
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setShowRecipientSelector(true)}
                  className="shrink-0"
                >
                  選択
                </Button>
              </div>
              {formData.selectedRecipient && (
                <p className="text-sm text-stone-600">
                  {formData.selectedRecipient.isEcoUser
                    ? "Eco Walletユーザー"
                    : "外部ユーザー"}
                </p>
              )}
              {fieldErrors.recipient && (
                <ErrorDisplay error={fieldErrors.recipient} />
              )}
            </div>

            {/* 金額入力 */}
            <div className="space-y-2">
              <Label htmlFor="amount">金額</Label>
              <div className="relative">
                <span className="absolute left-3 top-1/2 -translate-y-1/2 text-stone-600">
                  ¥
                </span>
                <Input
                  id="amount"
                  type="number"
                  placeholder="0"
                  value={formData.amount}
                  onChange={(e) => updateField("amount", e.target.value)}
                  className="pl-8"
                  min="1"
                  required
                />
              </div>
              {fieldErrors.amount && (
                <ErrorDisplay error={fieldErrors.amount} />
              )}
            </div>

            {/* メッセージ入力 */}
            <div className="space-y-2">
              <Label htmlFor="message">メッセージ（任意）</Label>
              <Textarea
                id="message"
                placeholder="メッセージを入力"
                value={formData.message}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                  updateField("message", e.target.value)
                }
                rows={3}
                className="resize-none"
              />
            </div>

            {/* 環境保全寄付 */}
            <div className="flex items-start space-x-3 p-4 bg-teal-50 rounded-lg border border-teal-200">
              <Checkbox
                id="donate"
                checked={formData.isDonateChecked}
                onCheckedChange={(checked) =>
                  updateField("isDonateChecked", checked as boolean)
                }
                className="mt-0.5"
              />
              <div className="flex-1">
                <Label
                  htmlFor="donate"
                  className="flex items-center gap-2 text-sm font-medium text-teal-800 cursor-pointer"
                >
                  <Leaf className="h-4 w-4" />
                  環境保全に寄付する
                </Label>
                <p className="text-xs text-teal-600 mt-1">
                  送金額の1%を環境保全活動に寄付します
                </p>
              </div>
            </div>

            {/* 金額内訳 */}
            {transferAmount > 0 && (
              <div className="space-y-2 p-4 bg-stone-50 rounded-lg">
                <div className="flex justify-between text-sm">
                  <span>送金額</span>
                  <span>{formatCurrency(transferAmount)}</span>
                </div>
                {formData.isDonateChecked && donationAmount > 0 && (
                  <div className="flex justify-between text-sm text-teal-600">
                    <span>環境保全寄付</span>
                    <span>{formatCurrency(donationAmount)}</span>
                  </div>
                )}
                <div className="pt-2 border-t border-stone-200">
                  <div className="flex justify-between font-medium">
                    <span>合計</span>
                    <span>{formatCurrency(totalAmount)}</span>
                  </div>
                </div>
              </div>
            )}

            {/* グローバルエラー表示 */}
            {error && <ErrorDisplay error={error} variant="banner" />}

            {/* 送金ボタン */}
            <Button
              type="submit"
              disabled={isProcessing || !formData.recipient || !formData.amount}
              className="w-full bg-teal-700 hover:bg-teal-800 text-white"
            >
              {isProcessing ? "処理中..." : "送金する"}
            </Button>
          </form>
        </CardContent>
      </Card>
    </>
  );
};
</file>

<file path="src/features/transfer/hooks/index.ts">
export { useTransferForm } from "./useTransferForm";
export { useSplitForm } from "./useSplitForm";
export { useSplitHistory } from "./useSplitHistory";
export type { SortType, SortOrder, StatusFilter } from "./useSplitHistory";
</file>

<file path="src/features/transfer/hooks/useSplitHistory.ts">
"use client";

import { useState, useMemo } from "react";
import { SplitHistory } from "../types/transfer";

export type SortType = "date" | "amount" | "participants";
export type SortOrder = "asc" | "desc";
export type StatusFilter = "all" | "completed" | "pending" | "cancelled";

interface UseSplitHistoryProps {
  histories: SplitHistory[];
}

export const useSplitHistory = ({ histories }: UseSplitHistoryProps) => {
  const [statusFilter, setStatusFilter] = useState<StatusFilter>("all");
  const [sortType, setSortType] = useState<SortType>("date");
  const [sortOrder, setSortOrder] = useState<SortOrder>("desc");
  const [searchQuery, setSearchQuery] = useState("");

  const filteredAndSortedHistories = useMemo(() => {
    // フィルタリング
    let filtered = histories;

    // ステータスフィルター
    if (statusFilter !== "all") {
      filtered = filtered.filter((history) => history.status === statusFilter);
    }

    // 検索フィルター
    if (searchQuery) {
      filtered = filtered.filter((history) =>
        history.title.toLowerCase().includes(searchQuery.toLowerCase()),
      );
    }

    // ソート
    const sorted = [...filtered].sort((a, b) => {
      let comparison = 0;

      switch (sortType) {
        case "date":
          comparison = new Date(a.date).getTime() - new Date(b.date).getTime();
          break;
        case "amount":
          comparison = a.amount - b.amount;
          break;
        case "participants":
          comparison = a.participantCount - b.participantCount;
          break;
      }

      return sortOrder === "asc" ? comparison : -comparison;
    });

    return sorted;
  }, [histories, statusFilter, sortType, sortOrder, searchQuery]);

  // ステータス別の件数を計算
  const statusCounts = useMemo(() => {
    return histories.reduce(
      (acc, history) => {
        acc[history.status] = (acc[history.status] || 0) + 1;
        acc.all += 1;
        return acc;
      },
      { all: 0, completed: 0, pending: 0, cancelled: 0 },
    );
  }, [histories]);

  return {
    filteredHistories: filteredAndSortedHistories,
    statusFilter,
    setStatusFilter,
    sortType,
    setSortType,
    sortOrder,
    setSortOrder,
    searchQuery,
    setSearchQuery,
    statusCounts,
  };
};
</file>

<file path="src/features/transfer/utils/validation.ts">
import { Result, ok, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";
import {
  validateAmountResult,
  validateEmailResult,
  validateRequiredField,
} from "@/lib/utils/validation";
import {
  TransferFormData,
  SplitFormData,
  SplitParticipant,
  Recipient,
} from "../types/transfer";

/**
 * 送金フォームのバリデーション
 */
export const validateTransferForm = (
  formData: TransferFormData,
  userBalance: number,
): { isValid: boolean; error?: string } => {
  const { selectedRecipient, recipient, amount, isDonateChecked } = formData;

  // 送金先のチェック
  if (!selectedRecipient && !recipient) {
    return { isValid: false, error: "送金先を選択または入力してください" };
  }

  // 金額のチェック
  const amountNum = Number(amount);
  if (!amount || isNaN(amountNum) || amountNum <= 0) {
    return { isValid: false, error: "有効な金額を入力してください" };
  }

  // 残高チェック
  const donationAmount = isDonateChecked ? Math.ceil(amountNum * 0.01) : 0;
  const totalAmount = amountNum + donationAmount;

  if (totalAmount > userBalance) {
    return { isValid: false, error: "残高が不足しています" };
  }

  return { isValid: true };
};

/**
 * 割り勘フォームのバリデーション
 */
export const validateSplitForm = (
  formData: SplitFormData,
): { isValid: boolean; error?: string } => {
  const { splitTitle, totalAmount, participants } = formData;

  // タイトルのチェック
  if (!splitTitle) {
    return { isValid: false, error: "タイトルを入力してください" };
  }

  // 合計金額のチェック
  const totalAmountNum = Number(totalAmount);
  if (!totalAmount || isNaN(totalAmountNum) || totalAmountNum <= 0) {
    return { isValid: false, error: "有効な合計金額を入力してください" };
  }

  // 参加者の金額合計チェック
  const participantsTotal = participants.reduce((sum, p) => {
    const pAmount = Number(p.amount) || 0;
    return sum + pAmount;
  }, 0);

  if (participantsTotal !== totalAmountNum) {
    return {
      isValid: false,
      error: `参加者の金額合計（${participantsTotal}円）が合計金額（${totalAmount}円）と一致しません`,
    };
  }

  // メールアドレスのチェック
  const missingEmail = participants.find(
    (p) => !p.isEcoUser && p.id !== "self" && !p.email,
  );
  if (missingEmail) {
    return {
      isValid: false,
      error: `${missingEmail.name}のメールアドレスを入力してください`,
    };
  }

  return { isValid: true };
};

/**
 * 環境貢献額を計算
 */
export const calculateEcoDonation = (amount: number): number => {
  return Math.ceil(amount * 0.01);
};

/**
 * 参加者に均等に金額を分配
 */
export const distributeAmountEvenly = (
  totalAmount: number,
  participants: SplitParticipant[],
): SplitParticipant[] => {
  const totalAmountNum = Number(totalAmount);
  if (
    isNaN(totalAmountNum) ||
    totalAmountNum <= 0 ||
    participants.length === 0
  ) {
    return participants;
  }

  const evenAmount = Math.floor(totalAmountNum / participants.length);
  const remainder = totalAmountNum - evenAmount * participants.length;

  return participants.map((p, index) => ({
    ...p,
    amount: index === 0 ? String(evenAmount + remainder) : String(evenAmount),
  }));
};

/**
 * 自分以外の参加者から回収する金額を計算
 */
export const calculateReceivableAmount = (
  participants: SplitParticipant[],
): number => {
  return participants
    .filter((p) => p.id !== "self")
    .reduce((sum, p) => sum + Number(p.amount || 0), 0);
};

/**
 * メールアドレスのバリデーション
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// =============================================================================
// Result型対応のバリデーション関数（新規）
// =============================================================================

/**
 * 送金フォームのバリデーション（Result型版）
 */
export const validateTransferFormResult = (
  formData: TransferFormData,
  userBalance: number,
): Result<TransferFormData, AppError> => {
  const { selectedRecipient, recipient, amount, isDonateChecked } = formData;

  // 送金先のチェック
  if (!selectedRecipient && !recipient) {
    return err({
      type: "REQUIRED_FIELD",
      message: "送金先を選択または入力してください",
      field: "recipient",
    });
  }

  // 金額のバリデーション
  const amountValidation = validateAmountResult(amount);
  if (amountValidation.isErr()) {
    return err(amountValidation.error);
  }

  const amountNum = amountValidation.value;
  const donationAmount = isDonateChecked ? calculateEcoDonation(amountNum) : 0;
  const totalAmount = amountNum + donationAmount;

  // 残高チェック
  if (totalAmount > userBalance) {
    return err({
      type: "INSUFFICIENT_BALANCE",
      message: "残高が不足しています",
      required: totalAmount,
      available: userBalance,
    });
  }

  return ok(formData);
};

/**
 * 割り勘フォームのバリデーション（Result型版）
 */
export const validateSplitFormResult = (
  formData: SplitFormData,
): Result<SplitFormData, AppError> => {
  const { splitTitle, totalAmount, participants } = formData;

  // タイトルのチェック
  const titleValidation = validateRequiredField(splitTitle, "タイトル");
  if (titleValidation.isErr()) {
    return err(titleValidation.error);
  }

  // 合計金額のチェック
  const totalAmountValidation = validateAmountResult(totalAmount);
  if (totalAmountValidation.isErr()) {
    return err({
      ...totalAmountValidation.error,
      message: "有効な合計金額を入力してください",
    });
  }

  const totalAmountNum = totalAmountValidation.value;

  // 参加者の金額合計チェック
  const participantsTotal = participants.reduce((sum, p) => {
    const pAmount = Number(p.amount) || 0;
    return sum + pAmount;
  }, 0);

  if (participantsTotal !== totalAmountNum) {
    return err({
      type: "INVALID_FORMAT",
      message: `参加者の金額合計（${participantsTotal}円）が合計金額（${totalAmount}円）と一致しません`,
      field: "participants",
      expected: `合計${totalAmountNum}円`,
    });
  }

  // メールアドレスのチェック
  const missingEmailParticipant = participants.find(
    (p) => !p.isEcoUser && p.id !== "self" && !p.email,
  );
  if (missingEmailParticipant) {
    return err({
      type: "REQUIRED_FIELD",
      message: `${missingEmailParticipant.name}のメールアドレスを入力してください`,
      field: "email",
    });
  }

  // 各参加者のメールアドレスの形式チェック
  for (const participant of participants) {
    if (participant.email && participant.id !== "self") {
      const emailValidation = validateEmailResult(participant.email);
      if (emailValidation.isErr()) {
        return err({
          ...emailValidation.error,
          message: `${participant.name}のメールアドレスが正しくありません`,
        });
      }
    }
  }

  return ok(formData);
};

/**
 * 送金金額の妥当性チェック（Result型版）
 */
export const validateTransferAmountResult = (
  amount: string,
  userBalance: number,
  isDonateChecked: boolean = false,
): Result<
  { transferAmount: number; donationAmount: number; totalAmount: number },
  AppError
> => {
  // 金額のバリデーション
  const amountValidation = validateAmountResult(amount);
  if (amountValidation.isErr()) {
    return err(amountValidation.error);
  }

  const transferAmount = amountValidation.value;
  const donationAmount = isDonateChecked
    ? calculateEcoDonation(transferAmount)
    : 0;
  const totalAmount = transferAmount + donationAmount;

  // 残高チェック
  if (totalAmount > userBalance) {
    return err({
      type: "INSUFFICIENT_BALANCE",
      message: "残高が不足しています",
      required: totalAmount,
      available: userBalance,
    });
  }

  return ok({
    transferAmount,
    donationAmount,
    totalAmount,
  });
};

/**
 * 受取人情報の検証（Result型版）
 */
export const validateRecipientResult = (
  selectedRecipient: Recipient | null,
  recipientInput: string,
): Result<string, AppError> => {
  if (selectedRecipient) {
    return ok(selectedRecipient.name);
  }

  const recipientValidation = validateRequiredField(recipientInput, "送金先");
  if (recipientValidation.isErr()) {
    return err(recipientValidation.error);
  }

  return ok(recipientValidation.value);
};
</file>

<file path="src/lib/utils/index.ts">
/**
 * ユーティリティモジュールのメインエントリポイント
 * アプリケーション全体からのインポートはこのファイル経由で行う
 */

// エコ関連のユーティリティをエクスポート
export * as eco from "./eco";

// トランザクション関連のユーティリティをエクスポート
export * as transactions from "./transactions";
</file>

<file path="src/lib/utils/validation.ts">
/**
 * バリデーション関数
 *
 * このファイルには従来のバリデーション関数とResult型対応の新しいバリデーション関数が含まれています。
 * neverthrow導入の段階的移行のため、両方の形式をサポートしています。
 */

import { Result, ok, err } from "neverthrow";
import { ValidationError } from "@/shared/types/errors";

// =============================================================================
// 従来のバリデーション関数（段階的移行のため残存）
// =============================================================================

/**
 * メールアドレスの検証（従来版）
 * @param email メールアドレス
 * @returns 有効な場合true
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
  return emailRegex.test(email);
}

/**
 * パスワードの強度を確認（従来版）
 * @param password パスワード
 * @returns 検証結果と理由
 */
export function validatePassword(password: string): {
  isValid: boolean;
  reason?: string;
} {
  if (password.length < 8) {
    return {
      isValid: false,
      reason: "パスワードは8文字以上である必要があります",
    };
  }

  // 数字を含むか
  if (!/\d/.test(password)) {
    return { isValid: false, reason: "パスワードは数字を含む必要があります" };
  }

  // 記号を含むか
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    return { isValid: false, reason: "パスワードは記号を含む必要があります" };
  }

  return { isValid: true };
}

/**
 * 金額の検証（従来版）
 * @param amount 金額文字列
 * @param min 最小値
 * @param max 最大値
 * @returns 検証結果と理由
 */
export function validateAmount(
  amount: string,
  min?: number,
  max?: number,
): { isValid: boolean; reason?: string } {
  const numAmount = Number(amount);

  if (isNaN(numAmount)) {
    return { isValid: false, reason: "有効な金額を入力してください" };
  }

  if (numAmount <= 0) {
    return {
      isValid: false,
      reason: "金額は0より大きい値である必要があります",
    };
  }

  if (min !== undefined && numAmount < min) {
    return { isValid: false, reason: `金額は${min}円以上である必要があります` };
  }

  if (max !== undefined && numAmount > max) {
    return { isValid: false, reason: `金額は${max}円以下である必要があります` };
  }

  return { isValid: true };
}

// =============================================================================
// Result型対応のバリデーション関数（新規）
// =============================================================================

/**
 * メールアドレスの検証（Result型版）
 * @param email メールアドレス
 * @returns Result型での検証結果
 */
export function validateEmailResult(
  email: string,
): Result<string, ValidationError> {
  if (!email || email.trim() === "") {
    return err({
      type: "REQUIRED_FIELD",
      message: "メールアドレスは必須です",
      field: "email",
    });
  }

  const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
  if (!emailRegex.test(email)) {
    return err({
      type: "INVALID_EMAIL",
      message: "有効なメールアドレスを入力してください",
      field: "email",
    });
  }

  return ok(email);
}

/**
 * パスワードの強度を確認（Result型版）
 * @param password パスワード
 * @returns Result型での検証結果
 */
export function validatePasswordResult(
  password: string,
): Result<string, ValidationError> {
  if (!password || password.trim() === "") {
    return err({
      type: "REQUIRED_FIELD",
      message: "パスワードは必須です",
      field: "password",
    });
  }

  const requirements: string[] = [];

  if (password.length < 8) {
    requirements.push("8文字以上");
  }

  if (!/\d/.test(password)) {
    requirements.push("数字を含む");
  }

  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    requirements.push("記号を含む");
  }

  if (requirements.length > 0) {
    return err({
      type: "INVALID_PASSWORD",
      message: `パスワードは以下の条件を満たす必要があります: ${requirements.join("、")}`,
      field: "password",
      requirements,
    });
  }

  return ok(password);
}

/**
 * 金額の検証（Result型版）
 * @param amount 金額文字列
 * @param min 最小値
 * @param max 最大値
 * @returns Result型での検証結果（成功時は数値を返す）
 */
export function validateAmountResult(
  amount: string,
  min?: number,
  max?: number,
): Result<number, ValidationError> {
  if (!amount || amount.trim() === "") {
    return err({
      type: "REQUIRED_FIELD",
      message: "金額は必須です",
      field: "amount",
    });
  }

  const numAmount = Number(amount);

  if (isNaN(numAmount)) {
    return err({
      type: "INVALID_AMOUNT",
      message: "有効な金額を入力してください",
      field: "amount",
    });
  }

  if (numAmount <= 0) {
    return err({
      type: "INVALID_AMOUNT",
      message: "金額は0より大きい値である必要があります",
      field: "amount",
      min: 1,
    });
  }

  if (min !== undefined && numAmount < min) {
    return err({
      type: "INVALID_RANGE",
      message: `金額は${min}円以上である必要があります`,
      field: "amount",
      min,
      max: max || Number.MAX_SAFE_INTEGER,
      actual: numAmount,
    });
  }

  if (max !== undefined && numAmount > max) {
    return err({
      type: "INVALID_RANGE",
      message: `金額は${max}円以下である必要があります`,
      field: "amount",
      min: min || 0,
      max,
      actual: numAmount,
    });
  }

  return ok(numAmount);
}

/**
 * 必須フィールドの検証（Result型版）
 * @param value 検証対象の値
 * @param fieldName フィールド名
 * @returns Result型での検証結果
 */
export function validateRequiredField(
  value: string | null | undefined,
  fieldName: string,
): Result<string, ValidationError> {
  if (!value || value.trim() === "") {
    return err({
      type: "REQUIRED_FIELD",
      message: `${fieldName}は必須項目です`,
      field: fieldName,
    });
  }

  return ok(value.trim());
}

/**
 * パスワード確認の検証（Result型版）
 * @param password パスワード
 * @param confirmPassword 確認用パスワード
 * @returns Result型での検証結果
 */
export function validatePasswordConfirmation(
  password: string,
  confirmPassword: string,
): Result<string, ValidationError> {
  if (password !== confirmPassword) {
    return err({
      type: "PASSWORD_MISMATCH",
      message: "パスワードが一致しません",
      fields: ["password", "confirmPassword"],
    });
  }

  return ok(password);
}

/**
 * 文字列の長さ検証（Result型版）
 * @param value 検証対象の値
 * @param fieldName フィールド名
 * @param minLength 最小長
 * @param maxLength 最大長
 * @returns Result型での検証結果
 */
export function validateStringLength(
  value: string,
  fieldName: string,
  minLength?: number,
  maxLength?: number,
): Result<string, ValidationError> {
  if (minLength !== undefined && value.length < minLength) {
    return err({
      type: "INVALID_RANGE",
      message: `${fieldName}は${minLength}文字以上である必要があります`,
      field: fieldName,
      min: minLength,
      max: maxLength || Number.MAX_SAFE_INTEGER,
      actual: value.length,
    });
  }

  if (maxLength !== undefined && value.length > maxLength) {
    return err({
      type: "INVALID_RANGE",
      message: `${fieldName}は${maxLength}文字以下である必要があります`,
      field: fieldName,
      min: minLength || 0,
      max: maxLength,
      actual: value.length,
    });
  }

  return ok(value);
}

/**
 * 数値範囲の検証（Result型版）
 * @param value 検証対象の数値
 * @param fieldName フィールド名
 * @param min 最小値
 * @param max 最大値
 * @returns Result型での検証結果
 */
export function validateNumberRange(
  value: number,
  fieldName: string,
  min?: number,
  max?: number,
): Result<number, ValidationError> {
  if (min !== undefined && value < min) {
    return err({
      type: "INVALID_RANGE",
      message: `${fieldName}は${min}以上である必要があります`,
      field: fieldName,
      min,
      max: max || Number.MAX_SAFE_INTEGER,
      actual: value,
    });
  }

  if (max !== undefined && value > max) {
    return err({
      type: "INVALID_RANGE",
      message: `${fieldName}は${max}以下である必要があります`,
      field: fieldName,
      min: min || Number.MIN_SAFE_INTEGER,
      max,
      actual: value,
    });
  }

  return ok(value);
}

/**
 * 電話番号の検証（Result型版）
 * @param phone 電話番号
 * @returns Result型での検証結果
 */
export function validatePhoneResult(
  phone: string,
): Result<string, ValidationError> {
  if (!phone || phone.trim() === "") {
    return err({
      type: "REQUIRED_FIELD",
      message: "電話番号は必須です",
      field: "phone",
    });
  }

  // 日本の電話番号の基本的なパターンをチェック
  // 090-XXXX-XXXX、080-XXXX-XXXX、070-XXXX-XXXX、03-XXXX-XXXX など
  const phoneRegex = /^(\d{2,4}-\d{4}-\d{4}|\d{10,11})$/;
  const cleanPhone = phone.replace(/[-\s]/g, "");

  if (!phoneRegex.test(phone) && !/^\d{10,11}$/.test(cleanPhone)) {
    return err({
      type: "INVALID_FORMAT",
      message: "有効な電話番号を入力してください（例: 090-1234-5678）",
      field: "phone",
      expected: "XXX-XXXX-XXXX形式",
    });
  }

  return ok(phone);
}

if (import.meta.vitest) {
  const { test, expect, describe } = import.meta.vitest;

  describe("validateEmailResult", () => {
    test("validates correct email", () => {
      const result = validateEmailResult("test@example.com");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("test@example.com");
    });

    test("rejects invalid email", () => {
      const result = validateEmailResult("invalid-email");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("INVALID_EMAIL");
      }
    });

    test("rejects empty email", () => {
      const result = validateEmailResult("");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("REQUIRED_FIELD");
      }
    });
  });

  describe("validatePasswordResult", () => {
    test("validates strong password", () => {
      const result = validatePasswordResult("MyPass123!");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("MyPass123!");
    });

    test("rejects weak password", () => {
      const result = validatePasswordResult("weak");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("INVALID_PASSWORD");
        if (result.error.type === "INVALID_PASSWORD") {
          expect(result.error.requirements?.length).toBeGreaterThan(0);
        }
      }
    });

    test("rejects empty password", () => {
      const result = validatePasswordResult("");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("REQUIRED_FIELD");
      }
    });
  });

  describe("validateAmountResult", () => {
    test("validates correct amount", () => {
      const result = validateAmountResult("1000");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr(0)).toBe(1000);
    });

    test("validates amount with range", () => {
      const result = validateAmountResult("500", 100, 1000);
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr(0)).toBe(500);
    });

    test("rejects amount below minimum", () => {
      const result = validateAmountResult("50", 100, 1000);
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("INVALID_RANGE");
      }
    });

    test("rejects amount above maximum", () => {
      const result = validateAmountResult("1500", 100, 1000);
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("INVALID_RANGE");
      }
    });

    test("rejects invalid number", () => {
      const result = validateAmountResult("not-a-number");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("INVALID_AMOUNT");
      }
    });

    test("rejects empty amount", () => {
      const result = validateAmountResult("");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("REQUIRED_FIELD");
      }
    });
  });

  describe("validatePasswordConfirmation", () => {
    test("validates matching passwords", () => {
      const result = validatePasswordConfirmation("password123", "password123");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("password123");
    });

    test("rejects non-matching passwords", () => {
      const result = validatePasswordConfirmation("password123", "different");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("PASSWORD_MISMATCH");
      }
    });
  });

  describe("validateRequiredField", () => {
    test("validates non-empty field", () => {
      const result = validateRequiredField("value", "fieldName");
      expect(result.isOk()).toBe(true);
      expect(result.unwrapOr("")).toBe("value");
    });

    test("rejects empty field", () => {
      const result = validateRequiredField("", "fieldName");
      expect(result.isErr()).toBe(true);
      if (result.isErr() && result.error.type === "REQUIRED_FIELD") {
        expect(result.error.type).toBe("REQUIRED_FIELD");
        expect(result.error.field).toBe("fieldName");
      }
    });

    test("rejects null field", () => {
      const result = validateRequiredField(null, "fieldName");
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("REQUIRED_FIELD");
      }
    });
  });
}
</file>

<file path="src/shared/stores/app.slice.ts">
/**
 * アプリケーション共通状態管理ストア（Result型対応）
 */

import { create } from "zustand";
import { Result, ok, err } from "neverthrow";
import { AppError, BusinessError, ErrorSeverity } from "../types/errors";
import {
  getErrorMessage,
  getErrorSeverity,
  isRetryableError,
} from "@/lib/utils/error-utils";

/**
 * アプリケーション通知の型定義（AppError対応）
 */
export interface AppNotification {
  id: string;
  type: "success" | "error" | "warning" | "info";
  title: string;
  message?: string;
  duration?: number;
  action?: {
    label: string;
    onClick: () => void;
  };
  timestamp: Date;
  // AppError情報
  error?: AppError;
  severity?: ErrorSeverity;
  canRetry?: boolean;
}

/**
 * グローバルローディング状態の型定義
 */
export interface LoadingState {
  [key: string]: boolean;
}

/**
 * アプリケーション共通状態の型定義
 */
export interface AppState {
  // 通知管理
  notifications: AppNotification[];

  // グローバルローディング状態
  loading: LoadingState;

  // グローバルエラー状態
  globalError: AppError | null;

  // アプリケーション設定
  settings: {
    theme: "light" | "dark" | "system";
    language: string;
    debugMode: boolean;
  };

  // 通知管理アクション（Result型対応）
  addNotification: (
    notification: Omit<AppNotification, "id" | "timestamp">,
  ) => Result<string, BusinessError>;
  removeNotification: (id: string) => Result<void, BusinessError>;
  clearNotifications: () => void;

  // ローディング状態管理（Result型対応）
  setLoading: (key: string, loading: boolean) => Result<void, BusinessError>;
  getLoading: (key: string) => Result<boolean, BusinessError>;
  clearLoading: () => void;

  // エラー管理（Result型対応）
  setGlobalError: (error: AppError | null) => Result<void, BusinessError>;
  clearGlobalError: () => void;

  // 設定管理（Result型対応）
  updateSettings: (
    settings: Partial<AppState["settings"]>,
  ) => Result<void, BusinessError>;
  resetSettings: () => void;

  // ユーティリティ
  isAnyLoading: () => boolean;
  getActiveNotificationsCount: () => number;
}

/**
 * アプリケーション共通状態管理ストア（Result型対応）
 */
export const useAppStore = create<AppState>((set, get) => ({
  // 初期状態
  notifications: [],
  loading: {},
  globalError: null,
  settings: {
    theme: "system",
    language: "ja",
    debugMode: process.env.NODE_ENV === "development",
  },

  // 通知を追加（Result型対応）
  addNotification: (notification) => {
    try {
      if (!notification.title || notification.title.trim() === "") {
        return err({
          type: "PAYMENT_FAILED",
          message: "通知タイトルは必須です",
          reason: `空のタイトル: ${notification.title}`,
          paymentId: undefined,
        });
      }

      const id = `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const newNotification: AppNotification = {
        ...notification,
        id,
        timestamp: new Date(),
        duration: notification.duration ?? 5000,
      };

      set((state) => ({
        notifications: [...state.notifications, newNotification],
      }));

      // 自動削除の設定
      if (newNotification.duration && newNotification.duration > 0) {
        setTimeout(() => {
          get().removeNotification(id);
        }, newNotification.duration);
      }

      return ok(id);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "通知の追加に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 通知を削除（Result型対応）
  removeNotification: (id) => {
    try {
      if (!id || id.trim() === "") {
        return err({
          type: "PAYMENT_FAILED",
          message: "通知IDが無効です",
          reason: `空のID: ${id}`,
          paymentId: undefined,
        });
      }

      set((state) => ({
        notifications: state.notifications.filter((n) => n.id !== id),
      }));

      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "通知の削除に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 全通知をクリア
  clearNotifications: () => {
    set({ notifications: [] });
  },

  // ローディング状態を設定（Result型対応）
  setLoading: (key, loading) => {
    try {
      if (!key || key.trim() === "") {
        return err({
          type: "PAYMENT_FAILED",
          message: "ローディングキーが無効です",
          reason: `空のキー: ${key}`,
          paymentId: undefined,
        });
      }

      set((state) => ({
        loading: {
          ...state.loading,
          [key]: loading,
        },
      }));

      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "ローディング状態の設定に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // ローディング状態を取得（Result型対応）
  getLoading: (key) => {
    try {
      if (!key || key.trim() === "") {
        return err({
          type: "PAYMENT_FAILED",
          message: "ローディングキーが無効です",
          reason: `空のキー: ${key}`,
          paymentId: undefined,
        });
      }

      const loading = get().loading[key] || false;
      return ok(loading);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "ローディング状態の取得に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // ローディング状態をクリア
  clearLoading: () => {
    set({ loading: {} });
  },

  // グローバルエラーを設定（Result型対応）
  setGlobalError: (error) => {
    try {
      set({ globalError: error });
      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "グローバルエラーの設定に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // グローバルエラーをクリア
  clearGlobalError: () => {
    set({ globalError: null });
  },

  // 設定を更新（Result型対応）
  updateSettings: (newSettings) => {
    try {
      if (!newSettings || typeof newSettings !== "object") {
        return err({
          type: "PAYMENT_FAILED",
          message: "設定データが無効です",
          reason: `無効な設定: ${JSON.stringify(newSettings)}`,
          paymentId: undefined,
        });
      }

      set((state) => ({
        settings: {
          ...state.settings,
          ...newSettings,
        },
      }));

      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "設定の更新に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 設定をリセット
  resetSettings: () => {
    set({
      settings: {
        theme: "system",
        language: "ja",
        debugMode: process.env.NODE_ENV === "development",
      },
    });
  },

  // いずれかのローディング状態が有効かチェック
  isAnyLoading: () => {
    const loading = get().loading;
    return Object.values(loading).some((isLoading) => isLoading);
  },

  // アクティブな通知数を取得
  getActiveNotificationsCount: () => {
    return get().notifications.length;
  },
}));

// 便利な通知作成ヘルパー関数
export const createSuccessNotification = (
  title: string,
  message?: string,
): Omit<AppNotification, "id" | "timestamp"> => ({
  type: "success",
  title,
  message,
  duration: 3000,
});

export const createErrorNotification = (
  title: string,
  message?: string,
  error?: AppError,
): Omit<AppNotification, "id" | "timestamp"> => ({
  type: "error",
  title,
  message: message || (error ? getErrorMessage(error) : undefined),
  duration: 8000,
  error,
  severity: error ? getErrorSeverity(error) : "high",
  canRetry: error ? isRetryableError(error) : false,
});

export const createWarningNotification = (
  title: string,
  message?: string,
): Omit<AppNotification, "id" | "timestamp"> => ({
  type: "warning",
  title,
  message,
  duration: 5000,
});

export const createInfoNotification = (
  title: string,
  message?: string,
): Omit<AppNotification, "id" | "timestamp"> => ({
  type: "info",
  title,
  message,
  duration: 4000,
});

/**
 * AppError型から適切な通知を自動生成
 */
export const createAppErrorNotification = (
  error: AppError,
  customTitle?: string,
  customMessage?: string,
): Omit<AppNotification, "id" | "timestamp"> => {
  const severity = getErrorSeverity(error);
  const message = customMessage || getErrorMessage(error);
  const canRetry = isRetryableError(error);

  // 重要度に基づいてタイプと期間を決定
  const getTypeAndDuration = (severity: ErrorSeverity) => {
    switch (severity) {
      case "low":
        return { type: "info" as const, duration: 4000 };
      case "medium":
        return { type: "warning" as const, duration: 6000 };
      case "high":
        return { type: "error" as const, duration: 8000 };
      case "critical":
        return { type: "error" as const, duration: 12000 };
      default:
        return { type: "error" as const, duration: 8000 };
    }
  };

  const { type, duration } = getTypeAndDuration(severity);

  // カスタムタイトルがない場合はエラータイプから生成
  const title = customTitle || getDefaultErrorTitle(error);

  return {
    type,
    title,
    message,
    duration,
    error,
    severity,
    canRetry,
  };
};

/**
 * エラータイプから適切なタイトルを生成
 */
const getDefaultErrorTitle = (error: AppError): string => {
  switch (error.type) {
    // ValidationError
    case "INVALID_EMAIL":
    case "INVALID_AMOUNT":
    case "REQUIRED_FIELD":
    case "INVALID_FORMAT":
    case "INVALID_PASSWORD":
    case "PASSWORD_MISMATCH":
    case "INVALID_RANGE":
      return "入力エラー";

    // ApiError
    case "NETWORK_ERROR":
      return "ネットワークエラー";
    case "SERVER_ERROR":
      return "サーバーエラー";
    case "TIMEOUT_ERROR":
      return "タイムアウトエラー";
    case "UNAUTHORIZED":
      return "認証エラー";
    case "FORBIDDEN":
      return "アクセス権限エラー";
    case "NOT_FOUND":
      return "リソースが見つかりません";
    case "CONFLICT":
      return "データ競合エラー";
    case "RATE_LIMIT_EXCEEDED":
      return "リクエスト制限";
    case "BAD_REQUEST":
      return "リクエストエラー";

    // BusinessError
    case "INSUFFICIENT_BALANCE":
      return "残高不足";
    case "PAYMENT_FAILED":
      return "決済エラー";
    case "TRANSACTION_LIMIT_EXCEEDED":
      return "取引限度額超過";
    case "CAMPAIGN_NOT_ACTIVE":
      return "キャンペーンエラー";
    case "DONATION_LIMIT_EXCEEDED":
      return "寄付限度額超過";
    case "ACCOUNT_SUSPENDED":
      return "アカウント停止";
    case "KYC_REQUIRED":
      return "本人確認が必要";
    case "CHARGE_MINIMUM_NOT_MET":
      return "チャージエラー";
    case "INVALID_QR_CODE":
      return "QRコードエラー";
    case "TRANSFER_TO_SELF":
      return "送金エラー";

    default:
      return "エラーが発生しました";
  }
};

/**
 * 複数のAppErrorから通知を一括作成
 */
export const createMultipleAppErrorNotifications = (
  errors: AppError[],
  customTitle?: string,
): Omit<AppNotification, "id" | "timestamp">[] => {
  if (errors.length === 0) return [];

  // 単一エラーの場合
  if (errors.length === 1) {
    return [createAppErrorNotification(errors[0], customTitle)];
  }

  // 複数エラーの場合は重要度で統合
  const highestSeverity = errors.reduce((highest, error) => {
    const severity = getErrorSeverity(error);
    const severityOrder = { low: 1, medium: 2, high: 3, critical: 4 };
    return severityOrder[severity] > severityOrder[highest]
      ? severity
      : highest;
  }, "low" as ErrorSeverity);

  const errorMessages = errors.map((error) => getErrorMessage(error));
  const combinedMessage = `以下のエラーが発生しました:\n${errorMessages.map((msg, index) => `${index + 1}. ${msg}`).join("\n")}`;

  const { type, duration } = (() => {
    switch (highestSeverity) {
      case "low":
        return { type: "info" as const, duration: 6000 };
      case "medium":
        return { type: "warning" as const, duration: 8000 };
      case "high":
        return { type: "error" as const, duration: 10000 };
      case "critical":
        return { type: "error" as const, duration: 15000 };
      default:
        return { type: "error" as const, duration: 10000 };
    }
  })();

  return [
    {
      type,
      title: customTitle || `${errors.length}件のエラーが発生しました`,
      message: combinedMessage,
      duration,
      severity: highestSeverity,
      canRetry: errors.some(isRetryableError),
    },
  ];
};

/**
 * AppStoreと連携した便利な通知関数
 */
export const showAppErrorNotification = (
  error: AppError,
  customTitle?: string,
  customMessage?: string,
): Result<string, BusinessError> => {
  const notification = createAppErrorNotification(
    error,
    customTitle,
    customMessage,
  );
  return useAppStore.getState().addNotification(notification);
};

export const showMultipleAppErrorNotifications = (
  errors: AppError[],
  customTitle?: string,
): Result<string[], BusinessError> => {
  const notifications = createMultipleAppErrorNotifications(
    errors,
    customTitle,
  );
  const results = notifications.map((notification) =>
    useAppStore.getState().addNotification(notification),
  );

  // すべて成功した場合のみ成功とする
  const failedResults = results.filter((result) => result.isErr());
  if (failedResults.length > 0) {
    return err(failedResults[0]._unsafeUnwrapErr());
  }

  return ok(results.map((result) => result._unsafeUnwrap()));
};

// In Source Testing
if (import.meta.vitest) {
  const { describe, it, expect, beforeEach } = import.meta.vitest;

  describe("AppStore", () => {
    beforeEach(() => {
      // ストアをリセット
      useAppStore.setState({
        notifications: [],
        loading: {},
        globalError: null,
        settings: {
          theme: "system",
          language: "ja",
          debugMode: false,
        },
      });
    });

    describe("addNotification", () => {
      it("有効な通知を追加できる", () => {
        const notification = {
          type: "success" as const,
          title: "テスト通知",
          message: "テストメッセージ",
        };

        const result = useAppStore.getState().addNotification(notification);
        expect(result.isOk()).toBe(true);

        const notificationId = result._unsafeUnwrap();
        expect(typeof notificationId).toBe("string");
        expect(useAppStore.getState().notifications).toHaveLength(1);
      });

      it("タイトルが空の場合、エラーを返す", () => {
        const notification = {
          type: "success" as const,
          title: "",
          message: "テストメッセージ",
        };

        const result = useAppStore.getState().addNotification(notification);
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
      });
    });

    describe("removeNotification", () => {
      it("通知を削除できる", () => {
        const addResult = useAppStore.getState().addNotification({
          type: "info",
          title: "テスト通知",
        });
        const notificationId = addResult._unsafeUnwrap();

        const removeResult = useAppStore
          .getState()
          .removeNotification(notificationId);
        expect(removeResult.isOk()).toBe(true);
        expect(useAppStore.getState().notifications).toHaveLength(0);
      });

      it("無効なIDの場合、エラーを返す", () => {
        const result = useAppStore.getState().removeNotification("");
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
      });
    });

    describe("setLoading", () => {
      it("ローディング状態を設定できる", () => {
        const result = useAppStore.getState().setLoading("test-key", true);
        expect(result.isOk()).toBe(true);
        expect(useAppStore.getState().loading["test-key"]).toBe(true);
      });

      it("無効なキーの場合、エラーを返す", () => {
        const result = useAppStore.getState().setLoading("", true);
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
      });
    });

    describe("getLoading", () => {
      it("ローディング状態を取得できる", () => {
        useAppStore.getState().setLoading("test-key", true);

        const result = useAppStore.getState().getLoading("test-key");
        expect(result.isOk()).toBe(true);
        expect(result._unsafeUnwrap()).toBe(true);
      });

      it("存在しないキーの場合、falseを返す", () => {
        const result = useAppStore.getState().getLoading("non-existent");
        expect(result.isOk()).toBe(true);
        expect(result._unsafeUnwrap()).toBe(false);
      });
    });

    describe("updateSettings", () => {
      it("設定を更新できる", () => {
        const result = useAppStore.getState().updateSettings({
          theme: "dark",
          language: "en",
        });

        expect(result.isOk()).toBe(true);
        expect(useAppStore.getState().settings.theme).toBe("dark");
        expect(useAppStore.getState().settings.language).toBe("en");
      });

      it("無効な設定の場合、エラーを返す", () => {
        const result = useAppStore
          .getState()
          .updateSettings(null as unknown as Partial<AppState["settings"]>);
        expect(result.isErr()).toBe(true);
        expect(result._unsafeUnwrapErr().type).toBe("PAYMENT_FAILED");
      });
    });

    describe("isAnyLoading", () => {
      it("ローディング状態がない場合、falseを返す", () => {
        expect(useAppStore.getState().isAnyLoading()).toBe(false);
      });

      it("いずれかのローディング状態がtrueの場合、trueを返す", () => {
        useAppStore.getState().setLoading("test1", false);
        useAppStore.getState().setLoading("test2", true);

        expect(useAppStore.getState().isAnyLoading()).toBe(true);
      });
    });
  });

  describe("Notification Helpers", () => {
    it("createSuccessNotification", () => {
      const notification = createSuccessNotification(
        "成功",
        "操作が完了しました",
      );
      expect(notification.type).toBe("success");
      expect(notification.title).toBe("成功");
      expect(notification.message).toBe("操作が完了しました");
      expect(notification.duration).toBe(3000);
    });

    it("createErrorNotification", () => {
      const notification = createErrorNotification(
        "エラー",
        "操作に失敗しました",
      );
      expect(notification.type).toBe("error");
      expect(notification.title).toBe("エラー");
      expect(notification.message).toBe("操作に失敗しました");
      expect(notification.duration).toBe(8000);
    });
  });
}
</file>

<file path="src/shared/types/errors.ts">
/**
 * Neverthrow導入に伴うエラー型定義
 *
 * このファイルは、アプリケーション全体で使用される統一されたエラー型を定義します。
 * Result<T, E>型のE部分として使用され、型安全なエラーハンドリングを実現します。
 */

/**
 * バリデーションエラー
 * フォーム入力やデータバリデーションで発生するエラー
 */
export type ValidationError =
  | {
      type: "INVALID_EMAIL";
      message: string;
      field: "email";
    }
  | {
      type: "INVALID_AMOUNT";
      message: string;
      field: "amount";
      min?: number;
      max?: number;
    }
  | {
      type: "REQUIRED_FIELD";
      message: string;
      field: string;
    }
  | {
      type: "INVALID_FORMAT";
      message: string;
      field: string;
      expected: string;
    }
  | {
      type: "INVALID_PASSWORD";
      message: string;
      field: "password";
      requirements?: string[];
    }
  | {
      type: "PASSWORD_MISMATCH";
      message: string;
      fields: ["password", "confirmPassword"];
    }
  | {
      type: "INVALID_RANGE";
      message: string;
      field: string;
      min: number;
      max: number;
      actual: number;
    };

/**
 * APIエラー
 * サーバーとの通信やHTTPリクエストで発生するエラー
 */
export type ApiError =
  | {
      type: "NETWORK_ERROR";
      message: string;
      cause?: Error;
    }
  | {
      type: "SERVER_ERROR";
      message: string;
      statusCode: number;
      details?: Record<string, unknown>;
    }
  | {
      type: "TIMEOUT_ERROR";
      message: string;
      timeoutMs: number;
    }
  | {
      type: "UNAUTHORIZED";
      message: string;
    }
  | {
      type: "FORBIDDEN";
      message: string;
    }
  | {
      type: "NOT_FOUND";
      message: string;
      resource?: string;
    }
  | {
      type: "CONFLICT";
      message: string;
      conflictingResource?: string;
    }
  | {
      type: "RATE_LIMIT_EXCEEDED";
      message: string;
      retryAfter?: number;
    }
  | {
      type: "BAD_REQUEST";
      message: string;
      validationErrors?: ValidationError[];
    };

/**
 * ビジネスロジックエラー
 * アプリケーション固有のビジネスルールに関するエラー
 */
export type BusinessError =
  | {
      type: "INSUFFICIENT_BALANCE";
      message: string;
      required: number;
      available: number;
    }
  | {
      type: "PAYMENT_FAILED";
      message: string;
      reason: string;
      paymentId?: string;
    }
  | {
      type: "TRANSACTION_LIMIT_EXCEEDED";
      message: string;
      limit: number;
      attempted: number;
      limitType: "daily" | "monthly" | "transaction";
    }
  | {
      type: "CAMPAIGN_NOT_ACTIVE";
      message: string;
      campaignId: string;
      startDate?: Date;
      endDate?: Date;
    }
  | {
      type: "DONATION_LIMIT_EXCEEDED";
      message: string;
      maxDonationAmount: number;
      requestedAmount: number;
    }
  | {
      type: "ACCOUNT_SUSPENDED";
      message: string;
      reason: string;
      suspendedUntil?: Date;
    }
  | {
      type: "KYC_REQUIRED";
      message: string;
      requiredLevel: "basic" | "enhanced";
    }
  | {
      type: "CHARGE_MINIMUM_NOT_MET";
      message: string;
      minimum: number;
      requested: number;
    }
  | {
      type: "INVALID_QR_CODE";
      message: string;
      qrCodeType?: "payment" | "transfer" | "unknown";
    }
  | {
      type: "TRANSFER_TO_SELF";
      message: string;
    }
  | {
      type: "TRANSFER_CODE_NOT_FOUND";
      message: string;
    }
  | {
      type: "TRANSFER_COMPLETED";
      message: string;
    }
  | {
      type: "TRANSFER_PENDING";
      message: string;
    }
  | {
      type: "TRANSFER_VERIFICATION_FAILED";
      message: string;
    };

/**
 * 統合エラー型
 * アプリケーション全体で使用される包括的なエラー型
 */
export type AppError = ValidationError | ApiError | BusinessError;

/**
 * エラー重要度レベル
 * ログやアラートの優先度判定に使用
 */
export type ErrorSeverity = "low" | "medium" | "high" | "critical";

/**
 * エラーコンテキスト
 * エラー発生時の追加情報
 */
export interface ErrorContext {
  userId?: string;
  transactionId?: string;
  timestamp: Date;
  userAgent?: string;
  url?: string;
  sessionId?: string;
}

/**
 * 拡張エラー情報
 * デバッグやログ用の詳細エラー情報
 */
export interface ExtendedError {
  error: AppError;
  severity: ErrorSeverity;
  context: ErrorContext;
  stackTrace?: string;
}
</file>

<file path="src/shared/types/transaction.ts">
/**
 * 取引タイプの型定義
 */
export type TransactionType =
  | "payment"
  | "charge"
  | "receive"
  | "donation"
  | "expired";

/**
 * 環境貢献情報の型定義
 */
export interface EcoContribution {
  enabled: boolean;
  amount: number;
  project?: string; // 環境貢献プロジェクト名
}

/**
 * キャンペーン情報の型定義
 */
export interface CampaignInfo {
  name: string; // キャンペーン名
  expiryDate?: string; // 有効期限
  expiredDate?: string; // 期限切れ日
}

/**
 * 割り勘情報の型定義
 */
export interface SplitInfo {
  participants: number; // 参加者数
  collected: number; // 回収済み人数
  remaining: number; // 残り人数
}

/**
 * 取引情報の型定義
 */
export interface Transaction {
  id: string;
  type: TransactionType;
  description: string;
  date: string;
  amount: number;
  ecoContribution?: EcoContribution;
  badges?: string[];
  campaignInfo?: CampaignInfo;
  splitInfo?: SplitInfo;
}
</file>

<file path="src/shared/index.ts">
/**
 * 共通フォルダのエクスポート
 */

// ユーティリティ関数
export * from "./utils/formats";

// カスタムフック
export * from "./hooks";

// 型定義
export * from "./types/transaction";
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "types": ["vitest/importMeta"],
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "**/*_backup_*/**/*", "**/*_backup_*"]
}
</file>

<file path="docs/README.md">
# Eco Wallet ドキュメント

## 概要

このディレクトリには、Eco Walletプロジェクトの技術ドキュメントが含まれています。

## ドキュメント一覧

### アーキテクチャ (`architecture/`)

- **[overview.md](architecture/overview.md)** - 現在のアーキテクチャ概要

  - バーティカルスライスアーキテクチャの説明
  - 17個のfeatureモジュールの一覧と責務
  - ディレクトリ構造と設計原則

- **[development-guide.md](architecture/development-guide.md)** - 開発ガイド

  - 新機能の追加方法
  - 既存機能の修正方法
  - コーディング規約とベストプラクティス
  - テスト方針とパフォーマンス最適化

- **[cline-development-guide.md](architecture/cline-development-guide.md)** - Cline開発ガイド

  - TypeScript特化プロンプトエンジニアリング
  - 効果的なプロンプトパターン（TDD、In Source Testing等）
  - アンチパターンと回避方法
  - Eco Wallet固有の適用方法

- **[neverthrow-migration-guide.md](architecture/neverthrow-migration-guide.md)** - Neverthrow導入ガイド

  - 型安全なエラーハンドリングの導入計画
  - 段階的移行戦略（Phase 1-3）
  - 実装パターンとベストプラクティス
  - トラブルシューティングガイド

- **[neverthrow-progress.md](architecture/neverthrow-progress.md)** - Neverthrow導入進捗管理
  - 進捗ダッシュボードと詳細タスク一覧
  - 作業履歴とセッション間の継続性
  - 品質指標と成功基準
  - 次回作業予定の管理

### デザイン (`design/`)

- **[design-guideline.md](design/design-guideline.md)** - デザインガイドライン
  - ブランドの理念と価値観
  - カラーパレットとタイポグラフィ
  - コンポーネントデザイン仕様
  - 画面別デザインガイドライン
  - アクセシビリティとレスポンシブデザイン

## クイックリンク

- [プロジェクトの構造を理解する](architecture/overview.md)
- [新機能を追加する](architecture/development-guide.md#新機能の追加)
- [デザインシステムを確認する](design/design-guideline.md#2-ビジュアルデザイン要素)

## プロジェクト情報

- **フレームワーク**: Next.js 14 (App Router)
- **UI ライブラリ**: React 18, Tailwind CSS, shadcn/ui
- **状態管理**: Redux Toolkit
- **アーキテクチャ**: バーティカルスライスアーキテクチャ

## 更新履歴

- 2025/01/25 - ドキュメントの整理・統合を実施
- 2025/01/25 - Cline開発ガイドを追加（TypeScript特化プロンプトエンジニアリング）
</file>

<file path="src/app/eco-news/[id]/page.tsx">
import { NewsDetailPage } from "@/features/eco-news";

export default function NewsDetailPageRoute() {
  return <NewsDetailPage />;
}
</file>

<file path="src/app/invite/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import {
  Leaf,
  Users,
  Copy,
  Mail,
  MessageSquare,
  CheckCircle,
} from "lucide-react";
import { useSession } from "next-auth/react";
import { SocialShareButtons, QRCodeDisplay } from "@/features/invite";
import { ReferralCampaignCard } from "@/features/campaigns";
import { PageContainer } from "@/features/layout";

export default function InvitePage() {
  const { data: session } = useSession();
  const [, setActiveTab] = useState("link");
  const [copied, setCopied] = useState(false);
  const [email, setEmail] = useState("");
  const [message, setMessage] = useState("");
  const [emailSent, setEmailSent] = useState(false);
  const [inviteLink, setInviteLink] = useState(""); // 初期値を空に設定

  // クライアントサイドでのみwindowオブジェクトを参照
  useEffect(() => {
    setInviteLink(
      `${window.location.origin}/auth/register?ref=${session?.user?.id || "demo"}`,
    );
  }, [session]);

  // 招待コード（実際の実装ではAPIから取得）
  const inviteCode =
    "ECO" +
    Math.floor(Math.random() * 10000)
      .toString()
      .padStart(4, "0");

  // リンクをコピーする関数
  const copyToClipboard = () => {
    if (inviteLink) {
      navigator.clipboard.writeText(inviteLink);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  // メール送信のシミュレーション
  const handleSendEmail = (e: React.FormEvent) => {
    e.preventDefault();
    // 実際の実装ではここでAPIを呼び出す
    setEmailSent(true);
    setTimeout(() => setEmailSent(false), 3000);
  };

  return (
    <PageContainer title="友達招待">
      <div className="space-y-6">
        <ReferralCampaignCard />
        <Card className="border-0 shadow-md bg-white p-6">
          <div className="flex items-start space-x-4 mb-6">
            <div className="w-12 h-12 bg-teal-100 rounded-full flex items-center justify-center">
              <Users className="h-6 w-6 text-teal-700" />
            </div>
            <div>
              <h2 className="text-lg font-medium text-stone-800">
                友達を招待する
              </h2>
              <p className="text-sm text-stone-600 mt-1">
                友達を招待すると、あなたも友達も
                <span className="font-medium text-amber-600">
                  1,000円分のエコポイント
                </span>
                を獲得できます
              </p>
            </div>
          </div>

          <div className="bg-teal-50 p-4 rounded-md border border-teal-100 mb-6">
            <div className="flex items-start space-x-3">
              <Leaf className="h-5 w-5 text-teal-600 mt-0.5" />
              <div>
                <h3 className="text-sm font-medium text-teal-800">
                  招待の環境効果
                </h3>
                <p className="text-xs text-teal-700 mt-1">
                  友達が参加するごとに、約0.5m²の森林保全に貢献できます。
                  友達10人の招待で、年間約5kgのCO2削減につながります。
                </p>
              </div>
            </div>
          </div>

          <Tabs
            defaultValue="link"
            className="w-full"
            onValueChange={setActiveTab}
          >
            <TabsList className="grid grid-cols-3 bg-stone-100">
              <TabsTrigger value="link" className="text-xs">
                招待リンク
              </TabsTrigger>
              <TabsTrigger value="email" className="text-xs">
                メール招待
              </TabsTrigger>
              <TabsTrigger value="code" className="text-xs">
                招待コード
              </TabsTrigger>
            </TabsList>

            <TabsContent value="link" className="space-y-4 pt-4">
              <p className="text-sm text-stone-600">
                以下のリンクを友達と共有して招待しましょう
              </p>

              <div className="relative">
                <Input
                  value={inviteLink}
                  readOnly
                  className="pr-20 font-mono text-xs border-stone-200"
                />
                <Button
                  variant="ghost"
                  size="sm"
                  className="absolute right-1 top-1 h-7"
                  onClick={copyToClipboard}
                >
                  {copied ? (
                    <CheckCircle className="h-4 w-4 text-green-600" />
                  ) : (
                    <Copy className="h-4 w-4" />
                  )}
                  <span className="ml-1">{copied ? "コピー済" : "コピー"}</span>
                </Button>
              </div>

              {/* QRコード表示を追加 */}
              <div className="flex flex-col items-center py-3 border-t border-b border-stone-100">
                <h4 className="text-sm font-medium text-stone-700 mb-3">
                  QRコードで共有
                </h4>
                <QRCodeDisplay value={inviteLink} />
              </div>

              {/* 新しいSNS共有ボタンに置き換え */}
              <SocialShareButtons
                inviteLink={inviteLink}
                inviteMessage="Eco Walletを試してみませんか？環境に優しい決済で、私たち二人とも1,000円分のエコポイントがもらえます！"
              />

              {/* 既存のSMS送信ボタンはそのまま残しておく */}
              <div className="flex mt-4">
                <Button
                  variant="outline"
                  className="w-full text-stone-700 space-x-2 border-stone-200"
                >
                  <MessageSquare className="h-4 w-4" />
                  <span>SMSで招待する</span>
                </Button>
              </div>

              {/* 環境影響の可視化を追加 */}
              <div className="mt-4 bg-teal-50 p-3 rounded-md border border-teal-100">
                <div className="flex items-start space-x-3">
                  <Leaf className="h-5 w-5 text-teal-600 mt-0.5" />
                  <div>
                    <h4 className="text-sm font-medium text-teal-800">
                      友達招待の環境効果
                    </h4>
                    <p className="text-xs text-teal-700 mt-1">
                      友達が1人参加すると、約0.5m²の森林保全に貢献できます。
                      友達10人の招待で、年間約5kgのCO2削減につながります。
                    </p>
                  </div>
                </div>
              </div>
            </TabsContent>

            <TabsContent value="email" className="space-y-4 pt-4">
              {!emailSent ? (
                <form onSubmit={handleSendEmail} className="space-y-4">
                  <div className="space-y-2">
                    <label htmlFor="email" className="text-sm text-stone-700">
                      友達のメールアドレス
                    </label>
                    <Input
                      id="email"
                      type="email"
                      placeholder="friend@example.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      required
                      className="border-stone-200"
                    />
                  </div>

                  <div className="space-y-2">
                    <label htmlFor="message" className="text-sm text-stone-700">
                      メッセージ (任意)
                    </label>
                    <textarea
                      id="message"
                      placeholder="こんにちは！環境に優しいEco Walletを試してみませんか？登録すると私たち二人とも1,000円分のエコポイントがもらえて、一緒に環境保全に貢献できます。毎回の決済で自動的に森林保全や水資源保護に寄付される仕組みです。ぜひ一緒に始めましょう！"
                      value={message}
                      onChange={(e) => setMessage(e.target.value)}
                      className="w-full p-2 text-sm border border-stone-200 rounded-md min-h-[100px]"
                    />
                  </div>

                  <Button
                    type="submit"
                    className="w-full bg-teal-700 hover:bg-teal-800 text-white"
                  >
                    <Mail className="h-4 w-4 mr-2" />
                    招待メールを送信
                  </Button>
                </form>
              ) : (
                <div className="bg-green-50 p-4 rounded-md border border-green-100 text-center">
                  <CheckCircle className="h-6 w-6 text-green-600 mx-auto mb-2" />
                  <h3 className="text-sm font-medium text-green-800">
                    招待メールを送信しました
                  </h3>
                  <p className="text-xs text-green-700 mt-1">
                    {email} 宛に招待メールを送信しました
                  </p>
                  <Button
                    variant="outline"
                    size="sm"
                    className="mt-3 text-green-700 border-green-200"
                    onClick={() => setEmailSent(false)}
                  >
                    別の友達を招待する
                  </Button>
                </div>
              )}
            </TabsContent>

            <TabsContent value="code" className="space-y-4 pt-4">
              <p className="text-sm text-stone-600">
                友達に以下の招待コードを共有してください。友達は登録時にこのコードを入力できます。
              </p>

              <div className="flex items-center justify-center bg-stone-50 p-6 rounded-md">
                <div className="text-2xl font-bold tracking-wider font-mono text-stone-800">
                  {inviteCode}
                </div>
              </div>

              <div className="text-center">
                <Button
                  variant="outline"
                  size="sm"
                  className="text-stone-700 border-stone-200"
                  onClick={() => {
                    navigator.clipboard.writeText(inviteCode);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                  }}
                >
                  {copied ? (
                    <CheckCircle className="h-4 w-4 text-green-600 mr-1" />
                  ) : (
                    <Copy className="h-4 w-4 mr-1" />
                  )}
                  {copied ? "コピー済" : "コードをコピー"}
                </Button>
              </div>

              <div className="mt-4 bg-teal-50 p-3 rounded-md border border-teal-100">
                <div className="flex items-start space-x-3">
                  <Leaf className="h-5 w-5 text-teal-600 mt-0.5" />
                  <div>
                    <h4 className="text-sm font-medium text-teal-800">
                      コードの渡し方
                    </h4>
                    <p className="text-xs text-teal-700 mt-1">
                      友達に登録時に「招待コード」欄に入力するよう伝えてください。
                      コードを入力することで、お互いに1,000円分のエコポイントが付与されます。
                    </p>
                  </div>
                </div>
              </div>
            </TabsContent>
          </Tabs>
        </Card>

        <InvitationStatusCard />
      </div>
    </PageContainer>
  );
}

// 招待状況を表示するコンポーネント
function InvitationStatusCard() {
  // 実際の実装ではAPIからデータを取得
  const invitations = [
    { email: "tanaka@example.com", status: "accepted", date: "2025/04/15" },
    { email: "suzuki@example.com", status: "pending", date: "2025/04/18" },
    { email: "yamada@example.com", status: "pending", date: "2025/04/20" },
  ];

  return (
    <Card className="border-0 shadow-md bg-white p-6">
      <h3 className="text-lg font-medium text-stone-800 mb-4">招待履歴</h3>

      {invitations.length > 0 ? (
        <div className="space-y-3">
          {invitations.map((invite, index) => (
            <div
              key={index}
              className="flex justify-between items-center p-3 bg-stone-50 rounded-md"
            >
              <div>
                <p className="text-sm font-medium text-stone-800">
                  {invite.email}
                </p>
                <p className="text-xs text-stone-500">{invite.date}</p>
              </div>
              <Badge
                className={
                  invite.status === "accepted"
                    ? "bg-green-100 text-green-800"
                    : "bg-amber-100 text-amber-800"
                }
              >
                {invite.status === "accepted" ? "登録済み" : "未登録"}
              </Badge>
            </div>
          ))}
        </div>
      ) : (
        <div className="text-center p-6">
          <Users className="h-8 w-8 text-stone-400 mx-auto mb-2" />
          <p className="text-sm text-stone-600">招待履歴がありません</p>
        </div>
      )}

      <div className="mt-4 pt-4 border-t border-stone-100">
        <div className="flex justify-between items-center">
          <div className="text-sm text-stone-600">合計獲得ポイント</div>
          <div className="text-lg font-bold text-amber-600">¥1,000</div>
        </div>
        <p className="text-xs text-stone-500 mt-1">
          1人の友達が登録して¥1,000を獲得しました
        </p>
      </div>
    </Card>
  );
}
</file>

<file path="src/app/notifications/[id]/page.tsx">
"use client";

import { useState, useEffect, use } from "react";
import { useRouter } from "next/navigation";
import { PageContainer } from "@/features/layout";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  ArrowLeft,
  Leaf,
  ShoppingBag,
  Megaphone,
  AlertTriangle,
  Bell,
} from "lucide-react";
import { notificationsData } from "@/features/notifications/data/notifications-data";
import {
  Notification,
  NotificationType,
} from "@/features/notifications/types/notification";
import { NotificationCampaignCard } from "@/features/campaigns";

interface NotificationDetailPageProps {
  params: Promise<{
    id: string;
  }>;
}

export default function NotificationDetailPage({
  params,
}: NotificationDetailPageProps) {
  const unwrappedParams = use(params);

  const router = useRouter();
  const [notification, setNotification] = useState<Notification | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 実際の実装ではAPIからデータを取得する
    const foundNotification = notificationsData.find(
      (n) => n.id === unwrappedParams.id,
    );
    setNotification(foundNotification || null);
    setLoading(false);

    // 既読に設定（実際の実装ではAPIを呼び出す）
    if (foundNotification && !foundNotification.isRead) {
      // APIでの既読更新処理をここに記述
    }
  }, [unwrappedParams.id]);

  const getNotificationIcon = (type: NotificationType) => {
    switch (type) {
      case "transaction":
        return <ShoppingBag className="h-6 w-6 text-blue-500" />;
      case "eco_impact":
        return <Leaf className="h-6 w-6 text-teal-600" />;
      case "campaign":
        return <Megaphone className="h-6 w-6 text-amber-500" />;
      case "security":
        return <AlertTriangle className="h-6 w-6 text-red-500" />;
      case "system":
      default:
        return <Bell className="h-6 w-6 text-stone-500" />;
    }
  };

  const getBackgroundColor = (type: NotificationType) => {
    switch (type) {
      case "transaction":
        return "bg-blue-50";
      case "eco_impact":
        return "bg-teal-50";
      case "campaign":
        return "bg-amber-50";
      case "security":
        return "bg-red-50";
      case "system":
      default:
        return "bg-stone-50";
    }
  };

  if (loading) {
    return (
      <PageContainer title="通知の詳細">
        <div className="flex justify-center items-center h-40">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-teal-700"></div>
        </div>
      </PageContainer>
    );
  }

  if (!notification) {
    return (
      <PageContainer title="通知の詳細">
        <div className="text-center py-8">
          <h2 className="text-lg font-medium text-stone-800">
            通知が見つかりませんでした
          </h2>
          <p className="text-sm text-stone-600 mt-2">
            この通知は削除されたか、存在しません。
          </p>
          <Button
            className="mt-4 bg-teal-700 hover:bg-teal-800 text-white"
            onClick={() => router.push("/notifications")}
          >
            通知一覧に戻る
          </Button>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer title="通知の詳細">
      <div className="mb-4">
        <Button
          variant="ghost"
          size="sm"
          className="text-stone-600"
          onClick={() => router.push("/notifications")}
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          通知一覧に戻る
        </Button>
      </div>

      <Card className="border-0 shadow-md bg-white overflow-hidden">
        <div className="p-6">
          <div className="flex items-center space-x-3 mb-4">
            <div
              className={`w-12 h-12 rounded-full flex items-center justify-center ${getBackgroundColor(notification.type)}`}
            >
              {getNotificationIcon(notification.type)}
            </div>
            <div>
              <h1 className="text-lg font-semibold text-stone-800">
                {notification.title}
              </h1>
              <p className="text-xs text-stone-500">{notification.date}</p>
            </div>
          </div>

          <div className="text-sm text-stone-700 leading-relaxed">
            <p>{notification.message}</p>

            {notification.type === "eco_impact" && (
              <div className="mt-4 p-4 bg-teal-50 rounded-lg">
                <h3 className="text-sm font-medium text-teal-800 mb-2">
                  環境貢献の詳細
                </h3>
                <ul className="text-xs text-teal-700 space-y-1 list-disc pl-4">
                  <li>今月の環境保全活動への寄付: ¥850</li>
                  <li>これまでの累計寄付額: ¥12,450</li>
                  <li>保全された森林面積: 5.2 m²</li>
                  <li>削減されたCO2排出量: 25kg</li>
                </ul>
                <Button
                  className="w-full mt-3 bg-teal-700 hover:bg-teal-800 text-white text-xs"
                  onClick={() => router.push("/impact")}
                >
                  環境インパクト詳細を見る
                </Button>
              </div>
            )}

            {notification.type === "transaction" && (
              <div className="mt-4 space-y-3">
                <div className="flex justify-between text-sm">
                  <span className="text-stone-600">金額</span>
                  <span className="font-medium text-stone-800">¥4,000</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-stone-600">環境保全寄付</span>
                  <span className="font-medium text-teal-700">¥200</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-stone-600">日時</span>
                  <span className="font-medium text-stone-800">
                    2025/04/19 12:30
                  </span>
                </div>
                <Button
                  className="w-full mt-1 bg-teal-700 hover:bg-teal-800 text-white text-xs"
                  onClick={() => router.push("/history")}
                >
                  取引履歴を見る
                </Button>
              </div>
            )}

            {notification.type === "campaign" && (
              <div className="mt-4 space-y-3">
                <NotificationCampaignCard campaignId="camp_1" />
              </div>
            )}

            {notification.type === "security" && (
              <div className="mt-4 space-y-3">
                <div className="bg-red-50 p-4 rounded-lg">
                  <h3 className="text-sm font-medium text-red-800 mb-2">
                    セキュリティ情報
                  </h3>
                  <p className="text-xs text-red-700">
                    新しいデバイス（iPhone 13 Pro）からログインがありました。
                    ログイン時間: 2025/04/12 08:23 場所: 東京都渋谷区
                  </p>
                  <div className="flex space-x-2 mt-3">
                    <Button
                      className="flex-1 bg-red-600 hover:bg-red-700 text-white text-xs"
                      onClick={() => router.push("/settings?tab=security")}
                    >
                      不審なログインを報告
                    </Button>
                    <Button className="flex-1 bg-stone-200 hover:bg-stone-300 text-stone-800 text-xs">
                      問題ありません
                    </Button>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </Card>
    </PageContainer>
  );
}
</file>

<file path="src/app/settings/page.tsx">
"use client";

import { useState } from "react";
import { useSession, getSession } from "next-auth/react";
import {
  PageHeader,
  ProfileCard,
  ProfileTab,
  NotificationsTab,
  PaymentTab,
  SecurityTab,
  EcoTab,
} from "@/features/settings";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card } from "@/components/ui/card";
import { User, Bell, CreditCard, Shield, Leaf } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";
import { showAppErrorNotification } from "@/shared/stores/app.slice";

export default function AccountSettingsPage() {
  // セッション管理（Client Component対応）
  const { data: session, status } = useSession();

  // エラーステート管理（Result型対応）
  const [error, setError] = useState<AppError | null>(null);

  // ローディング状態
  const [isLoading, setIsLoading] = useState(false);

  // エラー再試行ハンドラ（Result型対応）
  const handleRetry = () => {
    setError(null);
    // セッションを再取得
    handleRefreshSession();
  };

  // セッション再取得ハンドラ（Result型対応）
  const handleRefreshSession = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const refreshedSession = await getSession();
      if (!refreshedSession) {
        const authError: AppError = {
          type: "UNAUTHORIZED",
          message: "セッションの取得に失敗しました。再ログインしてください。",
        };
        setError(authError);
        showAppErrorNotification(authError, "認証エラー");
      }
    } catch {
      const appError: AppError = {
        type: "NETWORK_ERROR",
        message: "セッションの更新中にエラーが発生しました",
      };
      setError(appError);
      showAppErrorNotification(appError, "セッションエラー");
    } finally {
      setIsLoading(false);
    }
  };

  // ローディング中の表示
  if (status === "loading" || isLoading) {
    return (
      <div className="flex min-h-screen bg-stone-50 flex-col items-center justify-center p-4">
        <div className="w-full max-w-3xl">
          <div className="bg-white rounded-xl p-8 text-center shadow-sm border border-stone-100">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-teal-700 mx-auto mb-4"></div>
            <p className="text-stone-600">設定を読み込み中...</p>
          </div>
        </div>
      </div>
    );
  }

  // 認証エラーの表示
  if (status === "unauthenticated") {
    const authError: AppError = {
      type: "UNAUTHORIZED",
      message: "設定ページにアクセスするにはログインが必要です",
    };

    return (
      <div className="flex min-h-screen bg-stone-50 flex-col items-center justify-center p-4">
        <div className="w-full max-w-3xl">
          <ErrorDisplay
            error={authError}
            onRetry={() => (window.location.href = "/auth/login")}
            retryLabel="ログインページへ"
            className="bg-white rounded-xl shadow-sm border border-stone-100"
          />
        </div>
      </div>
    );
  }

  const user = session?.user;

  return (
    <div className="flex min-h-screen bg-stone-50 flex-col items-center p-4">
      <div className="w-full max-w-3xl space-y-6">
        <PageHeader />

        {/* エラー表示（Result型対応） */}
        {error && (
          <ErrorDisplay error={error} onRetry={handleRetry} className="mb-4" />
        )}

        <div className="flex flex-col sm:flex-row gap-6">
          <ProfileCard user={user} />

          <Card className="flex-1 p-4">
            <Tabs defaultValue="profile" className="w-full">
              <TabsList className="grid w-full grid-cols-5 bg-stone-100">
                <TabsTrigger value="profile" className="text-xs sm:text-sm">
                  <User className="h-4 w-4 mr-1" />
                  <span className="hidden sm:inline">プロフィール</span>
                </TabsTrigger>
                <TabsTrigger
                  value="notifications"
                  className="text-xs sm:text-sm"
                >
                  <Bell className="h-4 w-4 mr-1" />
                  <span className="hidden sm:inline">通知</span>
                </TabsTrigger>
                <TabsTrigger value="payment" className="text-xs sm:text-sm">
                  <CreditCard className="h-4 w-4 mr-1" />
                  <span className="hidden sm:inline">支払い</span>
                </TabsTrigger>
                <TabsTrigger value="security" className="text-xs sm:text-sm">
                  <Shield className="h-4 w-4 mr-1" />
                  <span className="hidden sm:inline">セキュリティ</span>
                </TabsTrigger>
                <TabsTrigger value="eco" className="text-xs sm:text-sm">
                  <Leaf className="h-4 w-4 mr-1" />
                  <span className="hidden sm:inline">エコ設定</span>
                </TabsTrigger>
              </TabsList>

              <TabsContent value="profile" className="mt-4">
                <ProfileTab user={user} />
              </TabsContent>
              <TabsContent value="notifications" className="mt-4">
                <NotificationsTab />
              </TabsContent>
              <TabsContent value="payment" className="mt-4">
                <PaymentTab />
              </TabsContent>
              <TabsContent value="security" className="mt-4">
                <SecurityTab />
              </TabsContent>
              <TabsContent value="eco" className="mt-4">
                <EcoTab />
              </TabsContent>
            </Tabs>
          </Card>
        </div>

        <p className="text-xs text-center text-stone-500 mt-6">
          お客様の購入ごとに、売上の1%を環境保護団体に寄付しています
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/components/LoginForm/LoginForm.tsx">
import Link from "next/link";
import { useRouter } from "next/navigation";
import { AuthForm } from "../AuthForm/LegacyAuthForm";
import { AuthField } from "../AuthField/LegacyAuthField";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Leaf, Mail, Lock } from "lucide-react";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateLoginForm } from "@/features/auth/utils/validation";
import { loginUser } from "@/services/api/user";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Result, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

export function LoginForm() {
  const router = useRouter();

  // ログイン処理
  const handleLoginSubmit = async (
    values: Record<string, string>,
  ): Promise<Result<void, AppError>> => {
    try {
      const result = await loginUser({
        email: values.email,
        password: values.password,
      });

      return result.map(() => {
        // 成功時の処理
        router.push("/");
        router.refresh();
      });
    } catch (error) {
      return err({
        type: "SERVER_ERROR",
        message:
          error instanceof Error ? error.message : "ログインに失敗しました",
        statusCode: 500,
      });
    }
  };

  const { values, fieldErrors, isLoading, error, handleChange, handleSubmit } =
    useAuthForm({
      initialValues: {
        email: "",
        password: "",
      },
      validateForm: validateLoginForm,
      onSubmit: handleLoginSubmit,
    });

  const [rememberMe, setRememberMe] = useState(false);

  return (
    <AuthForm
      onSubmit={handleSubmit}
      isLoading={isLoading}
      error={error?.message}
      submitLabel="ログイン"
      loadingLabel="ログイン中..."
      footer={
        <>
          <div className="text-center text-sm text-stone-600">
            アカウントをお持ちでない方は
            <Link
              href="/auth/register"
              className="text-teal-700 hover:underline ml-1 font-medium"
            >
              新規登録
            </Link>
          </div>

          <div className="flex items-center py-2">
            <div className="flex-grow h-px bg-stone-200"></div>
            <span className="px-2 text-xs text-stone-500">または</span>
            <div className="flex-grow h-px bg-stone-200"></div>
          </div>

          <Button
            type="button"
            variant="outline"
            className="w-full border-stone-300 h-10 px-4 py-2 hover:bg-stone-50 transition-all shadow-xs"
          >
            <svg
              className="h-5 w-5 mr-2"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                fill="#4285F4"
              />
              <path
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                fill="#34A853"
              />
              <path
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                fill="#FBBC05"
              />
              <path
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                fill="#EA4335"
              />
            </svg>
            Googleでログイン
          </Button>

          <div className="flex items-center pt-3 mt-3 p-3 bg-teal-50 border border-teal-200 rounded-md">
            <Leaf className="h-5 w-5 text-teal-700 mr-2.5 flex-shrink-0" />
            <p className="text-xs text-teal-800">
              環境に優しいサーバーで運用され、取引ごとに環境保護活動に寄付が行われます。
            </p>
          </div>
        </>
      }
    >
      <AuthField
        id="email"
        name="email"
        label="メールアドレス"
        type="email"
        placeholder="your@email.com"
        value={values.email}
        onChange={handleChange}
        disabled={isLoading}
        required
        error={fieldErrors.email?.message}
        icon={<Mail className="h-4 w-4" />}
      />

      <AuthField
        id="password"
        name="password"
        label="パスワード"
        type="password"
        placeholder="********"
        value={values.password}
        onChange={handleChange}
        disabled={isLoading}
        required
        error={fieldErrors.password?.message}
        icon={<Lock className="h-4 w-4" />}
        action={
          <Link
            href="/auth/forgot-password"
            className="text-xs text-teal-700 hover:underline hover:text-teal-800 font-medium"
          >
            パスワードをお忘れですか？
          </Link>
        }
      />

      <div className="flex items-center space-x-2 text-left mt-1">
        <Checkbox
          id="remember"
          checked={rememberMe}
          onCheckedChange={(checked) => setRememberMe(checked as boolean)}
          disabled={isLoading}
          className="text-teal-700 border-stone-400 data-[state=checked]:bg-teal-700"
        />
        <Label
          htmlFor="remember"
          className="text-sm text-stone-700 cursor-pointer"
        >
          ログイン状態を保持する
        </Label>
      </div>
    </AuthForm>
  );
}
</file>

<file path="src/features/auth/index.ts">
/**
 * 認証機能の公開API
 */

// 型定義のエクスポート
export * from "./types/auth";

// コンポーネントのエクスポート
export { AuthField } from "./components/AuthField";
export type { ExtendedAuthFieldProps } from "./components/AuthField";
export { AuthForm } from "./components/AuthForm";
export { LoginForm } from "./components/LoginForm";
export { LogoutButton } from "./components/LogoutButton";

// フックのエクスポート
export { useAuthForm } from "./hooks/useAuthForm";

// ユーティリティのエクスポート（将来追加予定）
// export { validateEmail } from "./utils/validators";
// export { getAuthRedirectPath } from "./utils/auth-redirects";

// ストアのエクスポート（将来追加予定）
// export { useAuthStore } from "./store/auth.slice";
// export type { AuthState } from "./store/auth.slice";
</file>

<file path="src/features/balance/components/BalanceCard/BalanceCardContainer.tsx">
"use client";

import { useBalanceStore } from "../../store/balance.slice";
import { formatCurrency } from "@/shared/utils/formats";
import { BalanceCardView } from "./BalanceCardView";
import { BalanceCardContainerProps } from "../../types/balance";

/**
 * 残高データを取得・加工し、表示コンポーネントに渡すコンテナコンポーネント
 *
 * @param className オプションのCSSクラス
 */
export function BalanceCardContainer({} /* className */ : BalanceCardContainerProps) {
  // Zustandストアからデータと関数を取得
  const getTotalBalance = useBalanceStore((state) => state.getTotalBalance);
  const campaignBalances = useBalanceStore((state) => state.campaignBalances);

  // 残高計算とデータ整形ロジック
  const campaignTotal = campaignBalances.reduce(
    (sum, cb) => sum + cb.amount,
    0,
  );

  const totalBalanceResult = getTotalBalance();
  const totalBalance = totalBalanceResult.isOk() ? totalBalanceResult.value : 0;
  const formattedBalance = formatCurrency(totalBalance);

  // 期限が近い（7日以内）キャンペーン残高があるかチェック
  const hasExpiringBalance = campaignBalances.some((cb) => cb.daysLeft <= 7);

  // 加工済みのデータをプレゼンテーションコンポーネントに渡す
  return (
    <BalanceCardView
      formattedBalance={formattedBalance}
      campaignTotal={campaignTotal}
      hasExpiringBalance={hasExpiringBalance}
    />
  );
}
</file>

<file path="src/features/balance/components/BalanceCard/BalanceCardView.tsx">
"use client";

import React from "react";
import Link from "next/link";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { QrCode, Send, Users, CreditCard, Plus } from "lucide-react";
import { formatCurrency } from "@/shared/utils/formats";
import { BalanceCardViewProps } from "../../types/balance";

/**
 * 残高表示と操作UIを提供するカードコンポーネント
 *
 * プレゼンテーションコンポーネントとして、残高表示とUIレイアウトを担当
 */
export const BalanceCardView = React.memo(
  ({
    formattedBalance,
    campaignTotal,
    hasExpiringBalance,
  }: BalanceCardViewProps) => {
    return (
      <Card className="border border-stone-100 shadow-sm hover:shadow-md bg-white overflow-hidden rounded-lg transition-shadow duration-200">
        <div className="bg-gradient-to-r from-teal-600 to-teal-700 p-6 text-white">
          <p className="text-xs opacity-90 font-medium uppercase tracking-wider">
            現在の残高
          </p>
          <div className="flex justify-between items-end mt-2">
            <div>
              <h2 className="text-3xl font-bold tracking-tight">
                {formattedBalance}
              </h2>
              {campaignTotal > 0 && (
                <div className="mt-2 flex items-center">
                  <div className="bg-white/20 backdrop-blur-sm rounded-full px-3 py-1">
                    <p className="text-xs font-medium">
                      キャンペーン残高:{" "}
                      {formatCurrency(campaignTotal, { withSymbol: false })}
                    </p>
                  </div>
                  {hasExpiringBalance && (
                    <span className="ml-2 text-xs bg-amber-500 text-white rounded-full px-2 py-0.5 font-medium">
                      期限間近
                    </span>
                  )}
                </div>
              )}
            </div>
            <Link href="/charge">
              <Button
                variant="outline"
                size="sm"
                className="bg-white/10 backdrop-blur-sm border-white/30 text-white hover:bg-white/20 rounded-lg px-4 py-2 h-9 transition-all duration-200"
              >
                <Plus className="h-4 w-4 mr-1" />
                チャージ
              </Button>
            </Link>
          </div>
        </div>
        <CardContent className="p-0">
          <div className="grid grid-cols-4 divide-x divide-stone-100">
            <Link href="/qrcode" className="w-full">
              <Button
                variant="ghost"
                className="flex flex-col items-center py-5 rounded-none h-auto w-full hover:bg-teal-50 transition-colors duration-200 group"
              >
                <QrCode className="h-6 w-6 mb-1.5 text-teal-600 group-hover:scale-110 transition-transform duration-200" />
                <span className="text-xs text-stone-700 font-medium">
                  支払う
                </span>
              </Button>
            </Link>
            <Link href="/transfer" className="w-full">
              <Button
                variant="ghost"
                className="flex flex-col items-center py-5 rounded-none h-auto w-full hover:bg-teal-50 transition-colors duration-200 group"
              >
                <Send className="h-6 w-6 mb-1.5 text-teal-600 group-hover:scale-110 transition-transform duration-200" />
                <span className="text-xs text-stone-700 font-medium">送金</span>
              </Button>
            </Link>
            <Link href="/transfer?tab=split" className="w-full">
              <Button
                variant="ghost"
                className="flex flex-col items-center py-5 rounded-none h-auto w-full hover:bg-teal-50 transition-colors duration-200 group"
              >
                <Users className="h-6 w-6 mb-1.5 text-teal-600 group-hover:scale-110 transition-transform duration-200" />
                <span className="text-xs text-stone-700 font-medium">
                  割り勘
                </span>
              </Button>
            </Link>
            <Link href="/payment" className="w-full">
              <Button
                variant="ghost"
                className="flex flex-col items-center py-5 rounded-none h-auto w-full hover:bg-teal-50 transition-colors duration-200 group"
              >
                <CreditCard className="h-6 w-6 mb-1.5 text-teal-600 group-hover:scale-110 transition-transform duration-200" />
                <span className="text-xs text-stone-700 font-medium">決済</span>
              </Button>
            </Link>
          </div>
        </CardContent>
      </Card>
    );
  },
);

BalanceCardView.displayName = "BalanceCardView";
</file>

<file path="src/features/balance/store/balance.slice.ts">
/**
 * 残高情報を管理するストア（Result型対応）
 */

import { create } from "zustand";
import { Result, ResultAsync, ok, err } from "neverthrow";
import { CampaignBalance } from "../types/balance";
import { BusinessError, AppError } from "../../../shared/types/errors";
import { fetchBalance } from "../../../services/api/balance";
import {
  calculateTotalBalance,
  validateChargeAmount,
  processCharge,
} from "../../../lib/business/balance";

/**
 * 残高ストアの状態型（Result型対応）
 */
export interface BalanceState {
  /** 通常残高 */
  regularBalance: number;

  /** キャンペーン残高のリスト */
  campaignBalances: Array<CampaignBalance & { daysLeft: number }>;

  /** ローディング状態 */
  isLoading: boolean;

  /** エラー状態 */
  error: AppError | null;

  /** 合計残高を取得（Result型対応） */
  getTotalBalance: () => Result<number, BusinessError>;

  /** 残高を更新 */
  updateBalance: (newRegularBalance: number) => void;

  /** 通常残高から引く */
  subtractFromRegularBalance: (amount: number) => void;

  /** キャンペーン残高を追加 */
  addCampaignBalance: (
    campaign: CampaignBalance,
  ) => Result<void, BusinessError>;

  /** キャンペーン残高を更新 */
  updateCampaignBalance: (
    campaignId: string,
    amount: number,
  ) => Result<void, BusinessError>;

  /** 残高を非同期で取得（API統合） */
  fetchBalanceAsync: (userId?: string) => ResultAsync<void, AppError>;

  /** チャージ処理（API統合） */
  processChargeAsync: (
    amount: number,
    paymentMethodId:
      | "bank_transfer"
      | "credit_card"
      | "convenience_store"
      | "atm",
  ) => ResultAsync<void, AppError>;

  /** エラーをクリア */
  clearError: () => void;

  /** ローディング状態を設定 */
  setLoading: (loading: boolean) => void;
}

/**
 * 残高ストア（Result型対応）
 */
export const useBalanceStore = create<BalanceState>((set, get) => ({
  // 初期値
  regularBalance: 15000,
  campaignBalances: [
    {
      campaignId: "ref-10-2023",
      campaignName: "紹介特典",
      amount: 1000,
      expiryDate: "2023-12-31",
      daysRemaining: 30,
      daysLeft: 30,
    },
    {
      campaignId: "eco-5-2023",
      campaignName: "エコ活動ボーナス",
      amount: 500,
      expiryDate: "2023-11-15",
      daysRemaining: 5,
      daysLeft: 5,
    },
  ],
  isLoading: false,
  error: null,

  // 合計残高を計算（Result型対応）
  getTotalBalance: () => {
    const { regularBalance, campaignBalances } = get();

    // ビジネスロジック関数を使用
    const balanceData = campaignBalances.map((cb) => ({
      id: cb.campaignId === "ref-10-2023" ? 1 : 2,
      amount: cb.amount,
      label: cb.campaignName,
      expiryDate: cb.expiryDate,
      daysLeft: cb.daysLeft,
    }));

    const result = calculateTotalBalance(regularBalance, balanceData);
    if (result.isErr()) {
      return err(result.error);
    }

    return ok(result.value.totalBalance);
  },

  // 通常残高を更新
  updateBalance: (newRegularBalance) => {
    set({ regularBalance: newRegularBalance, error: null });
  },

  // 通常残高から引く
  subtractFromRegularBalance: (amount) => {
    set((state) => ({
      regularBalance: Math.max(0, state.regularBalance - amount),
      error: null,
    }));
  },

  // キャンペーン残高を追加（Result型対応）
  addCampaignBalance: (campaign) => {
    try {
      if (!campaign.campaignId || campaign.amount < 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "無効なキャンペーン残高です",
          reason: `campaignId: ${campaign.campaignId}, amount: ${campaign.amount}`,
          paymentId: undefined,
        });
      }

      set((state) => ({
        campaignBalances: [
          ...state.campaignBalances,
          {
            ...campaign,
            daysLeft: campaign.daysRemaining,
          },
        ],
        error: null,
      }));

      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "キャンペーン残高の追加に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // キャンペーン残高を更新（Result型対応）
  updateCampaignBalance: (campaignId, amount) => {
    try {
      if (!campaignId || amount < 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "無効なキャンペーン残高更新です",
          reason: `campaignId: ${campaignId}, amount: ${amount}`,
          paymentId: undefined,
        });
      }

      const { campaignBalances } = get();
      const campaign = campaignBalances.find(
        (cb) => cb.campaignId === campaignId,
      );

      if (!campaign) {
        return err({
          type: "PAYMENT_FAILED",
          message: "キャンペーンが見つかりません",
          reason: `campaignId: ${campaignId}`,
          paymentId: undefined,
        });
      }

      set((state) => ({
        campaignBalances: state.campaignBalances.map((campaign) =>
          campaign.campaignId === campaignId
            ? { ...campaign, amount }
            : campaign,
        ),
        error: null,
      }));

      return ok(undefined);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "キャンペーン残高の更新に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 残高を非同期で取得（API統合）
  fetchBalanceAsync: (userId?: string) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        const balanceResult = await fetchBalance(userId);

        if (balanceResult.isErr()) {
          const error: AppError = balanceResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        const balanceData = balanceResult.value;
        set({
          regularBalance: balanceData.currentBalance,
          isLoading: false,
          error: null,
        });
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // チャージ処理（API統合）
  processChargeAsync: (
    amount: number,
    paymentMethodId:
      | "bank_transfer"
      | "credit_card"
      | "convenience_store"
      | "atm",
  ) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        // バリデーション
        const amountValidation = validateChargeAmount(amount);
        if (amountValidation.isErr()) {
          const error: AppError = amountValidation.error;
          set({ isLoading: false, error });
          throw error;
        }

        // チャージ処理
        const chargeResult = await processCharge({
          amount,
          paymentMethod: paymentMethodId,
          description: "チャージ",
        });

        if (chargeResult.isErr()) {
          const error: AppError = chargeResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        // 残高を更新
        set((state) => ({
          regularBalance: state.regularBalance + amount,
          isLoading: false,
          error: null,
        }));
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // エラーをクリア
  clearError: () => {
    set({ error: null });
  },

  // ローディング状態を設定
  setLoading: (loading: boolean) => {
    set({ isLoading: loading });
  },
}));
</file>

<file path="src/features/charge/components/ChargeInput/AmountInput.tsx">
"use client";

import React from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Wallet } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";

/**
 * 金額入力フォームのプロパティ（AppError型対応）
 */
export interface AmountInputProps {
  /** チャージ金額 */
  amount: string;
  /** チャージ金額更新関数 */
  setAmount: (value: string) => void;
  /** 金額選択ハンドラー */
  handleSelectAmount: (value: string) => void;
  /** エラー状態 */
  error: AppError | null;
}

/**
 * 金額入力フォームを表示するプレゼンテーションコンポーネント
 *
 * @param amount チャージ金額
 * @param setAmount チャージ金額更新関数
 * @param handleSelectAmount 金額選択ハンドラー
 * @param error エラーメッセージ
 */
export const AmountInput = React.memo(
  ({ amount, setAmount, handleSelectAmount, error }: AmountInputProps) => {
    const quickAmounts = [
      { value: "1000", label: "¥1,000" },
      { value: "3000", label: "¥3,000" },
      { value: "5000", label: "¥5,000" },
      { value: "10000", label: "¥10,000" },
    ];

    return (
      <div className="space-y-6">
        {/* 金額入力フィールド */}
        <div className="space-y-3">
          <Label
            htmlFor="amount"
            className="text-sm font-semibold text-stone-700 flex items-center"
          >
            <Wallet className="h-4 w-4 mr-2 text-teal-600" />
            チャージ金額
          </Label>
          <div className="relative">
            <span className="absolute left-4 top-1/2 transform -translate-y-1/2 text-xl text-stone-600">
              ¥
            </span>
            <Input
              id="amount"
              type="number"
              placeholder="5,000"
              className="pl-10 pr-12 h-14 text-xl font-medium border-stone-200 focus:border-teal-500 focus:ring-teal-500 transition-colors duration-200 text-center"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
            />
            <span className="absolute right-4 top-1/2 transform -translate-y-1/2 text-sm text-stone-600">
              円
            </span>
          </div>
        </div>

        {/* クイック金額選択 */}
        <div className="space-y-2">
          <p className="text-sm font-medium text-stone-600">クイック選択</p>
          <div className="grid grid-cols-2 gap-3">
            {quickAmounts.map((quick) => (
              <Button
                key={quick.value}
                variant="outline"
                className={`
                  h-12 font-medium border-stone-200 hover:border-teal-300 hover:bg-teal-50 
                  transition-all duration-200
                  ${amount === quick.value ? "bg-teal-50 border-teal-300 text-teal-700" : ""}
                `}
                onClick={() => handleSelectAmount(quick.value)}
              >
                {quick.label}
              </Button>
            ))}
          </div>
        </div>

        {/* エラー表示 */}
        {error && <ErrorDisplay error={error} />}
      </div>
    );
  },
);

AmountInput.displayName = "AmountInput";
</file>

<file path="src/features/charge/components/ChargeInput/ChargeInputContainer.tsx">
"use client";

import { useState, useMemo } from "react";
import {
  validateAmountResult,
  validateEmailResult,
} from "@/lib/utils/validation";
import { validateChargeAmount } from "@/lib/business/balance";
import { chargeBalance, ChargeRequest } from "@/services/api/balance";
import { AppError } from "@/shared/types/errors";
import { ChargeInputForm } from "./ChargeInputForm";

/**
 * チャージ入力コンテナのプロパティ
 */
export interface ChargeInputContainerProps {
  /** 確認ステップに進む際のコールバック */
  onProceedToConfirm?: (amount: number) => void;
}

/**
 * チャージ入力の状態管理とロジックを担当するコンテナコンポーネント
 *
 * @param onProceedToConfirm 確認ステップに進む際のコールバック
 */
export function ChargeInputContainer({
  onProceedToConfirm,
}: ChargeInputContainerProps) {
  // フォーム状態
  const [amount, setAmount] = useState<string>("");
  const [email, setEmail] = useState<string>("");
  const [paymentMethod, setPaymentMethod] = useState<"credit-card" | "bank">(
    "credit-card",
  );
  const [emailSent, setEmailSent] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<AppError | null>(null);
  const [transferCode, setTransferCode] = useState<string>("");
  const [processingVerification, setProcessingVerification] =
    useState<boolean>(false);

  // バリデーション（Result型対応）
  const amountValidationResult = useMemo(
    () => validateAmountResult(amount, 1, 1000000),
    [amount],
  );
  const emailValidationResult = useMemo(
    () => validateEmailResult(email),
    [email],
  );

  const isValidAmount = amountValidationResult.isOk();
  const validEmail = emailValidationResult.isOk();

  // 金額クイック選択ハンドラー
  const handleSelectAmount = (value: string) => {
    setAmount(value);
    setError(null);
  };

  // フォーム送信ハンドラー（Result型対応）
  const handleProceedToConfirm = () => {
    console.log("handleProceedToConfirm called with amount:", amount);

    // Result型バリデーション
    if (amountValidationResult.isErr()) {
      const validationError = amountValidationResult.error;
      setError(validationError);
      console.log("Amount validation failed:", validationError);
      return;
    }

    const validatedAmount = amountValidationResult.value;

    // ビジネスロジック層でのバリデーション
    const chargeValidationResult = validateChargeAmount(validatedAmount);
    if (chargeValidationResult.isErr()) {
      const businessError = chargeValidationResult.error;
      setError(businessError);
      console.log("Charge validation failed:", businessError);
      return;
    }

    // 入力が有効であれば次のステップに進む
    if (onProceedToConfirm) {
      console.log(
        "Calling onProceedToConfirm with validatedAmount:",
        validatedAmount,
      );
      onProceedToConfirm(validatedAmount);
    } else {
      console.log("onProceedToConfirm is not defined");
    }
  };

  // 銀行振込メール送信処理（Result型対応）
  const handleSendBankTransferEmail = async () => {
    // メールアドレスのバリデーション
    if (emailValidationResult.isErr()) {
      const validationError = emailValidationResult.error;
      setError(validationError);
      return;
    }

    // 金額のバリデーション
    if (amountValidationResult.isErr()) {
      const validationError = amountValidationResult.error;
      setError(validationError);
      return;
    }

    const validatedEmail = emailValidationResult.value;
    const validatedAmount = amountValidationResult.value;

    // ビジネスロジック層でのチャージバリデーション
    const chargeValidationResult = validateChargeAmount(validatedAmount);
    if (chargeValidationResult.isErr()) {
      const businessError = chargeValidationResult.error;
      setError(businessError);
      return;
    }

    setIsLoading(true);
    setError(null);

    // API呼び出し（Result型対応）
    const chargeRequest: ChargeRequest = {
      amount: validatedAmount,
      paymentMethod: "bank_transfer",
      paymentDetails: {
        email: validatedEmail,
        requestType: "bank_transfer_instructions",
      },
    };

    const result = await chargeBalance(chargeRequest);

    result.match(
      (response) => {
        // 成功時の処理
        setTransferCode(response.transactionId);
        setEmailSent(true);
        console.log("Bank transfer request successful:", response);
      },
      (apiError) => {
        // エラー時の処理
        setError(apiError);
        console.error("Bank transfer request failed:", apiError);
      },
    );

    setIsLoading(false);
  };

  // 銀行振込通知処理（Result型対応）
  const handleNotifyBankTransfer = async () => {
    if (!transferCode) {
      setError({
        type: "TRANSFER_CODE_NOT_FOUND",
        message: "振込コードが見つかりません。再度メール送信を行ってください。",
      });
      return;
    }

    setProcessingVerification(true);
    setError(null);

    // チャージステータス確認API呼び出し（Result型対応）
    const result = await chargeBalance({
      amount: amountValidationResult.isOk() ? amountValidationResult.value : 0,
      paymentMethod: "bank_transfer",
      paymentDetails: {
        transactionId: transferCode,
        requestType: "verification_request",
      },
    });

    result.match(
      (response) => {
        // 成功時の処理
        if (response.status === "completed") {
          setError({
            type: "TRANSFER_COMPLETED",
            message: "振込が確認されました。チャージが完了しました。",
          });
        } else if (response.status === "pending") {
          setError({
            type: "TRANSFER_PENDING",
            message:
              "振込確認リクエストを受け付けました。通常1営業日以内に確認します。",
          });
        } else {
          setError({
            type: "TRANSFER_VERIFICATION_FAILED",
            message: "振込の確認ができませんでした。もう一度お試しください。",
          });
        }
        console.log("Bank transfer verification response:", response);
      },
      (apiError) => {
        // エラー時の処理
        setError(apiError);
        console.error("Bank transfer verification failed:", apiError);
      },
    );

    setProcessingVerification(false);
  };

  return (
    <ChargeInputForm
      amount={amount}
      setAmount={setAmount}
      email={email}
      setEmail={setEmail}
      paymentMethod={paymentMethod}
      setPaymentMethod={setPaymentMethod}
      emailSent={emailSent}
      error={error}
      handleSelectAmount={handleSelectAmount}
      handleProceedToConfirm={handleProceedToConfirm}
      handleSendBankTransferEmail={handleSendBankTransferEmail}
      transferCode={transferCode}
      setTransferCode={setTransferCode}
      processingVerification={processingVerification}
      handleNotifyBankTransfer={handleNotifyBankTransfer}
      isValidAmount={isValidAmount}
      isEmailValid={validEmail}
      isLoading={isLoading}
    />
  );
}
</file>

<file path="src/features/charge/components/ChargeInput/ChargeInputForm.tsx">
"use client";

import React from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Leaf, CreditCard, Building } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { AmountInput } from "./AmountInput";
import { BankTransferInput } from "./BankTransferInput";

/**
 * チャージ入力フォームのプロパティ（AppError型対応）
 */
export interface ChargeInputFormProps {
  /** チャージ金額 */
  amount: string;
  /** チャージ金額更新関数 */
  setAmount: (value: string) => void;
  /** メールアドレス */
  email: string;
  /** メールアドレス更新関数 */
  setEmail: (value: string) => void;
  /** 支払い方法 */
  paymentMethod: "credit-card" | "bank";
  /** 支払い方法更新関数 */
  setPaymentMethod: (value: "credit-card" | "bank") => void;
  /** メール送信済みフラグ */
  emailSent: boolean;
  /** エラー状態 */
  error: AppError | null;
  /** 金額選択ハンドラー */
  handleSelectAmount: (value: string) => void;
  /** 確認ステップ遷移ハンドラー */
  handleProceedToConfirm: () => void;
  /** 銀行振込メール送信ハンドラー */
  handleSendBankTransferEmail: () => void;
  /** 振込コード */
  transferCode: string;
  /** 振込コード更新関数 */
  setTransferCode: (value: string) => void;
  /** 振込確認処理中フラグ */
  processingVerification: boolean;
  /** 振込通知ハンドラー */
  handleNotifyBankTransfer: () => void;
  /** 金額の有効性 */
  isValidAmount: boolean;
  /** メールアドレスの有効性 */
  isEmailValid: boolean;
  /** ローディング状態 */
  isLoading: boolean;
}

/**
 * チャージ入力フォームのコンポーネント
 *
 * プレゼンテーションコンポーネントとして、フォームのUIを担当する。
 */
export const ChargeInputForm = React.memo(
  ({
    amount,
    setAmount,
    email,
    setEmail,
    paymentMethod,
    setPaymentMethod,
    emailSent,
    error,
    handleSelectAmount,
    handleProceedToConfirm,
    handleSendBankTransferEmail,
    transferCode,
    setTransferCode,
    processingVerification,
    handleNotifyBankTransfer,
    isValidAmount,
    isEmailValid,
    isLoading,
  }: ChargeInputFormProps) => {
    return (
      <div className="space-y-4">
        {/* 環境貢献メッセージ */}
        <Alert className="bg-teal-50 border-teal-100">
          <Leaf className="h-4 w-4 text-teal-600" />
          <AlertDescription className="text-sm text-teal-800 ml-2">
            ペーパーレス決済で、取引ごとに環境保護団体への寄付が行われます
          </AlertDescription>
        </Alert>

        {/* 支払い方法タブ */}
        <Card className="border border-stone-100 shadow-sm">
          <Tabs
            defaultValue={paymentMethod}
            className="w-full"
            onValueChange={(value) => {
              if (!emailSent) {
                if (value === "credit-card" || value === "bank") {
                  setPaymentMethod(value as "credit-card" | "bank");
                }
              }
            }}
          >
            <TabsList className="grid w-full grid-cols-2 bg-stone-50 p-1">
              <TabsTrigger
                value="credit-card"
                className="text-sm font-medium data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm"
                disabled={emailSent}
              >
                <CreditCard className="h-4 w-4 mr-2" />
                クレジットカード
              </TabsTrigger>
              <TabsTrigger
                value="bank"
                className="text-sm font-medium data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm"
                disabled={emailSent}
              >
                <Building className="h-4 w-4 mr-2" />
                銀行振込
              </TabsTrigger>
            </TabsList>

            {/* クレジットカード入力タブ */}
            <TabsContent value="credit-card" className="px-6 py-4">
              <AmountInput
                amount={amount}
                setAmount={setAmount}
                handleSelectAmount={handleSelectAmount}
                error={error}
              />

              {/* 次へ進むボタン */}
              <Button
                className="w-full mt-6 bg-teal-600 hover:bg-teal-700 text-white h-12 text-base font-medium shadow-sm transition-all duration-200"
                onClick={handleProceedToConfirm}
                disabled={!isValidAmount || !amount}
              >
                確認画面へ進む
                {amount && (
                  <span className="ml-2 text-sm font-normal">
                    (¥{Number(amount).toLocaleString()})
                  </span>
                )}
              </Button>
            </TabsContent>

            {/* 銀行振込タブ */}
            <TabsContent value="bank" className="px-6 py-4">
              <BankTransferInput
                email={email}
                setEmail={setEmail}
                amount={amount}
                setAmount={setAmount}
                emailSent={emailSent}
                isLoading={isLoading}
                isValidEmail={isEmailValid}
                isValidAmount={isValidAmount}
                error={error}
                handleSelectAmount={handleSelectAmount}
                handleSendBankTransferEmail={handleSendBankTransferEmail}
                transferCode={transferCode}
                setTransferCode={setTransferCode}
                processingVerification={processingVerification}
                handleNotifyBankTransfer={handleNotifyBankTransfer}
              />
            </TabsContent>
          </Tabs>
        </Card>

        {/* 環境貢献額の自動計算表示 */}
        {amount && Number(amount) > 0 && (
          <Card className="border border-stone-100 shadow-sm p-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="bg-teal-100 rounded-full p-2 mr-3">
                  <Leaf className="h-5 w-5 text-teal-600" />
                </div>
                <div>
                  <p className="text-sm font-medium text-stone-800">
                    環境保護団体への寄付額
                  </p>
                  <p className="text-xs text-stone-600">
                    チャージ額の1%が自動的に寄付されます
                  </p>
                </div>
              </div>
              <p className="text-lg font-semibold text-teal-700">
                ¥{Math.floor(Number(amount) * 0.01).toLocaleString()}
              </p>
            </div>
          </Card>
        )}
      </div>
    );
  },
);

ChargeInputForm.displayName = "ChargeInputForm";
</file>

<file path="src/features/donation/components/DonateInput/DonateInputForm.tsx">
"use client";

import React from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { formatCurrency } from "@/shared/utils/formats";
import { Leaf } from "lucide-react";
import { DonationProject } from "../../types/donation";
import {
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { ProjectInfo } from "./ProjectInfo";
import { AmountSelector } from "./AmountSelector";

interface DonateInputFormProps {
  project: DonationProject;
  amount: string;
  setAmount: (value: string) => void;
  error: string | null;
  handleSelectAmount: (value: string) => void;
  handleProceedToConfirm: () => void;
  balance: number;
  isLoading?: boolean;
}

// プレゼンテーションコンポーネント: フォームUIのみを担当
export const DonateInputForm = React.memo(
  ({
    project,
    amount,
    setAmount,
    error,
    handleSelectAmount,
    handleProceedToConfirm,
    balance,
    isLoading = false,
  }: DonateInputFormProps) => {
    return (
      <>
        <CardHeader className="pb-2">
          <CardTitle className="text-xl text-teal-800">
            {project.title}
          </CardTitle>
          <CardDescription>
            このプロジェクトへの寄付で環境保全に貢献できます
          </CardDescription>
        </CardHeader>

        <CardContent className="space-y-6">
          {/* プロジェクト情報 */}
          <ProjectInfo project={project} />

          {/* 金額入力部分 */}
          <div className="space-y-2">
            <Label
              htmlFor="amount"
              className="text-sm font-medium text-stone-800"
            >
              寄付金額
            </Label>
            <div className="flex items-center space-x-2">
              <Input
                id="amount"
                type="number"
                placeholder="1,000"
                className="border-stone-300"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
              />
              <span className="text-sm text-stone-600">円</span>
            </div>
            <p className="text-xs text-stone-500">
              残高: {formatCurrency(balance)}
            </p>
          </div>

          {/* 金額クイック選択 */}
          <AmountSelector onSelectAmount={handleSelectAmount} />

          {/* 環境情報説明 */}
          <div className="bg-teal-50 p-3 rounded-md border border-teal-100">
            <div className="flex items-start">
              <Leaf className="h-4 w-4 text-teal-600 mt-0.5 mr-2" />
              <div className="text-xs text-teal-700">
                あなたの寄付は、直接環境保全活動に使われます。寄付によって得られる具体的な環境貢献効果は寄付完了後に確認できます。
              </div>
            </div>
          </div>

          {/* エラーメッセージ */}
          {error && (
            <div className="text-red-600 text-sm bg-red-50 p-2 rounded-md">
              {error}
            </div>
          )}

          {/* 送信ボタン */}
          <Button
            className="w-full bg-teal-700 hover:bg-teal-800 text-white disabled:opacity-50 disabled:cursor-not-allowed"
            onClick={handleProceedToConfirm}
            disabled={isLoading}
          >
            {isLoading ? (
              <div className="flex items-center">
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                処理中...
              </div>
            ) : (
              "次へ進む"
            )}
          </Button>
        </CardContent>
      </>
    );
  },
);

DonateInputForm.displayName = "DonateInputForm";
</file>

<file path="src/features/eco-impact/store/eco-impact.slice.ts">
import { StateCreator } from "zustand";
import { create } from "zustand";
import { Result, ok, err } from "neverthrow";
import { ecoImpactData } from "../data/eco-impact-data";
import { EcoRank, ContributionParams } from "../types/eco-impact";
import { BusinessError, AppError } from "../../../shared/types/errors";
import {
  calculateContribution,
  calculateEcoProgress,
  getEcoRankFromDonation,
} from "../utils/calculations";

/**
 * EcoImpact スライスの型定義（Result型対応）
 */
export interface EcoImpactSlice {
  // 環境貢献データ
  forestArea: number;
  waterSaved: number;
  co2Reduction: number;
  progressPercent: number;
  totalDonation: number;
  monthlyDonation: number;

  // 目標値
  targetForestArea: number;
  targetWaterSaved: number;
  targetCo2Reduction: number;

  // エラー状態
  error: AppError | null;

  // アクション（Result型対応）
  addContribution: (params: ContributionParams) => Result<void, BusinessError>;
  updateProgress: () => Result<number, BusinessError>;

  // 派生データ（Result型対応）
  getEcoRank: () => Result<EcoRank, BusinessError>;

  // ユーティリティ
  clearError: () => void;
}

/**
 * EcoImpact スライスの作成関数（Result型対応）
 */
export const createEcoImpactSlice: StateCreator<
  EcoImpactSlice,
  [],
  [],
  EcoImpactSlice
> = (set, get) => ({
  // 初期状態（モックデータから）
  forestArea: ecoImpactData.forestArea,
  waterSaved: ecoImpactData.waterSaved,
  co2Reduction: ecoImpactData.co2Reduction,
  progressPercent: ecoImpactData.progressPercent,
  targetForestArea: ecoImpactData.targetForestArea,
  targetWaterSaved: ecoImpactData.targetWaterSaved,
  targetCo2Reduction: ecoImpactData.targetCo2Reduction,
  totalDonation: ecoImpactData.totalDonation,
  monthlyDonation: ecoImpactData.monthlyDonation,
  error: null,

  // 環境貢献を追加（Result型対応）
  addContribution: (params) => {
    try {
      // パラメータバリデーション
      if (!params || params.amount <= 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "無効な環境貢献パラメータです",
          reason: `amount: ${params?.amount}`,
          paymentId: undefined,
        });
      }

      set((state) => {
        const newState = calculateContribution(state, params);
        return { ...newState, error: null };
      });

      return ok(undefined);
    } catch (error) {
      const errorResult: BusinessError = {
        type: "PAYMENT_FAILED",
        message: "環境貢献の追加に失敗しました",
        reason: String(error),
        paymentId: undefined,
      };

      set({ error: errorResult });
      return err(errorResult);
    }
  },

  // 進捗率の更新（Result型対応）
  updateProgress: () => {
    try {
      const state = get();
      const progress = calculateEcoProgress(
        state.forestArea,
        state.waterSaved,
        state.co2Reduction,
        state.targetForestArea,
        state.targetWaterSaved,
        state.targetCo2Reduction,
      );

      // 進捗率の妥当性チェック
      if (progress < 0 || progress > 100) {
        return err({
          type: "PAYMENT_FAILED",
          message: "進捗率の計算結果が無効です",
          reason: `progress: ${progress}`,
          paymentId: undefined,
        });
      }

      set({ progressPercent: progress, error: null });
      return ok(progress);
    } catch (error) {
      const errorResult: BusinessError = {
        type: "PAYMENT_FAILED",
        message: "進捗率の更新に失敗しました",
        reason: String(error),
        paymentId: undefined,
      };

      set({ error: errorResult });
      return err(errorResult);
    }
  },

  // エコランクの取得（Result型対応）
  getEcoRank: () => {
    try {
      const totalDonation = get().totalDonation;

      if (totalDonation < 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "寄付総額が無効です",
          reason: `totalDonation: ${totalDonation}`,
          paymentId: undefined,
        });
      }

      const rank = getEcoRankFromDonation(totalDonation);
      return ok(rank);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "エコランクの取得に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // エラーをクリア
  clearError: () => {
    set({ error: null });
  },
});

/**
 * 単独で使用可能な EcoImpact ストアフック
 */
export const useEcoImpactStore = create<EcoImpactSlice>()((...a) => ({
  ...createEcoImpactSlice(...a),
}));
</file>

<file path="src/features/settings/components/tabs/ProfileTab.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { MapPin, Users } from "lucide-react";
import { Session } from "next-auth";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import Link from "next/link";
import { SettingSection } from "@/features/settings/components/SettingSection";
import { ErrorDisplay } from "@/components/ui/error-display";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateProfileForm } from "@/features/auth/utils/validation";
import { ok, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

interface ProfileTabProps {
  user?: Session["user"];
}

export function ProfileTab({ user }: ProfileTabProps) {
  // useAuthFormフックを使用してプロフィール更新フォームを管理
  const profileForm = useAuthForm({
    initialValues: {
      name: user?.name || "山田 太郎",
      email: user?.email || "eco_user@example.com",
      phone: "090-1234-5678",
      location: "tokyo",
    },
    validateForm: validateProfileForm,
    onSubmit: async (values) => {
      try {
        // TODO: 実際のAPI呼び出し処理
        // const updateResult = await updateProfileAsync(values);
        // return updateResult;

        // 現在はモックの成功処理
        console.log("Profile updated successfully:", values);

        return ok(undefined);
      } catch {
        const appError: AppError = {
          type: "NETWORK_ERROR",
          message: "プロフィールの更新中にエラーが発生しました",
        };
        return err(appError);
      }
    },
  });

  // エラー再試行ハンドラ
  const handleRetry = () => {
    profileForm.clearError();
  };

  // Select用の値変更ハンドラ
  const handleLocationChange = (value: string) => {
    profileForm.setValues((prev) => ({
      ...prev,
      location: value,
    }));

    // フィールドエラーをクリア
    if (profileForm.fieldErrors.location) {
      profileForm.clearFieldError("location");
    }
  };

  return (
    <div className="space-y-4">
      {/* エラー表示（Result型対応） */}
      {profileForm.error && (
        <ErrorDisplay
          error={profileForm.error}
          onRetry={handleRetry}
          className="mb-4"
        />
      )}

      {/* 基本情報セクション */}
      <form onSubmit={profileForm.handleSubmit}>
        <SettingSection
          title="基本情報"
          description="アカウントの基本情報を編集します"
        >
          <div className="space-y-2">
            <Label
              htmlFor="name"
              className="text-sm font-medium text-stone-800"
            >
              氏名
            </Label>
            <Input
              id="name"
              name="name"
              value={profileForm.values.name}
              onChange={profileForm.handleChange}
              className="border-stone-200"
              placeholder="山田 太郎"
              aria-describedby={
                profileForm.fieldErrors.name ? "name-error" : undefined
              }
            />
            {profileForm.fieldErrors.name && (
              <p id="name-error" className="text-xs text-red-600">
                {profileForm.fieldErrors.name.message}
              </p>
            )}
          </div>

          <div className="space-y-2">
            <Label
              htmlFor="email"
              className="text-sm font-medium text-stone-800"
            >
              メールアドレス
            </Label>
            <Input
              id="email"
              name="email"
              type="email"
              value={profileForm.values.email}
              onChange={profileForm.handleChange}
              className="border-stone-200"
              placeholder="eco_user@example.com"
              aria-describedby={
                profileForm.fieldErrors.email ? "email-error" : undefined
              }
            />
            {profileForm.fieldErrors.email && (
              <p id="email-error" className="text-xs text-red-600">
                {profileForm.fieldErrors.email.message}
              </p>
            )}
          </div>

          <div className="space-y-2">
            <Label
              htmlFor="phone"
              className="text-sm font-medium text-stone-800"
            >
              電話番号
            </Label>
            <Input
              id="phone"
              name="phone"
              type="tel"
              value={profileForm.values.phone}
              onChange={profileForm.handleChange}
              className="border-stone-200"
              placeholder="090-1234-5678"
              aria-describedby={
                profileForm.fieldErrors.phone ? "phone-error" : undefined
              }
            />
            {profileForm.fieldErrors.phone && (
              <p id="phone-error" className="text-xs text-red-600">
                {profileForm.fieldErrors.phone.message}
              </p>
            )}
          </div>
        </SettingSection>

        {/* 地域情報セクション */}
        <SettingSection
          title="地域情報"
          icon={<MapPin className="h-4 w-4 text-stone-600" />}
        >
          <div className="space-y-2">
            <Label
              htmlFor="location"
              className="text-sm font-medium text-stone-800"
            >
              お住まいの地域
            </Label>
            <div className="flex items-center space-x-2">
              <MapPin className="h-4 w-4 text-stone-400" />
              <Select
                value={profileForm.values.location}
                onValueChange={handleLocationChange}
              >
                <SelectTrigger
                  className="border-stone-200"
                  aria-describedby={
                    profileForm.fieldErrors.location
                      ? "location-error"
                      : undefined
                  }
                >
                  <SelectValue placeholder="地域を選択" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="hokkaido">北海道</SelectItem>
                  <SelectItem value="tohoku">東北</SelectItem>
                  <SelectItem value="kanto">関東</SelectItem>
                  <SelectItem value="tokyo">東京</SelectItem>
                  <SelectItem value="chubu">中部</SelectItem>
                  <SelectItem value="kansai">関西</SelectItem>
                  <SelectItem value="chugoku">中国</SelectItem>
                  <SelectItem value="shikoku">四国</SelectItem>
                  <SelectItem value="kyushu">九州</SelectItem>
                  <SelectItem value="okinawa">沖縄</SelectItem>
                </SelectContent>
              </Select>
            </div>
            {profileForm.fieldErrors.location && (
              <p id="location-error" className="text-xs text-red-600">
                {profileForm.fieldErrors.location.message}
              </p>
            )}
          </div>
        </SettingSection>

        <Button
          type="submit"
          disabled={profileForm.isLoading}
          className="w-full bg-teal-700 hover:bg-teal-800 text-white mt-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {profileForm.isLoading ? (
            <div className="flex items-center">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
              更新中...
            </div>
          ) : (
            "変更を保存"
          )}
        </Button>
      </form>

      {/* 友達招待セクション */}
      <SettingSection
        title="友達招待"
        icon={<Users className="h-4 w-4 text-teal-700" />}
        className="mt-6 pt-6 border-t border-stone-200"
      >
        <div className="flex items-center justify-between">
          <p className="text-xs text-stone-600">
            友達を招待すると、あなたも友達も1,000円分のエコポイントがもらえます
          </p>
          <Link href="/invite">
            <Button
              variant="outline"
              size="sm"
              className="text-xs text-teal-700 border-teal-200 hover:bg-teal-50"
            >
              友達を招待する
            </Button>
          </Link>
        </div>
      </SettingSection>
    </div>
  );
}
</file>

<file path="src/features/transactions/components/TransactionDetail/TransactionDetailView.tsx">
"use client";

import React from "react";
import { PageContainer } from "@/features/layout";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Transaction } from "@/shared/types/transaction";
import { TransactionStyle, ReceiptItem } from "@/features/transactions";

interface TransactionDetailViewProps {
  transaction: Transaction | null;
  loading: boolean;
  showReceipt: boolean;
  setShowReceipt: (show: boolean) => void;
  style?: TransactionStyle;
  formattedAmount: string;
  forestArea: number;
  co2Reduction: number;
  receiptItems: ReceiptItem[];
  transactionId: string;
  onBackToHistory: () => void;
  onShowEcoImpactDetails: () => void;
  onDownloadReceipt: () => void;
  onShareReceipt: () => void;
  // サブコンポーネントのレンダリング関数
  renderHeader: (
    transaction: Transaction | null,
    style?: TransactionStyle,
  ) => React.ReactNode;
  renderInfo: (
    transaction: Transaction | null,
    formattedAmount: string,
    style?: TransactionStyle,
  ) => React.ReactNode;
  renderActionButtons: () => React.ReactNode;
  renderEcoInfo: (forestArea: number, co2Reduction: number) => React.ReactNode;
  renderReceiptDialog: () => React.ReactNode;
}

/**
 * トランザクション詳細のビューコンポーネント
 *
 * プレゼンテーションロジックを担当し、UI表示に集中する
 */
export const TransactionDetailView = React.memo(
  ({
    transaction,
    loading,
    style,
    formattedAmount,
    forestArea,
    co2Reduction,
    onBackToHistory,
    // レンダリング関数
    renderHeader,
    renderInfo,
    renderActionButtons,
    renderEcoInfo,
    renderReceiptDialog,
  }: TransactionDetailViewProps) => {
    // ローディング中表示
    if (loading) {
      return (
        <PageContainer title="取引詳細" activeTab="history">
          <div className="flex justify-center items-center h-40">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-teal-700"></div>
          </div>
        </PageContainer>
      );
    }

    // トランザクションが見つからなかった場合
    if (!transaction) {
      return (
        <PageContainer title="取引詳細" activeTab="history">
          <div className="text-center py-8">
            <h2 className="text-lg font-medium text-stone-800">
              取引が見つかりませんでした
            </h2>
            <p className="text-sm text-stone-600 mt-2">
              この取引は削除されたか、存在しません。
            </p>
            <Button
              className="mt-4 bg-teal-700 hover:bg-teal-800 text-white"
              onClick={onBackToHistory}
            >
              取引履歴に戻る
            </Button>
          </div>
        </PageContainer>
      );
    }

    return (
      <PageContainer title="取引詳細" activeTab="history">
        {/* ヘッダー部分 */}
        {renderHeader(transaction, style)}

        {/* メイン情報 */}
        <Card className="border-0 shadow-md bg-white overflow-hidden">
          <div className="p-6">
            {renderInfo(transaction, formattedAmount, style)}
            {renderActionButtons()}
          </div>
        </Card>

        {/* 環境情報（該当する場合） */}
        {transaction.ecoContribution?.enabled &&
          renderEcoInfo(forestArea, co2Reduction)}

        {/* 電子レシートダイアログ */}
        {renderReceiptDialog()}
      </PageContainer>
    );
  },
);

TransactionDetailView.displayName = "TransactionDetailView";
</file>

<file path="src/features/transactions/README.md">
# 取引機能（Transactions Feature）

このディレクトリはバーティカルスライスアーキテクチャに基づいた取引機能を含みます。

## ディレクトリ構造

```
transactions/
├── README.md                   # このファイル（機能の説明）
├── components/                 # UIコンポーネント
│   ├── TransactionItem/        # 取引アイテム表示コンポーネント
│   │   ├── TransactionItem.tsx # 実装
│   │   └── index.ts           # 公開API
│   ├── RecentTransactions/     # 最近の取引リストコンポーネント
│   │   ├── RecentTransactionsContainer.tsx  # コンテナ
│   │   ├── RecentTransactionsList.tsx       # プレゼンテーション
│   │   └── index.ts           # 公開API
│   └── TransactionDetail/      # 取引詳細表示コンポーネント
│       ├── TransactionDetailContainer.tsx   # コンテナ
│       ├── TransactionDetailView.tsx        # メインプレゼンテーション
│       ├── TransactionHeader.tsx            # ヘッダー部分
│       ├── TransactionInfo.tsx              # 情報表示部分
│       ├── TransactionEcoInfo.tsx           # 環境貢献情報
│       ├── ActionButtons.tsx                # アクションボタン
│       ├── ReceiptDialog.tsx                # レシートダイアログ
│       └── index.ts           # 公開API
├── types/                      # 型定義
│   ├── transaction.ts         # 取引関連の型定義
│   └── receipt.ts             # レシート関連の型定義
├── hooks/                      # カスタムフック
│   ├── transactionStyling.tsx   # 取引のスタイリング関数
│   └── useFormattedCurrency.ts  # 通貨フォーマットフック
├── store/                      # 状態管理
│   └── transaction.slice.ts    # Zustandストア
└── index.ts                    # 公開API（エクスポート）
```

## 使い方

機能を使用するには、公開APIからコンポーネントと型をインポートします：

```typescript
import {
  // コンポーネント
  TransactionItem,
  RecentTransactionsContainer,
  TransactionDetailContainer,

  // 型定義
  Transaction,
  TransactionType,
  ReceiptItem,

  // フック
  getTransactionStyle,
  useFormattedCurrency,

  // ストア
  useTransactionStore,
} from "@/features/transactions";
```

### コンポーネント例

#### 取引アイテム

```tsx
<TransactionItem
  transaction={transaction}
  onClick={() => handleTransactionClick(transaction.id)}
/>
```

#### 最近の取引リスト

```tsx
<RecentTransactionsContainer limit={5} onViewAll={handleViewAll} />
```

#### 取引詳細

```tsx
// app/history/[id]/page.tsx
export default function TransactionDetailPage() {
  return <TransactionDetailContainer />;
}
```

## 責任

この機能モジュールは以下の責任を持ちます：

1. 取引データの管理と表示
2. 取引履歴の一覧表示
3. 個別取引の詳細表示
4. レシート表示と共有
5. 取引のフィルタリング
6. 環境貢献情報の表示（eco-impact機能と連携）

## 外部依存関係

- UI基本コンポーネント: `@/components/ui/`
- 環境貢献機能: `@/features/eco-impact`
- 状態管理: `zustand`

## 拡張予定

今後、以下の機能を追加予定です：

1. 取引の検索機能
2. 取引のソート機能
3. 取引のカテゴリ分類
4. 取引レポート出力
5. グラフ表示
</file>

<file path="src/features/transfer/hooks/useSplitForm.ts">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { useBalanceStore } from "@/features/balance/store/balance.slice";
import { SplitFormData, SplitParticipant } from "../types/transfer";
import {
  validateSplitForm,
  calculateEcoDonation,
  distributeAmountEvenly,
  calculateReceivableAmount,
} from "../utils/validation";
import { defaultParticipants } from "../data/recipients-data";
import { AppError } from "@/shared/types/errors";

export const useSplitForm = () => {
  const router = useRouter();
  const addTransaction = useTransactionStore((state) => state.addTransaction);
  const subtractFromRegularBalance = useBalanceStore(
    (state) => state.subtractFromRegularBalance,
  );

  // フォームの状態
  const [formData, setFormData] = useState<SplitFormData>({
    splitTitle: "",
    totalAmount: "",
    participants: defaultParticipants,
    isReceiptDisabled: true,
    splitMethod: "wallet",
  });

  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<AppError | null>(null);
  const [isSuccess, setIsSuccess] = useState(false);

  // フォームフィールドの更新
  const updateField = <K extends keyof SplitFormData>(
    field: K,
    value: SplitFormData[K],
  ) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    setError(null); // エラーをクリア
  };

  // 参加者の金額を更新
  const updateParticipantAmount = (id: string, amount: string) => {
    setFormData((prev) => ({
      ...prev,
      participants: prev.participants.map((p) =>
        p.id === id ? { ...p, amount } : p,
      ),
    }));
  };

  // 参加者のメールアドレスを更新
  const updateParticipantEmail = (id: string, email: string) => {
    setFormData((prev) => ({
      ...prev,
      participants: prev.participants.map((p) =>
        p.id === id ? { ...p, email } : p,
      ),
    }));
  };

  // 均等に金額を分ける
  const distributeEvenly = () => {
    if (
      !formData.totalAmount ||
      isNaN(Number(formData.totalAmount)) ||
      Number(formData.totalAmount) <= 0
    ) {
      setError({
        type: "INVALID_AMOUNT",
        message: "有効な合計金額を入力してください",
        field: "amount",
      });
      return;
    }

    const updatedParticipants = distributeAmountEvenly(
      Number(formData.totalAmount),
      formData.participants,
    );

    setFormData((prev) => ({
      ...prev,
      participants: updatedParticipants,
    }));
  };

  // 参加者を追加
  const addParticipant = (name: string, isEcoUser: boolean = false) => {
    const newParticipant: SplitParticipant = {
      id: `p${Date.now()}`,
      name,
      isEcoUser,
      amount: "",
      email: "",
    };

    setFormData((prev) => ({
      ...prev,
      participants: [...prev.participants, newParticipant],
    }));
  };

  // 参加者を削除
  const removeParticipant = (id: string) => {
    setFormData((prev) => ({
      ...prev,
      participants: prev.participants.filter((p) => p.id !== id),
    }));
  };

  // 割り勘処理
  const handleSplitRequest = async (): Promise<void> => {
    setError(null);

    const validation = validateSplitForm(formData);
    if (!validation.isValid) {
      setError({
        type: "INVALID_FORMAT",
        message: validation.error || "バリデーションエラー",
        field: "form",
        expected: "valid split form",
      });
      return;
    }

    setIsProcessing(true);

    try {
      // 割り勘処理のモック - 実際のAPIコールの代わりにタイマーを使用
      await new Promise((resolve) => setTimeout(resolve, 1500));

      const totalAmount = Number(formData.totalAmount);
      const donationAmount = calculateEcoDonation(totalAmount);

      // トランザクションの追加（立替分）
      const transactionId = addTransaction({
        type: "payment",
        description: `${formData.splitTitle}（立替）`,
        date: new Date()
          .toLocaleDateString("ja-JP", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          })
          .replace(/\//g, "/"),
        amount: -totalAmount,
        ecoContribution: {
          enabled: true,
          amount: donationAmount,
        },
        badges: ["割り勘"],
      });

      // 他の参加者からの入金予定
      const receivableAmount = calculateReceivableAmount(formData.participants);

      if (receivableAmount > 0) {
        addTransaction({
          type: "receive",
          description: `${formData.splitTitle}（割り勘請求）`,
          date: new Date()
            .toLocaleDateString("ja-JP", {
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
            })
            .replace(/\//g, "/"),
          amount: receivableAmount,
          badges: ["割り勘", "未受取"],
        });
      }

      // 残高の更新（立替分）
      subtractFromRegularBalance(totalAmount);

      // 成功状態にする
      setIsSuccess(true);

      // 3秒後にリダイレクト
      setTimeout(() => {
        router.push(`/history/${transactionId}`);
      }, 3000);

      return;
    } catch (error) {
      console.error("割り勘処理中にエラーが発生しました", error);
      setError({
        type: "NETWORK_ERROR",
        message: "割り勘処理に失敗しました。時間をおいて再度お試しください。",
        cause: error instanceof Error ? error : undefined,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  // エラー再試行ハンドラ
  const clearError = () => {
    setError(null);
  };

  // 計算値
  const totalAmount = Number(formData.totalAmount) || 0;
  const receivableAmount = calculateReceivableAmount(formData.participants);
  const donationAmount = calculateEcoDonation(totalAmount);

  return {
    formData,
    updateField,
    updateParticipantAmount,
    updateParticipantEmail,
    distributeEvenly,
    addParticipant,
    removeParticipant,
    handleSplitRequest,
    isProcessing,
    error,
    clearError,
    isSuccess,
    totalAmount,
    receivableAmount,
    donationAmount,
  };
};
</file>

<file path="src/features/transfer/hooks/useTransferForm.ts">
"use client";

import { useState, FormEvent } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Result, ok, err } from "neverthrow";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { useBalanceStore } from "@/features/balance/store/balance.slice";
import { AppError } from "@/shared/types/errors";
import { TransferFormData, Recipient } from "../types/transfer";
import {
  validateTransferFormResult,
  calculateEcoDonation,
} from "../utils/validation";

// 送金フォームのバリデーション結果型
export interface TransferValidationResult {
  isValid: boolean;
  errors: Record<string, AppError | null>;
}

// 送金フォームのバリデーション関数型
export type TransferValidationFunction = (
  formData: TransferFormData,
  userBalance: number,
) => TransferValidationResult;

// 送金フォームのバリデーション関数
const validateTransferForm = (
  formData: TransferFormData,
  userBalance: number,
): TransferValidationResult => {
  const validation = validateTransferFormResult(formData, userBalance);

  if (validation.isOk()) {
    return {
      isValid: true,
      errors: {},
    };
  }

  const error = validation.error;
  const errors: Record<string, AppError | null> = {};

  // エラーのフィールド特定（型安全に）
  if ("field" in error) {
    errors[error.field] = error;
  } else if ("fields" in error) {
    // PASSWORD_MISMATCHなどの複数フィールドエラー
    error.fields.forEach((field) => {
      errors[field] = error;
    });
  } else {
    // 特定のフィールドに属さないエラーは amount に設定
    errors.amount = error;
  }

  return {
    isValid: false,
    errors,
  };
};

interface UseTransferFormProps {
  initialFormData?: Partial<TransferFormData>;
  onTransferSuccess?: (transactionId: string) => void;
}

export const useTransferForm = (props: UseTransferFormProps = {}) => {
  const router = useRouter();
  const { data: session } = useSession();
  const addTransaction = useTransactionStore((state) => state.addTransaction);
  const subtractFromRegularBalance = useBalanceStore(
    (state) => state.subtractFromRegularBalance,
  );

  const { initialFormData = {}, onTransferSuccess } = props;

  // フォームの状態
  const [formData, setFormData] = useState<TransferFormData>({
    recipient: "",
    selectedRecipient: null,
    amount: "",
    message: "",
    isDonateChecked: true,
    ...initialFormData,
  });

  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<AppError | null>(null);
  const [fieldErrors, setFieldErrors] = useState<
    Record<string, AppError | null>
  >({});
  const [isSuccess, setIsSuccess] = useState(false);

  // フォームフィールドの更新
  const updateField = <K extends keyof TransferFormData>(
    field: K,
    value: TransferFormData[K],
  ) => {
    setFormData((prev) => ({ ...prev, [field]: value }));

    // フィールド変更時にそのフィールドのエラーをクリア
    if (fieldErrors[field as string]) {
      setFieldErrors((prev) => ({ ...prev, [field as string]: null }));
    }

    // グローバルエラーもクリア
    if (error) {
      setError(null);
    }
  };

  // 受取人を選択
  const selectRecipient = (recipient: Recipient) => {
    setFormData((prev) => ({
      ...prev,
      selectedRecipient: recipient,
      recipient: recipient.name,
    }));

    // 受取人フィールドのエラーをクリア
    if (fieldErrors.recipient) {
      setFieldErrors((prev) => ({ ...prev, recipient: null }));
    }
  };

  // 送金処理の実行
  const executeTransfer = async (): Promise<Result<string, AppError>> => {
    try {
      // 送金処理のモック - 実際のAPIコールの代わりにタイマーを使用
      await new Promise((resolve) => setTimeout(resolve, 1500));

      const recipientName = formData.selectedRecipient
        ? formData.selectedRecipient.name
        : formData.recipient;
      const transferAmount = Number(formData.amount);
      const donationAmount = formData.isDonateChecked
        ? calculateEcoDonation(transferAmount)
        : 0;
      const totalDeduction = transferAmount + donationAmount;

      // トランザクションの追加
      const transactionResult = addTransaction({
        type: "payment",
        description: `${recipientName}へ送金`,
        date: new Date()
          .toLocaleDateString("ja-JP", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          })
          .replace(/\//g, "/"),
        amount: -totalDeduction,
        ecoContribution: formData.isDonateChecked
          ? {
              enabled: true,
              amount: donationAmount,
            }
          : undefined,
      });

      if (transactionResult.isErr()) {
        // BusinessErrorをAppErrorに変換
        return err(transactionResult.error as AppError);
      }

      const transactionId = transactionResult.value;

      // 残高の更新
      subtractFromRegularBalance(totalDeduction);

      return ok(transactionId);
    } catch (error) {
      console.error("送金処理中にエラーが発生しました", error);
      return err({
        type: "SERVER_ERROR",
        message: "送金処理に失敗しました。時間をおいて再度お試しください。",
        statusCode: 500,
      });
    }
  };

  // 送金処理
  const handleTransfer = async (e?: FormEvent): Promise<void> => {
    if (e) {
      e.preventDefault();
    }

    setError(null);
    setFieldErrors({});

    const userBalance = session?.user?.balance || 0;
    const validation = validateTransferForm(formData, userBalance);

    setFieldErrors(validation.errors);

    if (!validation.isValid) {
      return;
    }

    setIsProcessing(true);

    try {
      const result = await executeTransfer();

      result.match(
        (transactionId) => {
          // 成功時の処理
          setIsSuccess(true);

          // コールバック実行
          if (onTransferSuccess) {
            onTransferSuccess(transactionId);
          } else {
            // デフォルトの成功処理：3秒後にリダイレクト
            setTimeout(() => {
              router.push(`/history/${transactionId}`);
            }, 3000);
          }
        },
        (err) => {
          setError(err);
        },
      );
    } catch (err) {
      // 予期しないエラーの場合
      setError({
        type: "SERVER_ERROR",
        message:
          err instanceof Error ? err.message : "予期しないエラーが発生しました",
        statusCode: 500,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  // エラークリア関数
  const clearError = () => {
    setError(null);
  };

  const clearFieldError = (fieldName: string) => {
    setFieldErrors((prev) => ({ ...prev, [fieldName]: null }));
  };

  const clearAllErrors = () => {
    setError(null);
    setFieldErrors({});
  };

  // 計算値
  const transferAmount = Number(formData.amount) || 0;
  const donationAmount = formData.isDonateChecked
    ? calculateEcoDonation(transferAmount)
    : 0;
  const totalAmount = transferAmount + donationAmount;

  return {
    // フォームデータ
    formData,
    updateField,
    selectRecipient,

    // 処理関数
    handleTransfer,

    // 状態
    isProcessing,
    error,
    fieldErrors,
    isSuccess,

    // エラー管理
    clearError,
    clearFieldError,
    clearAllErrors,

    // 計算値
    transferAmount,
    donationAmount,
    totalAmount,
  };
};
</file>

<file path="src/lib/utils/invitation-utils.ts">
/**
 * 招待機能関連のユーティリティ関数
 */
import { Invitation, InviteStatus } from "@/features/invite/types/invite";

/**
 * 招待コードを生成する
 */
export const generateInviteCode = (): string => {
  return (
    "ECO" +
    Math.floor(Math.random() * 10000)
      .toString()
      .padStart(4, "0")
  );
};

/**
 * 招待リンクを生成する
 */
export const generateInviteLink = (userId: string): string => {
  return `https://ecowallet.example.com/register?ref=${userId}`;
};

/**
 * 新しい招待オブジェクトを作成する
 */
export const createNewInvitation = (
  email: string,
  code: string,
  inviterId: string,
): Invitation => {
  return {
    email,
    code,
    status: "pending",
    createdAt: new Date().toISOString().split("T")[0].replace(/-/g, "/"),
    inviterId,
  };
};

/**
 * 招待を受諾済みに更新する
 */
export const updateInvitationToAccepted = (
  invitation: Invitation,
  inviteeId: string,
): Invitation => {
  return {
    ...invitation,
    status: "registered",
    usedAt: new Date().toISOString().split("T")[0].replace(/-/g, "/"),
    inviteeId,
  };
};

/**
 * 招待状態を取得する
 */
export const getInvitationStatusByCode = (
  invitations: Invitation[],
  code: string,
): InviteStatus | undefined => {
  const invitation = invitations.find((inv) => inv.code === code);
  return invitation?.status;
};

/**
 * 招待からの獲得ポイントを計算する
 */
export const calculateEarnedPoints = (
  sentInvitations: Invitation[],
  pointsPerInvite: number = 1000,
): number => {
  const acceptedCount = sentInvitations.filter(
    (inv) => inv.status === "registered",
  ).length;
  return acceptedCount * pointsPerInvite;
};
</file>

<file path="src/app/auth/login/page.tsx">
"use client";

import { AuthLayout } from "@/features/layout";
import { LoginForm } from "@/features/auth";
import { Gift } from "lucide-react";

export default function LoginPage() {
  return (
    <AuthLayout title="ログイン" subtitle="シンプルで環境に優しい決済サービス">
      <div className="mb-6 p-4 bg-amber-50 border border-amber-200 rounded-lg shadow-sm">
        <div className="flex items-center mb-3">
          <Gift className="h-5 w-5 text-amber-700 mr-2" />
          <h3 className="text-sm font-medium text-amber-800">
            テストアカウント
          </h3>
        </div>
        <div className="space-y-2 text-sm text-amber-700 pl-7">
          <div className="grid grid-cols-[100px_1fr] gap-1">
            <span className="text-amber-800 font-medium">メールアドレス:</span>
            <span>demo@example.com</span>
          </div>
          <div className="grid grid-cols-[100px_1fr] gap-1">
            <span className="text-amber-800 font-medium">パスワード:</span>
            <span>P@ssw0rd</span>
          </div>
        </div>
      </div>
      <LoginForm />
    </AuthLayout>
  );
}
</file>

<file path="src/app/charge/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import { useSession } from "next-auth/react";
import { ChargeInputContainer } from "@/features/charge/components/ChargeInput";
import { ChargeConfirm } from "@/features/charge/components/ChargeConfirm";
import { ChargeComplete } from "@/features/charge/components/ChargeComplete";
import { PageContainer } from "@/features/layout";
import { processCharge, type ChargeParams } from "@/lib/business/balance";
import { showAppErrorNotification } from "@/shared/stores/app.slice";
import type { AppError } from "@/shared/types/errors";

type ChargeStep = "input" | "confirm" | "complete";

export default function ChargePage() {
  const router = useRouter();
  const { data: session, update } = useSession();

  // 基本状態
  const [currentStep, setCurrentStep] = useState<ChargeStep>("input");
  const [paymentMethod] = useState<"credit-card" | "bank">("credit-card");
  const [amount, setAmount] = useState<string>("");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<AppError | null>(null);
  const [transactionId, setTransactionId] = useState<string>("");

  // 銀行振込関連の状態
  const [transferCode] = useState<string>("");

  // 確認ステップへの移行
  const handleProceedToConfirm = (receivedAmount?: number) => {
    // 受け取った金額がある場合は状態を更新
    if (receivedAmount) {
      setAmount(receivedAmount.toString());
    }

    const amountToCheck = receivedAmount ? receivedAmount.toString() : amount;
    if (
      !amountToCheck ||
      isNaN(Number(amountToCheck)) ||
      Number(amountToCheck) <= 0
    ) {
      const validationError: AppError = {
        type: "INVALID_AMOUNT",
        message: "有効な金額を入力してください",
        field: "amount",
      };
      setError(validationError);
      showAppErrorNotification(validationError);
      return;
    }
    setError(null);
    setCurrentStep("confirm");
  };

  // 入力ステップに戻る
  const handleBackToInput = () => {
    setCurrentStep("input");
  };

  // チャージ処理
  const handleConfirmCharge = async () => {
    setIsLoading(true);
    setError(null);

    const chargeParams: ChargeParams = {
      amount: Number(amount),
      paymentMethod:
        paymentMethod === "credit-card" ? "credit_card" : "bank_transfer",
      description: "Eco Walletチャージ",
    };

    const result = await processCharge(chargeParams);

    result.match(
      async (success) => {
        // チャージ成功
        setTransactionId(success.transactionId);

        // セッションの残高を更新
        if (session?.user) {
          const newBalance = (session.user.balance || 0) + success.amount;
          await update({ balance: newBalance });
        }

        setCurrentStep("complete");
      },
      (chargeError) => {
        // チャージ失敗
        setError(chargeError);
        showAppErrorNotification(chargeError, "チャージエラー");
      },
    );

    setIsLoading(false);
  };

  const handleBack = () => {
    if (currentStep === "input") {
      router.back();
    } else {
      handleBackToInput();
    }
  };

  return (
    <PageContainer showHeader={false} showFooter={false}>
      <div className="min-h-screen bg-stone-50">
        {/* ヘッダー */}
        <div className="max-w-md mx-auto px-4 pt-6 pb-4">
          <Button
            variant="ghost"
            size="sm"
            onClick={handleBack}
            className="mb-4 -ml-2 text-stone-600 hover:text-stone-800"
          >
            <ArrowLeft className="h-4 w-4 mr-1" />
            戻る
          </Button>

          <div className="text-center mb-6">
            <h1 className="text-2xl font-bold text-stone-800 mb-2">
              {currentStep === "input" && "チャージ"}
              {currentStep === "confirm" && "チャージ確認"}
              {currentStep === "complete" && "チャージ完了"}
            </h1>
            <p className="text-sm text-stone-600">
              {currentStep === "input" &&
                "お支払い方法と金額を選択してください"}
              {currentStep === "confirm" && "チャージ内容をご確認ください"}
              {currentStep === "complete" && "チャージが完了しました"}
            </p>
          </div>
        </div>

        <div className="max-w-md mx-auto px-4 pb-8">
          {currentStep === "input" && (
            <ChargeInputContainer
              onProceedToConfirm={(amount) => handleProceedToConfirm(amount)}
            />
          )}

          {currentStep === "confirm" && (
            <ChargeConfirm
              amount={amount}
              paymentMethod={paymentMethod}
              session={session}
              isLoading={isLoading}
              error={error}
              handleConfirmCharge={handleConfirmCharge}
              handleBackToInput={handleBackToInput}
            />
          )}

          {currentStep === "complete" && (
            <ChargeComplete
              amount={amount}
              paymentMethod={paymentMethod}
              session={session}
              transactionId={transactionId}
              transferCode={transferCode}
              router={router}
            />
          )}
        </div>
      </div>
    </PageContainer>
  );
}
</file>

<file path="src/features/donation/components/DonateInput/DonateInputContainer.tsx">
"use client";

import { useBalanceStore } from "@/features/balance/store/balance.slice";
import { DonationProject } from "../../types/donation";
import { DonateInputForm } from "./DonateInputForm";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateDonationForm } from "@/features/auth/utils/validation";
import { ErrorDisplay } from "@/components/ui/error-display";
import { ok, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

interface DonateInputContainerProps {
  project: DonationProject;
  onProceed: (amount: number) => void;
}

// コンテナコンポーネント: 状態管理とロジック処理を担当
export function DonateInputContainer({
  project,
  onProceed,
}: DonateInputContainerProps) {
  // 残高データの取得
  const balanceResult = useBalanceStore((state) => state.getTotalBalance());
  const balance = balanceResult.isOk() ? balanceResult.value : 0;

  // useAuthFormフックを使用して寄付フォームを管理
  const donationForm = useAuthForm({
    initialValues: {
      amount: "",
    },
    validateForm: validateDonationForm,
    onSubmit: async (values) => {
      try {
        const numAmount = parseFloat(values.amount);

        // 残高不足チェック
        if (numAmount > balance) {
          const insufficientBalanceError: AppError = {
            type: "INSUFFICIENT_BALANCE",
            message: "残高が足りません",
            required: numAmount,
            available: balance,
          };
          return err(insufficientBalanceError);
        }

        // 寄付処理を実行（次のステップに進む）
        onProceed(numAmount);

        return ok(undefined);
      } catch {
        const appError: AppError = {
          type: "NETWORK_ERROR",
          message: "寄付処理中にエラーが発生しました",
        };
        return err(appError);
      }
    },
  });

  // エラー再試行ハンドラ
  const handleRetry = () => {
    donationForm.clearError();
  };

  // 金額クイック選択ハンドラー
  const handleSelectAmount = (value: string) => {
    donationForm.setValues({ amount: value });

    // フィールドエラーをクリア
    if (donationForm.fieldErrors.amount) {
      donationForm.clearFieldError("amount");
    }
  };

  // フォーム送信ハンドラー（DonateInputFormの型に合わせる）
  const handleProceedToConfirm = () => {
    // FormEventを作成してhandleSubmitを呼び出す
    const event = {
      preventDefault: () => {},
    } as React.FormEvent;

    donationForm.handleSubmit(event);
  };

  return (
    <div className="space-y-4">
      {/* エラー表示（Result型対応） */}
      {donationForm.error && (
        <ErrorDisplay
          error={donationForm.error}
          onRetry={handleRetry}
          className="mb-4"
        />
      )}

      <DonateInputForm
        project={project}
        amount={donationForm.values.amount}
        setAmount={(value: string) => donationForm.setValues({ amount: value })}
        error={donationForm.fieldErrors.amount?.message || null}
        handleSelectAmount={handleSelectAmount}
        handleProceedToConfirm={handleProceedToConfirm}
        balance={balance}
        isLoading={donationForm.isLoading}
      />
    </div>
  );
}
</file>

<file path="src/features/eco-impact/index.ts">
// 型定義のエクスポート
export * from "./types/eco-impact";

// ストアのエクスポート
export { useEcoImpactStore } from "./store/eco-impact.slice";
export type { EcoImpactSlice } from "./store/eco-impact.slice";

// フックのエクスポート
export { useEcoImpact } from "./hooks/useEcoImpact";

// ユーティリティ関数のエクスポート
export {
  calculateEcoImpact,
  getEcoRankFromDonation,
  calculateEcoProgress,
  calculateContribution,
} from "./utils/calculations";

// コンポーネントのエクスポート
export { CompactEcoImpact } from "./components/CompactEcoImpact";
export { EcoImpactDisplay } from "./components/EcoImpact";
export { TransactionEcoImpact } from "./components/TransactionEcoImpact";
export { NewsAndProjects } from "./components/NewsAndProjects";
export { RecommendedAction } from "./components/RecommendedAction";
export { EcoContributionSummary } from "./components/EcoContributionSummary";
</file>

<file path="src/features/settings/components/tabs/SecurityTab.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import { Card } from "@/components/ui/card";
import { Session } from "next-auth";
import {
  Eye,
  EyeOff,
  Shield,
  Smartphone,
  Laptop,
  LogOut,
  Fingerprint,
} from "lucide-react";
import { SettingSection } from "@/features/settings/components/SettingSection";
import { ErrorDisplay } from "@/components/ui/error-display";
import { useAuthForm } from "@/features/auth/hooks/useAuthForm";
import { validateChangePasswordForm } from "@/features/auth/utils/validation";
import { ok, err } from "neverthrow";
import { AppError } from "@/shared/types/errors";

interface SecurityTabProps {
  user?: Session["user"];
}

export function SecurityTab({ user }: SecurityTabProps) {
  // パスワードの表示/非表示を管理する状態
  const [showPassword, setShowPassword] = useState(false);
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  // useAuthFormフックを使用してパスワード変更フォームを管理
  const passwordForm = useAuthForm({
    initialValues: {
      currentPassword: "",
      newPassword: "",
      confirmNewPassword: "",
    },
    validateForm: validateChangePasswordForm,
    onSubmit: async (values) => {
      try {
        // TODO: 実際のAPI呼び出し処理
        // const updateResult = await updatePasswordAsync({
        //   currentPassword: values.currentPassword,
        //   newPassword: values.newPassword,
        // });
        // return updateResult;

        // 現在はモックの成功処理
        console.log("Password updated successfully:", values);

        // 成功時はコンソールログのみ（実際のAPIでは通知を追加可能）
        console.log("Password change successful");

        // フォームをリセット
        passwordForm.setValues({
          currentPassword: "",
          newPassword: "",
          confirmNewPassword: "",
        });

        return ok(undefined);
      } catch {
        const appError: AppError = {
          type: "NETWORK_ERROR",
          message: "パスワードの変更中にエラーが発生しました",
        };
        return err(appError);
      }
    },
  });

  // エラー再試行ハンドラ
  const handleRetry = () => {
    passwordForm.clearError();
  };

  return (
    <div className="space-y-6">
      {/* エラー表示（Result型対応） */}
      {passwordForm.error && (
        <ErrorDisplay
          error={passwordForm.error}
          onRetry={handleRetry}
          className="mb-4"
        />
      )}

      {/* パスワード変更セクション */}
      <form onSubmit={passwordForm.handleSubmit}>
        <SettingSection
          title="パスワード変更"
          icon={<Shield className="h-4 w-4 text-teal-700" />}
          description={`${user?.email || "eco_user@example.com"} アカウントのパスワード変更`}
        >
          <div className="space-y-3">
            {/* 現在のパスワード */}
            <div className="space-y-2">
              <Label
                htmlFor="currentPassword"
                className="text-sm text-stone-700"
              >
                現在のパスワード
              </Label>
              <div className="relative">
                <Input
                  id="currentPassword"
                  name="currentPassword"
                  type={showPassword ? "text" : "password"}
                  className="border-stone-200 pr-10"
                  value={passwordForm.values.currentPassword}
                  onChange={passwordForm.handleChange}
                  aria-required="true"
                  aria-describedby={
                    passwordForm.fieldErrors.currentPassword
                      ? "currentPassword-error"
                      : undefined
                  }
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-stone-500 hover:text-stone-700"
                  onClick={() => setShowPassword(!showPassword)}
                  aria-label={
                    showPassword ? "パスワードを隠す" : "パスワードを表示"
                  }
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
              {passwordForm.fieldErrors.currentPassword && (
                <p id="currentPassword-error" className="text-xs text-red-600">
                  {passwordForm.fieldErrors.currentPassword.message}
                </p>
              )}
            </div>

            {/* 新しいパスワード */}
            <div className="space-y-2">
              <Label htmlFor="newPassword" className="text-sm text-stone-700">
                新しいパスワード
              </Label>
              <div className="relative">
                <Input
                  id="newPassword"
                  name="newPassword"
                  type={showNewPassword ? "text" : "password"}
                  className="border-stone-200 pr-10"
                  value={passwordForm.values.newPassword}
                  onChange={passwordForm.handleChange}
                  aria-required="true"
                  aria-describedby={
                    passwordForm.fieldErrors.newPassword
                      ? "newPassword-error"
                      : "newPassword-help"
                  }
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-stone-500 hover:text-stone-700"
                  onClick={() => setShowNewPassword(!showNewPassword)}
                  aria-label={
                    showNewPassword ? "パスワードを隠す" : "パスワードを表示"
                  }
                >
                  {showNewPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
              <p id="newPassword-help" className="text-xs text-stone-500 mt-1">
                8文字以上で、数字と記号を含めてください
              </p>
              {passwordForm.fieldErrors.newPassword && (
                <p id="newPassword-error" className="text-xs text-red-600">
                  {passwordForm.fieldErrors.newPassword.message}
                </p>
              )}
            </div>

            {/* 新しいパスワード（確認） */}
            <div className="space-y-2">
              <Label
                htmlFor="confirmNewPassword"
                className="text-sm text-stone-700"
              >
                新しいパスワード（確認）
              </Label>
              <div className="relative">
                <Input
                  id="confirmNewPassword"
                  name="confirmNewPassword"
                  type={showConfirmPassword ? "text" : "password"}
                  className="border-stone-200 pr-10"
                  value={passwordForm.values.confirmNewPassword}
                  onChange={passwordForm.handleChange}
                  aria-required="true"
                  aria-describedby={
                    passwordForm.fieldErrors.confirmNewPassword
                      ? "confirmNewPassword-error"
                      : undefined
                  }
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-stone-500 hover:text-stone-700"
                  onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                  aria-label={
                    showConfirmPassword
                      ? "パスワードを隠す"
                      : "パスワードを表示"
                  }
                >
                  {showConfirmPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
              {passwordForm.fieldErrors.confirmNewPassword && (
                <p
                  id="confirmNewPassword-error"
                  className="text-xs text-red-600"
                >
                  {passwordForm.fieldErrors.confirmNewPassword.message}
                </p>
              )}
            </div>
          </div>

          <Button
            type="submit"
            disabled={passwordForm.isLoading}
            className="w-full bg-teal-700 hover:bg-teal-800 text-white mt-3 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {passwordForm.isLoading ? (
              <div className="flex items-center">
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                変更中...
              </div>
            ) : (
              "パスワードを変更"
            )}
          </Button>
        </SettingSection>
      </form>

      <Separator className="my-6" />

      {/* 二段階認証セクション */}
      <SettingSection
        title="二段階認証"
        icon={<Shield className="h-4 w-4 text-teal-700" />}
      >
        <Card className="border border-stone-200 p-4 bg-stone-50">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <Label
                htmlFor="2fa"
                className="text-sm font-medium text-stone-800"
              >
                二段階認証を有効化
              </Label>
              <p className="text-xs text-stone-500">
                ログイン時に確認コードが必要になります
              </p>
            </div>
            <Switch id="2fa" defaultChecked aria-label="二段階認証を有効化" />
          </div>
        </Card>

        <Card className="border border-stone-200 p-4 bg-stone-50 mt-3">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <Label
                htmlFor="biometric"
                className="text-sm font-medium text-stone-800"
              >
                <div className="flex items-center">
                  <Fingerprint className="h-4 w-4 text-stone-600 mr-2" />
                  生体認証
                </div>
              </Label>
              <p className="text-xs text-stone-500">
                指紋または顔認証でログインできます
              </p>
            </div>
            <Switch
              id="biometric"
              defaultChecked
              aria-label="生体認証を有効化"
            />
          </div>
        </Card>
      </SettingSection>

      <Separator className="my-6" />

      {/* デバイス管理セクション */}
      <SettingSection
        title="デバイス管理"
        icon={<Smartphone className="h-4 w-4 text-teal-700" />}
      >
        <Card className="border border-stone-200 p-4 shadow-sm">
          <div className="flex justify-between items-center">
            <div className="flex items-start space-x-3">
              <div className="mt-0.5 w-8 h-8 bg-teal-50 rounded-full flex items-center justify-center">
                <Smartphone className="h-4 w-4 text-teal-700" />
              </div>
              <div>
                <h4 className="text-sm font-medium text-stone-800">
                  iPhone 13 Pro
                </h4>
                <p className="text-xs text-stone-500">
                  最終ログイン: 2025/04/20 10:23
                </p>
              </div>
            </div>
            <Badge className="bg-teal-100 text-teal-800 hover:bg-teal-200">
              現在のデバイス
            </Badge>
          </div>
        </Card>

        <Card className="border border-stone-200 p-4 shadow-sm mt-3">
          <div className="flex justify-between items-center">
            <div className="flex items-start space-x-3">
              <div className="mt-0.5 w-8 h-8 bg-stone-50 rounded-full flex items-center justify-center">
                <Laptop className="h-4 w-4 text-stone-600" />
              </div>
              <div>
                <h4 className="text-sm font-medium text-stone-800">
                  MacBook Pro
                </h4>
                <p className="text-xs text-stone-500">
                  最終ログイン: 2025/04/19 18:45
                </p>
              </div>
            </div>
            <Button
              variant="outline"
              size="sm"
              className="h-8 text-xs text-red-600 border-red-200 hover:bg-red-50"
            >
              解除
            </Button>
          </div>
        </Card>
      </SettingSection>

      <Button
        variant="outline"
        className="w-full mt-6 text-red-600 border-red-200 hover:bg-red-50 flex items-center justify-center"
      >
        <LogOut className="h-4 w-4 mr-2" />
        すべてのデバイスからログアウト
      </Button>
    </div>
  );
}
</file>

<file path="src/features/transactions/store/transaction.slice.ts">
import { StateCreator } from "zustand";
import { create } from "zustand";
import { Result, ResultAsync, ok, err } from "neverthrow";
import { Transaction, TransactionType } from "@/shared/types/transaction";
import { BusinessError, AppError } from "@/shared/types/errors";
import { transactionsData } from "@/features/transactions/data/transactions-data";
import {
  filterTransactionsByDateRange,
  filterTransactionsByType,
  getRecentTransactions,
  filterTransactionsWithEcoContribution,
  calculateTotalEcoContribution,
} from "@/lib/utils/transactions/filtering";
import {
  fetchTransactions,
  createTransaction,
  updateTransaction,
  deleteTransaction,
} from "@/services/api/transactions";
import { validateTransactionAmount } from "@/lib/business/transaction";

/**
 * Transaction スライスの型定義（Result型対応）
 */
export interface TransactionSlice {
  // データ
  transactions: Transaction[];

  // 状態管理
  isLoading: boolean;
  error: AppError | null;

  // アクション（Result型対応）
  addTransaction: (
    transaction: Omit<Transaction, "id">,
  ) => Result<string, BusinessError>;
  addTransactionAsync: (
    transaction: Omit<Transaction, "id">,
  ) => ResultAsync<string, AppError>;
  updateTransactionAsync: (
    id: string,
    updates: Partial<Transaction>,
  ) => ResultAsync<void, AppError>;
  deleteTransactionAsync: (id: string) => ResultAsync<void, AppError>;
  fetchTransactionsAsync: (
    params?: Record<string, unknown>,
  ) => ResultAsync<void, AppError>;

  // クエリ（Result型対応）
  getTransactionById: (id: string) => Result<Transaction, BusinessError>;
  getTransactionsByType: (
    type: TransactionType,
  ) => Result<Transaction[], BusinessError>;
  getRecentTransactions: (
    limit?: number,
  ) => Result<Transaction[], BusinessError>;
  getTransactionsByDateRange: (
    startDate: string,
    endDate: string,
  ) => Result<Transaction[], BusinessError>;
  getTransactionsWithEcoContribution: () => Result<
    Transaction[],
    BusinessError
  >;
  getTotalEcoContribution: () => Result<number, BusinessError>;

  // ユーティリティ
  clearError: () => void;
  setLoading: (loading: boolean) => void;
}

/**
 * Transaction スライスの作成関数（Result型対応）
 */
export const createTransactionSlice: StateCreator<
  TransactionSlice,
  [],
  [],
  TransactionSlice
> = (set, get) => ({
  // 初期状態
  transactions: transactionsData,
  isLoading: false,
  error: null,

  // 新しい取引を追加（Result型対応）
  addTransaction: (transaction) => {
    try {
      // バリデーション
      if (!transaction.amount || transaction.amount <= 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "取引金額が無効です",
          reason: `無効な金額: ${transaction.amount}`,
          paymentId: undefined,
        });
      }

      const amountValidation = validateTransactionAmount(
        transaction.amount,
        transaction.type,
      );
      if (amountValidation.isErr()) {
        return err(amountValidation.error);
      }

      const id = `txn_${Date.now().toString(36)}`;
      const newTransaction = { id, ...transaction };

      set((state) => ({
        transactions: [newTransaction, ...state.transactions],
        error: null,
      }));

      return ok(id);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引の追加に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 非同期で取引を追加（API統合）
  addTransactionAsync: (transaction) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        const createRequest = {
          type: transaction.type,
          amount: transaction.amount,
          description: transaction.description || "",
          ecoContribution: transaction.ecoContribution,
        };

        const apiResult = await createTransaction(createRequest);

        if (apiResult.isErr()) {
          const error: AppError = apiResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        const newTransaction = apiResult.value;
        set((state) => ({
          transactions: [newTransaction, ...state.transactions],
          isLoading: false,
          error: null,
        }));

        return newTransaction.id;
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // 取引を更新（API統合）
  updateTransactionAsync: (id, updates) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        const updateRequest = {
          description: updates.description,
          ecoContribution: updates.ecoContribution,
        };

        const apiResult = await updateTransaction(id, updateRequest);

        if (apiResult.isErr()) {
          const error: AppError = apiResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        const updatedTransaction = apiResult.value;
        set((state) => ({
          transactions: state.transactions.map((t) =>
            t.id === id ? updatedTransaction : t,
          ),
          isLoading: false,
          error: null,
        }));
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // 取引を削除（API統合）
  deleteTransactionAsync: (id) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        const apiResult = await deleteTransaction(id);

        if (apiResult.isErr()) {
          const error: AppError = apiResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        set((state) => ({
          transactions: state.transactions.filter((t) => t.id !== id),
          isLoading: false,
          error: null,
        }));
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // 取引一覧を取得（API統合）
  fetchTransactionsAsync: (params = {}) => {
    return ResultAsync.fromSafePromise(
      (async () => {
        set({ isLoading: true, error: null });

        const apiResult = await fetchTransactions(params);

        if (apiResult.isErr()) {
          const error: AppError = apiResult.error;
          set({ isLoading: false, error });
          throw error;
        }

        const transactionsResponse = apiResult.value;
        set({
          transactions: transactionsResponse.transactions,
          isLoading: false,
          error: null,
        });
      })(),
    ).mapErr((error: unknown): AppError => {
      const appError: AppError =
        error && typeof error === "object" && "type" in error
          ? (error as AppError)
          : { type: "NETWORK_ERROR", message: String(error) };

      set({ isLoading: false, error: appError });
      return appError;
    });
  },

  // IDで取引を検索（Result型対応）
  getTransactionById: (id) => {
    try {
      if (!id || id.trim() === "") {
        return err({
          type: "PAYMENT_FAILED",
          message: "取引IDが無効です",
          reason: `空のID: ${id}`,
          paymentId: undefined,
        });
      }

      const transaction = get().transactions.find(
        (transaction) => transaction.id === id,
      );

      if (!transaction) {
        return err({
          type: "PAYMENT_FAILED",
          message: "取引が見つかりません",
          reason: `取引ID: ${id}`,
          paymentId: undefined,
        });
      }

      return ok(transaction);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引の検索に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // タイプで取引をフィルタリング（Result型対応）
  getTransactionsByType: (type) => {
    try {
      const transactions = filterTransactionsByType(get().transactions, type);
      return ok(transactions);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "取引のフィルタリングに失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 最近の取引を取得（Result型対応）
  getRecentTransactions: (limit = 5) => {
    try {
      if (limit <= 0) {
        return err({
          type: "PAYMENT_FAILED",
          message: "制限数は0より大きい値である必要があります",
          reason: `無効な制限数: ${limit}`,
          paymentId: undefined,
        });
      }

      const transactions = getRecentTransactions(get().transactions, limit);
      return ok(transactions);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "最近の取引の取得に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 日付範囲で取引をフィルタリング（Result型対応）
  getTransactionsByDateRange: (startDate, endDate) => {
    try {
      if (!startDate || !endDate) {
        return err({
          type: "PAYMENT_FAILED",
          message: "開始日と終了日は必須です",
          reason: `startDate: ${startDate}, endDate: ${endDate}`,
          paymentId: undefined,
        });
      }

      const transactions = filterTransactionsByDateRange(
        get().transactions,
        startDate,
        endDate,
      );
      return ok(transactions);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "日付範囲での取引フィルタリングに失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 環境貢献のある取引を取得（Result型対応）
  getTransactionsWithEcoContribution: () => {
    try {
      const transactions = filterTransactionsWithEcoContribution(
        get().transactions,
      );
      return ok(transactions);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "環境貢献取引の取得に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // 環境貢献の合計を計算（Result型対応）
  getTotalEcoContribution: () => {
    try {
      const total = calculateTotalEcoContribution(get().transactions);
      return ok(total);
    } catch (error) {
      return err({
        type: "PAYMENT_FAILED",
        message: "環境貢献合計の計算に失敗しました",
        reason: String(error),
        paymentId: undefined,
      });
    }
  },

  // エラーをクリア
  clearError: () => {
    set({ error: null });
  },

  // ローディング状態を設定
  setLoading: (loading: boolean) => {
    set({ isLoading: loading });
  },
});

/**
 * 単独で使用可能な Transaction ストアフック
 */
export const useTransactionStore = create<TransactionSlice>()((...a) => ({
  ...createTransactionSlice(...a),
}));
</file>

<file path="src/features/transfer/index.ts">
// 型定義
export * from "./types/transfer";

// フック
export * from "./hooks";

// コンポーネント
export { RecipientSelector } from "./components/RecipientSelector";
export { SuccessMessage } from "./components/SuccessMessage";
export { TransferForm } from "./components/TransferForm";
export { SplitForm } from "./components/SplitForm";
export { SplitHistoryList } from "./components/SplitHistoryList";
export { TransferSplitPage } from "./components/TransferSplitPage";

// データ
export {
  recentRecipients,
  splitHistories,
  defaultParticipants,
} from "./data/recipients-data";

// ユーティリティ
export * from "./utils/validation";
</file>

<file path="src/app/campaigns/page.tsx">
"use client";

import Link from "next/link";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import {
  Leaf,
  Zap,
  Calendar,
  ChevronRight,
  Users,
  Filter,
  Tag,
  Gift,
  Clock,
  Flame,
  ArrowRight,
  Star,
} from "lucide-react";
import { useCampaignStore } from "@/features/campaigns/store/campaign.slice";
import { PageContainer } from "@/features/layout";
import { Campaign } from "@/features/campaigns/types/campaign";

export default function CampaignsPage() {
  const getActiveCampaigns = useCampaignStore(
    (state) => state.getActiveCampaigns,
  );
  const getCampaignsByType = useCampaignStore(
    (state) => state.getCampaignsByType,
  );

  const activeCampaigns = getActiveCampaigns();
  const ecoCampaigns = getCampaignsByType("eco");
  const referralCampaigns = getCampaignsByType("referral");

  return (
    <PageContainer title="キャンペーン">
      {/* ヘッダーセクション */}
      <div className="bg-gradient-to-br from-teal-700 to-teal-600 -mx-4 -mt-4 p-6 mb-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h1 className="text-2xl font-bold text-white mb-2">キャンペーン</h1>
            <p className="text-teal-100 text-sm">
              参加してポイントを獲得し、環境に貢献しよう
            </p>
          </div>
          <div className="bg-white/20 backdrop-blur-sm rounded-lg p-3">
            <Flame className="h-6 w-6 text-white" />
          </div>
        </div>

        {/* キャンペーン統計 */}
        <div className="grid grid-cols-2 gap-3 mt-4">
          <div className="bg-white/10 backdrop-blur-sm rounded-lg p-3">
            <div className="flex items-center justify-between">
              <span className="text-teal-100 text-xs">開催中</span>
              <Star className="h-4 w-4 text-amber-300" />
            </div>
            <p className="text-2xl font-bold text-white">
              {activeCampaigns.length}
            </p>
            <p className="text-teal-100 text-xs">キャンペーン</p>
          </div>
          <div className="bg-white/10 backdrop-blur-sm rounded-lg p-3">
            <div className="flex items-center justify-between">
              <span className="text-teal-100 text-xs">今月の参加</span>
              <Zap className="h-4 w-4 text-amber-300" />
            </div>
            <p className="text-2xl font-bold text-white">5</p>
            <p className="text-teal-100 text-xs">キャンペーン</p>
          </div>
        </div>
      </div>

      {/* フィルターボタン */}
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold text-stone-800">
          開催中のキャンペーン
        </h2>
        <Button
          variant="outline"
          size="sm"
          className="text-stone-600 border-stone-200 hover:bg-stone-50 hover:border-stone-300 transition-all duration-200"
        >
          <Filter className="h-4 w-4 mr-1" />
          絞り込み
        </Button>
      </div>

      {/* タブ */}
      <Tabs defaultValue="all" className="w-full">
        <TabsList className="grid grid-cols-3 bg-stone-100 p-1 rounded-lg">
          <TabsTrigger
            value="all"
            className="text-sm font-medium data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm transition-all duration-200"
          >
            すべて
            <span className="ml-1 text-xs bg-teal-100 text-teal-700 px-1.5 py-0.5 rounded-full">
              {activeCampaigns.length}
            </span>
          </TabsTrigger>
          <TabsTrigger
            value="eco"
            className="text-sm font-medium data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm transition-all duration-200"
          >
            <Leaf className="h-4 w-4 mr-1" />
            環境
            <span className="ml-1 text-xs bg-teal-100 text-teal-700 px-1.5 py-0.5 rounded-full">
              {ecoCampaigns.length}
            </span>
          </TabsTrigger>
          <TabsTrigger
            value="referral"
            className="text-sm font-medium data-[state=active]:bg-white data-[state=active]:text-teal-700 data-[state=active]:shadow-sm transition-all duration-200"
          >
            <Users className="h-4 w-4 mr-1" />
            招待
            <span className="ml-1 text-xs bg-teal-100 text-teal-700 px-1.5 py-0.5 rounded-full">
              {referralCampaigns.length}
            </span>
          </TabsTrigger>
        </TabsList>

        <TabsContent value="all" className="space-y-4 mt-4">
          {activeCampaigns.length === 0 ? (
            <EmptyState />
          ) : (
            activeCampaigns.map((campaign) => (
              <CampaignCard key={campaign.id} campaign={campaign} />
            ))
          )}
        </TabsContent>

        <TabsContent value="eco" className="space-y-4 mt-4">
          {ecoCampaigns.length === 0 ? (
            <EmptyState type="eco" />
          ) : (
            ecoCampaigns.map((campaign) => (
              <CampaignCard key={campaign.id} campaign={campaign} />
            ))
          )}
        </TabsContent>

        <TabsContent value="referral" className="space-y-4 mt-4">
          {referralCampaigns.length === 0 ? (
            <EmptyState type="referral" />
          ) : (
            referralCampaigns.map((campaign) => (
              <CampaignCard key={campaign.id} campaign={campaign} />
            ))
          )}
        </TabsContent>
      </Tabs>

      {/* おすすめキャンペーン */}
      <div className="mt-8 bg-gradient-to-r from-amber-50 to-amber-100 rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-lg font-semibold text-stone-800">
            おすすめキャンペーン
          </h3>
          <Badge className="bg-amber-600 text-white">期間限定</Badge>
        </div>
        <p className="text-sm text-stone-600 mb-3">
          今なら最大3倍のポイントが獲得できるキャンペーンを開催中！
        </p>
        <Button className="w-full bg-amber-600 hover:bg-amber-700 text-white">
          詳しく見る
          <ArrowRight className="h-4 w-4 ml-2" />
        </Button>
      </div>
    </PageContainer>
  );
}

// キャンペーンカードコンポーネント
function CampaignCard({ campaign }: { campaign: Campaign }) {
  // 残り日数を計算
  const endDate = new Date(campaign.endDate);
  const today = new Date();
  const diffTime = endDate.getTime() - today.getTime();
  const daysLeft = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  // 進捗率を計算
  const startDate = new Date(campaign.startDate);
  const totalDays = Math.ceil(
    (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24),
  );
  const passedDays = Math.ceil(
    (today.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24),
  );
  const progressPercent = Math.min(
    100,
    Math.max(0, (passedDays / totalDays) * 100),
  );

  // キャンペーンタイプに応じたアイコンを取得
  const getCampaignIcon = (type: string) => {
    switch (type) {
      case "eco":
        return <Leaf className="h-5 w-5 text-teal-600" />;
      case "point":
        return <Gift className="h-5 w-5 text-amber-500" />;
      case "referral":
        return <Users className="h-5 w-5 text-blue-500" />;
      default:
        return <Zap className="h-5 w-5 text-stone-500" />;
    }
  };

  // タイプに応じた背景色
  const getTypeColor = (type: string) => {
    switch (type) {
      case "eco":
        return "from-teal-700 to-teal-600";
      case "referral":
        return "from-blue-600 to-blue-500";
      case "point":
        return "from-amber-600 to-amber-500";
      default:
        return "from-stone-600 to-stone-500";
    }
  };

  return (
    <Card className="border border-stone-100 shadow-sm hover:shadow-md hover:border-stone-200 transition-all duration-200 overflow-hidden">
      <div className="flex">
        {/* 左側のタイプインジケーター */}
        <div
          className={`w-1.5 bg-gradient-to-b ${getTypeColor(campaign.type)}`}
        />

        <div className="flex-1">
          <div className="p-4">
            <div className="flex items-start justify-between mb-3">
              <div className="flex items-center gap-2">
                <div
                  className={`p-2 rounded-lg bg-gradient-to-br ${
                    campaign.type === "eco"
                      ? "from-teal-50 to-teal-100"
                      : campaign.type === "referral"
                        ? "from-blue-50 to-blue-100"
                        : "from-amber-50 to-amber-100"
                  }`}
                >
                  {getCampaignIcon(campaign.type)}
                </div>
                <div>
                  <h3 className="font-semibold text-stone-800 text-sm">
                    {campaign.title}
                  </h3>
                  {campaign.badgeText && (
                    <Badge
                      variant="secondary"
                      className="mt-1 text-xs bg-gradient-to-r from-amber-100 to-amber-200 text-amber-800 border-0"
                    >
                      {campaign.badgeText}
                    </Badge>
                  )}
                </div>
              </div>
              {campaign.isPopular && (
                <div className="bg-gradient-to-r from-amber-400 to-amber-500 text-white text-xs px-2 py-1 rounded-full flex items-center gap-1">
                  <Star className="h-3 w-3" />
                  人気
                </div>
              )}
            </div>

            <p className="text-sm text-stone-600 line-clamp-2 mb-3">
              {campaign.subtitle || campaign.description}
            </p>

            {/* 期間と残り日数 */}
            <div className="flex items-center gap-4 text-xs text-stone-500 mb-3">
              <div className="flex items-center">
                <Calendar className="h-3 w-3 mr-1" />
                <span>
                  {campaign.startDate} 〜 {campaign.endDate}
                </span>
              </div>
              <div className="flex items-center">
                <Clock className="h-3 w-3 mr-1" />
                <span
                  className={daysLeft <= 3 ? "text-red-600 font-medium" : ""}
                >
                  {daysLeft > 0 ? `残り${daysLeft}日` : "終了"}
                </span>
              </div>
            </div>

            {/* ポイント還元率 */}
            {campaign.pointRate && (
              <div className="bg-gradient-to-r from-amber-50 to-amber-100 border border-amber-200 rounded-lg p-2.5 mb-3">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Tag className="h-4 w-4 text-amber-600" />
                    <span className="text-sm font-medium text-amber-800">
                      ポイント還元率
                    </span>
                  </div>
                  <span className="text-lg font-bold text-amber-800">
                    {campaign.pointRate}%
                  </span>
                </div>
              </div>
            )}

            {/* 進捗バー */}
            <div className="mb-4">
              <div className="flex justify-between text-xs mb-1">
                <span className="text-stone-500">キャンペーン進行状況</span>
                <span className="text-stone-600 font-medium">
                  {Math.round(progressPercent)}%
                </span>
              </div>
              <div className="bg-stone-100 rounded-full h-2 overflow-hidden">
                <div
                  className={`h-full bg-gradient-to-r ${getTypeColor(campaign.type)} transition-all duration-500`}
                  style={{ width: `${progressPercent}%` }}
                />
              </div>
            </div>

            {/* アクションボタン */}
            <Link href={`/campaigns/${campaign.id}`}>
              <Button className="w-full bg-gradient-to-r from-teal-700 to-teal-600 hover:from-teal-800 hover:to-teal-700 text-white transition-all duration-200">
                詳細を見る
                <ChevronRight className="h-4 w-4 ml-2" />
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </Card>
  );
}

// 空状態コンポーネント
function EmptyState({ type }: { type?: string }) {
  const getEmptyMessage = () => {
    switch (type) {
      case "eco":
        return "現在、環境キャンペーンは開催されていません。";
      case "referral":
        return "現在、招待キャンペーンは開催されていません。";
      default:
        return "現在、開催中のキャンペーンはありません。";
    }
  };

  return (
    <div className="bg-stone-50 rounded-lg p-8 text-center">
      <div className="bg-stone-100 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4">
        <Zap className="h-8 w-8 text-stone-400" />
      </div>
      <p className="text-stone-600 text-sm mb-4">{getEmptyMessage()}</p>
      <p className="text-stone-500 text-xs">
        新しいキャンペーンが始まり次第、お知らせします。
      </p>
    </div>
  );
}
</file>

<file path="src/features/transactions/components/RecentTransactions/RecentTransactionsContainer.tsx">
"use client";

import { useState, useEffect, useMemo } from "react";
import { Transaction } from "@/shared/types/transaction";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import {
  getTransactionStyle,
  TransactionStyle,
} from "../../hooks/transactionStyling";
import { StyledTransaction } from "../TransactionItem";
import RecentTransactionsList from "./RecentTransactionsList";

interface RecentTransactionsContainerProps {
  limit?: number;
  showHeader?: boolean;
}

// トランザクション金額をフォーマットするヘルパー関数
const formatTransactionAmount = (amount: number): string => {
  const prefix = amount > 0 ? "+" : "";
  return `${prefix}${new Intl.NumberFormat("ja-JP").format(Math.abs(amount))}`;
};

// コンテナコンポーネント: データ取得とビジネスロジックを担当
export default function RecentTransactionsContainer({
  limit = 3,
  showHeader = true,
}: RecentTransactionsContainerProps) {
  // 取引データの状態管理
  const [transactions, setTransactions] = useState<Transaction[]>([]);

  // トランザクション取得関数をストアから取得
  const getRecentTransactions = useTransactionStore(
    (state) => state.getRecentTransactions,
  );

  // 各トランザクションタイプのスタイルを事前に計算
  const paymentStyle = getTransactionStyle("payment", []);
  const chargeStyle = getTransactionStyle("charge", []);
  const receiveStyle = getTransactionStyle("receive", []);
  const donationStyle = getTransactionStyle("donation", []);
  const expiredStyle = getTransactionStyle("expired", []);
  const receiveWithBonusStyle = getTransactionStyle("receive", ["特典"]);

  // トランザクションデータをフェッチ
  useEffect(() => {
    const recentTransactionsResult = getRecentTransactions(limit);
    const recentTransactions = recentTransactionsResult.isOk()
      ? recentTransactionsResult.value
      : [];
    setTransactions(recentTransactions);
  }, [getRecentTransactions, limit]);

  // スタイル適用済みトランザクションを生成（データとスタイルを結合）
  const styledTransactions: StyledTransaction[] = useMemo(() => {
    return transactions.map((tx) => {
      // トランザクションタイプとバッジに基づいてスタイルを取得するヘルパー関数
      let style: TransactionStyle;

      if (tx.type === "receive" && tx.badges?.includes("特典")) {
        style = receiveWithBonusStyle;
      } else {
        switch (tx.type) {
          case "payment":
            style = paymentStyle;
            break;
          case "charge":
            style = chargeStyle;
            break;
          case "receive":
            style = receiveStyle;
            break;
          case "donation":
            style = donationStyle;
            break;
          case "expired":
            style = expiredStyle;
            break;
          default:
            style = paymentStyle;
        }
      }

      const formattedAmount = formatTransactionAmount(tx.amount);

      return {
        transaction: tx,
        style,
        formattedAmount,
      };
    });
  }, [
    transactions,
    paymentStyle,
    chargeStyle,
    receiveStyle,
    donationStyle,
    expiredStyle,
    receiveWithBonusStyle,
  ]);

  // スタイリング済みのトランザクションデータをプレゼンテーションコンポーネントに渡す
  return (
    <RecentTransactionsList
      transactions={styledTransactions}
      showHeader={showHeader}
    />
  );
}
</file>

<file path="src/features/transactions/components/TransactionItem/TransactionItem.tsx">
"use client";

import React from "react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { Clock, Gift, Leaf, ChevronRight } from "lucide-react";
import { Transaction } from "@/shared/types/transaction";
import { TransactionStyle } from "../../hooks/transactionStyling";

// スタイル化されたトランザクションの型定義
export interface StyledTransaction {
  transaction: Transaction;
  style: TransactionStyle;
  formattedAmount: string;
}

interface TransactionItemProps {
  item: StyledTransaction;
}

// プレゼンテーションコンポーネント: 単純に個々のトランザクションUIを表示するのみ
const TransactionItem = React.memo(({ item }: TransactionItemProps) => {
  const { transaction, style, formattedAmount } = item;

  // 金額の色を決定
  const getAmountColorClass = () => {
    if (transaction.amount < 0) {
      return "text-stone-700";
    }
    if (
      transaction.type === "receive" ||
      transaction.badges?.includes("特典")
    ) {
      return "text-amber-600";
    }
    return "text-blue-600";
  };

  return (
    <Link href={`/history/${transaction.id}`} className="block group">
      <div className="bg-white rounded-lg border border-stone-100 hover:border-stone-200 hover:shadow-sm transition-all duration-200 p-4">
        <div className="flex items-center justify-between">
          {/* 左側：アイコンと情報 */}
          <div className="flex items-center space-x-3 flex-1">
            <div
              className={`w-10 h-10 rounded-full flex items-center justify-center ${style.bgColor} transition-transform duration-200 group-hover:scale-105`}
            >
              {style.icon}
            </div>
            <div className="flex-1 min-w-0">
              <h4 className="text-sm font-medium text-stone-900 truncate">
                {transaction.description}
              </h4>
              <div className="flex items-center gap-2 mt-0.5">
                <p className="text-xs text-stone-500">{transaction.date}</p>

                {/* バッジ表示 */}
                {transaction.ecoContribution?.enabled && (
                  <Badge className="bg-teal-50 text-teal-700 text-[10px] px-1.5 py-0 h-4 rounded-full border-0 hover:bg-teal-100">
                    <Leaf className="h-2.5 w-2.5 mr-0.5" />
                    環境
                  </Badge>
                )}
                {transaction.badges?.map((badge, index) => (
                  <Badge
                    key={index}
                    className={`${
                      badge === "特典"
                        ? "bg-amber-50 text-amber-700"
                        : badge === "期限切れ"
                          ? "bg-red-50 text-red-700"
                          : badge === "割り勘"
                            ? "bg-blue-50 text-blue-700"
                            : "bg-stone-50 text-stone-600"
                    } text-[10px] px-1.5 py-0 h-4 rounded-full border-0`}
                  >
                    {badge}
                  </Badge>
                ))}
              </div>
            </div>
          </div>

          {/* 右側：金額と矢印 */}
          <div className="flex items-center gap-2">
            <div className={`text-right ${getAmountColorClass()}`}>
              <p className="text-sm font-semibold">{formattedAmount}</p>
              {transaction.ecoContribution?.enabled && (
                <p className="text-[10px] text-teal-600 mt-0.5">
                  環境貢献 ¥{transaction.ecoContribution.amount}
                </p>
              )}
            </div>
            <ChevronRight className="h-4 w-4 text-stone-400 group-hover:text-stone-600 transition-colors" />
          </div>
        </div>

        {/* キャンペーン特典の詳細表示 */}
        {transaction.type === "receive" &&
          transaction.badges?.includes("特典") && (
            <div className="mt-3 ml-[52px] bg-amber-50 rounded-md p-2.5 border border-amber-200">
              <div className="flex items-center text-amber-700">
                <Gift className="h-3 w-3 mr-1.5" />
                <span className="text-xs font-medium">友達紹介プログラム</span>
              </div>
              <div className="flex items-center mt-1 text-amber-600">
                <Clock className="h-3 w-3 mr-1.5" />
                <span className="text-[11px]">有効期限: 2025/04/30</span>
              </div>
            </div>
          )}

        {/* 期限切れの詳細表示 */}
        {transaction.type === "expired" && (
          <div className="mt-3 ml-[52px] bg-red-50 rounded-md p-2.5 border border-red-200">
            <div className="flex items-center text-red-700">
              <Clock className="h-3 w-3 mr-1.5" />
              <span className="text-xs">
                エコポイントの残高が期限切れになりました
              </span>
            </div>
          </div>
        )}
      </div>
    </Link>
  );
});

TransactionItem.displayName = "TransactionItem";

export default TransactionItem;
</file>

<file path="src/features/transactions/index.ts">
// 型定義のエクスポート
export * from "./types/receipt";

// ストアのエクスポート
export { useTransactionStore } from "./store/transaction.slice";
export type { TransactionSlice } from "./store/transaction.slice";

// フックのエクスポート
export { getTransactionStyle } from "./hooks/transactionStyling";
export type { TransactionStyle } from "./hooks/transactionStyling";

// コンポーネントのエクスポート
export { TransactionItem } from "./components/TransactionItem";
export type { StyledTransaction } from "./components/TransactionItem";
export {
  RecentTransactionsContainer,
  RecentTransactionsList,
} from "./components/RecentTransactions";
export {
  TransactionDetailContainer,
  TransactionDetailView,
  TransactionHeader,
  TransactionInfo,
  TransactionEcoInfo,
  ActionButtons,
  ReceiptDialog,
} from "./components/TransactionDetail";
export { TransactionDetailSection } from "./components/TransactionDetailSection";
export { TransactionFilters } from "./components/TransactionFilters";
export { TransactionList } from "./components/TransactionList";
</file>

<file path="src/lib/mock-data/transactions.ts">
/**
 * このファイルは後方互換性のために存在します。
 * 新しいコードでは以下の直接インポートを推奨します：
 * - 型定義: @/types/transaction
 * - モックデータ: @/lib/mock-data/transactions-data
 */

// 型定義をリエクスポート
export type { Transaction, TransactionType } from "@/shared/types/transaction";

// モックデータをリエクスポート
export { transactionsData } from "@/features/transactions/data/transactions-data";
</file>

<file path="package.json">
{
  "name": "eco-wallet",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "build": "next build",
    "dev": "next dev --turbopack",
    "lint": "next lint",
    "prepare": "husky",
    "start": "next start",
    "test": "vitest",
    "test:run": "vitest run",
    "debug": "NODE_OPTIONS='--inspect=3000' next dev"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.0.1",
    "@radix-ui/react-avatar": "^1.1.7",
    "@radix-ui/react-checkbox": "^1.2.2",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-popover": "^1.1.13",
    "@radix-ui/react-progress": "^1.1.4",
    "@radix-ui/react-radio-group": "^1.3.3",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-separator": "^1.1.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.8",
    "@tanstack/react-query": "^5.74.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.501.0",
    "neverthrow": "^8.2.0",
    "next": "15.3.1",
    "next-auth": "^4.24.11",
    "react": "^19.0.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.56.0",
    "react-qr-code": "^2.0.15",
    "tailwind-merge": "^3.2.0",
    "zod": "^3.24.3",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "husky": "^8.0.0",
    "jsdom": "^26.1.0",
    "lint-staged": "^15.5.1",
    "prettier": "^3.5.3",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.2.7",
    "typescript": "^5",
    "vitest": "^3.1.1"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild",
      "sharp",
      "unrs-resolver"
    ]
  },
  "volta": {
    "node": "22.15.0"
  }
}
</file>

<file path="src/app/campaigns/[id]/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { PageContainer } from "@/features/layout";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import {
  Leaf,
  Calendar,
  Tag,
  Info,
  ChevronRight,
  ArrowLeft,
  TreePine,
  Droplets,
  Globe,
  Users,
  Gift,
} from "lucide-react";
import { useCampaignStore } from "@/features/campaigns/store/campaign.slice";
import { Campaign } from "@/features/campaigns/types/campaign";

import { calculateDateDifference } from "@/shared/utils/formats";
import { calculateProgressPercent } from "@/lib/utils/eco";

export default function CampaignDetailPage() {
  const params = useParams();
  const router = useRouter();
  const campaignId = params.id as string;

  // キャンペーンストアからデータを取得
  const getCampaignById = useCampaignStore((state) => state.getCampaignById);
  const [campaign, setCampaign] = useState<Campaign | null>(null);
  const [loading, setLoading] = useState(true);
  const [daysLeft, setDaysLeft] = useState<number>(0);
  const [progressPercent, setProgressPercent] = useState<number>(0);

  useEffect(() => {
    // キャンペーンデータの取得をシミュレート
    const fetchData = async () => {
      setLoading(true);

      try {
        // 実際のAPIリクエストの代わりにモックデータを使用
        await new Promise((resolve) => setTimeout(resolve, 300)); // 遅延を追加

        const data = getCampaignById(campaignId);
        if (data) {
          setCampaign(data);

          // 残り日数を計算 - ユーティリティ関数を使用
          const diffDays = calculateDateDifference(data.endDate);
          setDaysLeft(diffDays > 0 ? diffDays : 0);

          // 進捗率を計算 - ユーティリティ関数を使用
          const totalDays = calculateDateDifference(
            data.endDate,
            data.startDate,
          );
          const passedDays = calculateDateDifference(
            new Date(),
            data.startDate,
          );
          const progress = calculateProgressPercent(passedDays, totalDays);
          setProgressPercent(progress);
        }
      } catch (error) {
        console.error("Failed to fetch campaign:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [campaignId, getCampaignById]);

  // キャンペーンタイプに応じたアイコンを取得
  const getCampaignIcon = (type: string) => {
    switch (type) {
      case "eco":
        return <Leaf className="h-6 w-6 text-teal-600" />;
      case "point":
        return <Gift className="h-6 w-6 text-amber-500" />;
      case "referral":
        return <Users className="h-6 w-6 text-blue-500" />;
      default:
        return <Info className="h-6 w-6 text-stone-500" />;
    }
  };

  if (loading) {
    return (
      <PageContainer title="キャンペーン詳細">
        <div className="flex justify-center items-center h-40">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-teal-700"></div>
        </div>
      </PageContainer>
    );
  }

  if (!campaign) {
    return (
      <PageContainer title="キャンペーン詳細">
        <div className="text-center py-8">
          <h2 className="text-lg font-medium text-stone-800">
            キャンペーンが見つかりませんでした
          </h2>
          <p className="text-sm text-stone-600 mt-2">
            このキャンペーンは終了したか、存在しません。
          </p>
          <Button
            className="mt-4 bg-teal-700 hover:bg-teal-800 text-white"
            onClick={() => router.push("/campaigns")}
          >
            キャンペーン一覧に戻る
          </Button>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer title="キャンペーン詳細">
      <div className="mb-4">
        <Button
          variant="ghost"
          size="sm"
          className="text-stone-600"
          onClick={() => router.back()}
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          戻る
        </Button>
      </div>

      <Card className="border-0 shadow-md bg-white overflow-hidden">
        {/* キャンペーンヘッダー */}
        <div className="bg-gradient-to-r from-amber-600 to-amber-400 p-6 text-white">
          <div className="flex items-center">
            <div className="bg-white/20 p-2 rounded-full mr-3">
              {getCampaignIcon(campaign.type)}
            </div>
            <div>
              <h1 className="text-xl font-semibold">{campaign.title}</h1>
              <p className="text-sm opacity-90">{campaign.subtitle}</p>
            </div>
          </div>

          <div className="mt-4 flex justify-between items-center">
            <div className="flex items-center">
              <Calendar className="h-4 w-4 mr-1" />
              <span className="text-xs">
                {campaign.startDate} 〜 {campaign.endDate}
              </span>
            </div>
            {campaign.badgeText && (
              <Badge className="bg-white text-amber-600">
                {campaign.badgeText}
              </Badge>
            )}
          </div>

          {/* 期間プログレスバー */}
          <div className="mt-3">
            <div className="flex justify-between text-xs mb-1">
              <span>キャンペーン進行状況</span>
              <span>{daysLeft > 0 ? `残り${daysLeft}日` : "終了"}</span>
            </div>
            <Progress value={progressPercent} className="bg-white/30" />
          </div>
        </div>

        {/* キャンペーン詳細 */}
        <div className="p-6 space-y-6">
          {/* 概要 */}
          <div>
            <h2 className="text-lg font-medium text-stone-800 mb-2">
              キャンペーン概要
            </h2>
            <p className="text-sm text-stone-600">{campaign.description}</p>
          </div>

          <Separator />

          {/* 特典内容 */}
          <div>
            <h2 className="text-lg font-medium text-stone-800 mb-2">
              特典内容
            </h2>
            {campaign.pointRate && (
              <div className="bg-amber-50 p-4 rounded-md border border-amber-100 mb-3">
                <div className="flex items-center text-amber-800">
                  <Tag className="h-5 w-5 mr-2" />
                  <span className="text-lg font-bold">
                    {campaign.pointRate}%ポイント還元
                  </span>
                </div>
              </div>
            )}
            <p className="text-sm text-stone-600">
              {campaign.benefitDescription}
            </p>
          </div>

          {/* 適用条件 */}
          <div>
            <h2 className="text-lg font-medium text-stone-800 mb-2">
              適用条件
            </h2>
            <ul className="space-y-2">
              {campaign.conditions.map((condition, index) => (
                <li key={index} className="flex items-start">
                  <div className="w-5 h-5 bg-amber-100 rounded-full flex items-center justify-center text-xs text-amber-800 mr-2 mt-0.5">
                    {index + 1}
                  </div>
                  <p className="text-sm text-stone-600">{condition}</p>
                </li>
              ))}
            </ul>
          </div>

          {/* 参加方法 */}
          {campaign.steps && (
            <>
              <Separator />
              <div>
                <h2 className="text-lg font-medium text-stone-800 mb-2">
                  参加方法
                </h2>
                <div className="space-y-3">
                  {campaign.steps.map((step, index) => (
                    <div key={index} className="flex items-center">
                      <div className="w-6 h-6 bg-teal-100 rounded-full flex items-center justify-center text-xs text-teal-800 mr-3">
                        {index + 1}
                      </div>
                      <p className="text-sm text-stone-700">{step}</p>
                    </div>
                  ))}
                </div>
              </div>
            </>
          )}

          {/* 環境貢献情報 */}
          {campaign.ecoImpact && (
            <>
              <Separator />
              <div>
                <h2 className="text-lg font-medium text-stone-800 mb-2">
                  {campaign.ecoImpact.title}
                </h2>
                <div className="bg-teal-50 p-4 rounded-md border border-teal-100">
                  <p className="text-sm text-teal-700 mb-3">
                    {campaign.ecoImpact.description}
                  </p>

                  {campaign.ecoImpact.metrics && (
                    <div className="grid grid-cols-2 gap-3">
                      {campaign.ecoImpact.metrics.map((metric, index) => (
                        <div
                          key={index}
                          className="bg-white bg-opacity-60 p-3 rounded-md"
                        >
                          <div className="flex items-center mb-1">
                            {metric.icon === "tree" && (
                              <TreePine className="h-4 w-4 text-teal-600 mr-1" />
                            )}
                            {metric.icon === "water" && (
                              <Droplets className="h-4 w-4 text-blue-500 mr-1" />
                            )}
                            {metric.icon === "globe" && (
                              <Globe className="h-4 w-4 text-green-600 mr-1" />
                            )}
                            <span className="text-xs text-stone-600">
                              {metric.label}
                            </span>
                          </div>
                          <p className="text-sm font-medium text-teal-700">
                            {metric.value}
                          </p>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </>
          )}

          {/* 関連商品 */}
          {campaign.relatedItems && campaign.relatedItems.length > 0 && (
            <>
              <Separator />
              <div>
                <h2 className="text-lg font-medium text-stone-800 mb-2">
                  関連商品
                </h2>
                <div className="space-y-3">
                  {campaign.relatedItems.map((item, index) => (
                    <div
                      key={index}
                      className="border border-stone-200 p-3 rounded-md"
                    >
                      <h3 className="text-sm font-medium text-stone-800">
                        {item.title}
                      </h3>
                      <p className="text-xs text-stone-600 mt-1">
                        {item.description}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            </>
          )}

          {/* アクションボタン */}
          <div className="mt-6">
            <Button className="w-full bg-teal-700 hover:bg-teal-800 text-white">
              キャンペーンに参加する
            </Button>
            {campaign.type === "referral" && (
              <Button
                variant="outline"
                className="w-full mt-3 border-amber-200 text-amber-700 hover:bg-amber-50"
                onClick={() => router.push("/invite")}
              >
                友達を招待する
                <ChevronRight className="h-4 w-4 ml-1" />
              </Button>
            )}
          </div>
        </div>
      </Card>
    </PageContainer>
  );
}
</file>

<file path="src/app/payment/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { CheckCircle, Leaf, ArrowLeft } from "lucide-react";
import { ErrorDisplay } from "@/components/ui/error-display";
import {
  usePaymentStore,
  ProductInfo,
  PaymentSummary,
  PaymentMethodSelectorContainer,
  PaymentOptionsComponent,
  mockProducts,
  mockPaymentMethods,
  defaultPaymentOptions,
} from "@/features/payment";
import { processPayment } from "@/lib/business/payment";
import type { ProcessPaymentParams } from "@/lib/business/payment";
import type { AppError } from "@/shared/types/errors";
import { showAppErrorNotification } from "@/shared/stores/app.slice";

export default function PaymentPage() {
  const router = useRouter();
  const {
    paymentInfo,
    setPaymentInfo,
    setPaymentMethod,
    setPaymentOptions,
    resetPayment,
  } = usePaymentStore();

  // Result型対応のstate
  const [error, setError] = useState<AppError | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [transactionId, setTransactionId] = useState<string | null>(null);

  // 初期化
  useEffect(() => {
    // デモ用に最初の商品を使用
    const product = mockProducts[0];
    const donationAmount = defaultPaymentOptions.donationAmount;

    setPaymentInfo({
      product,
      subtotal: product.price,
      donationAmount,
      total: product.price + donationAmount,
      selectedPaymentMethod: "wallet",
      options: defaultPaymentOptions,
    });

    // クリーンアップ
    return () => {
      resetPayment();
      setError(null);
      setIsProcessing(false);
      setIsSuccess(false);
      setTransactionId(null);
    };
  }, [setPaymentInfo, resetPayment]);

  // キャンセルボタンのクリックハンドラー
  const handleCancel = () => {
    if (!isProcessing) {
      router.back();
    }
  };

  // 決済確定ボタンのクリックハンドラー（Result型対応版）
  const handleConfirmPayment = async () => {
    if (!paymentInfo) return;

    // エラーとフラグをリセット
    setError(null);
    setIsProcessing(true);

    try {
      // 決済方法をProcessPaymentParamsの形式にマッピング
      let paymentMethod: ProcessPaymentParams["paymentMethod"];
      switch (paymentInfo.selectedPaymentMethod) {
        case "card":
          paymentMethod = "credit_card";
          break;
        case "bank":
          paymentMethod = "bank_transfer";
          break;
        case "wallet":
          paymentMethod = "bank_transfer"; // walletはbank_transferとして処理
          break;
        default:
          paymentMethod = "credit_card"; // デフォルト
      }

      // 決済パラメータの作成
      const paymentParams: ProcessPaymentParams = {
        amount: paymentInfo.total,
        paymentMethod,
        description: `${paymentInfo.product.name}の購入`,
        metadata: {
          productId: paymentInfo.product.id,
          productName: paymentInfo.product.name,
          donationAmount: paymentInfo.donationAmount,
          includeDonation: paymentInfo.options.includeDonation,
        },
      };

      // ビジネスロジック層のprocessPayment関数を呼び出し
      const result = await processPayment(paymentParams);

      // .match()パターンで成功・失敗を明示的に処理
      result.match(
        (paymentState) => {
          // 成功時の処理
          setTransactionId(paymentState.transactionId);
          setIsSuccess(true);

          // 成功表示を少し見せた後に遷移
          setTimeout(() => {
            router.push(`/history/${paymentState.transactionId}`);
          }, 1000);
        },
        (paymentError) => {
          // 失敗時の処理
          setError(paymentError);
          showAppErrorNotification(paymentError, "決済エラー");
        },
      );
    } catch (unexpectedError) {
      // 予期しないエラーの処理
      const errorToSet: AppError = {
        type: "PAYMENT_FAILED",
        message: "決済処理中に予期しないエラーが発生しました",
        reason: String(unexpectedError),
        paymentId: undefined,
      };
      setError(errorToSet);
      showAppErrorNotification(errorToSet, "決済エラー");
    } finally {
      setIsProcessing(false);
    }
  };

  if (!paymentInfo) {
    return null; // 初期化中
  }

  return (
    <div className="min-h-screen bg-stone-50 pt-16 pb-8 px-4">
      {/* ヘッダー */}
      <div className="max-w-md mx-auto mb-6">
        <Button
          variant="ghost"
          size="sm"
          onClick={handleCancel}
          className="mb-4 -ml-2 text-stone-600 hover:text-stone-800"
          disabled={isProcessing || isSuccess}
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          戻る
        </Button>

        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-stone-800 mb-2">決済確認</h1>
          <p className="text-sm text-stone-600">
            購入内容をご確認の上、決済を行ってください
          </p>
        </div>
      </div>

      <div className="max-w-md mx-auto space-y-4">
        {/* エラー表示 */}
        {error && (
          <ErrorDisplay error={error} variant="inline" className="mb-4" />
        )}

        {/* 成功メッセージ */}
        {isSuccess && (
          <Card className="border-0 shadow-sm bg-gradient-to-r from-teal-50 to-green-50">
            <CardContent className="flex items-center p-6">
              <div className="bg-teal-100 rounded-full p-3 mr-4">
                <CheckCircle className="h-8 w-8 text-teal-600" />
              </div>
              <div>
                <h3 className="text-lg font-semibold text-teal-800">
                  決済が完了しました
                </h3>
                <p className="text-sm text-teal-700 mt-1">
                  取引履歴に移動しています...
                </p>
                {transactionId && (
                  <p className="text-xs text-teal-600 mt-2">
                    取引ID: {transactionId}
                  </p>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {!isSuccess && (
          <>
            {/* 商品情報カード */}
            <Card className="border border-stone-100 shadow-sm hover:shadow-md transition-shadow duration-200">
              <CardHeader className="pb-3">
                <CardTitle className="text-base font-semibold text-stone-800">
                  購入商品
                </CardTitle>
              </CardHeader>
              <CardContent>
                <ProductInfo product={paymentInfo.product} />

                {paymentInfo.product.isEcoFriendly &&
                  paymentInfo.product.ecoDescription && (
                    <div className="mt-4 bg-teal-50 border border-teal-100 rounded-lg p-3">
                      <div className="flex items-start">
                        <Leaf className="h-4 w-4 text-teal-600 mr-2 mt-0.5 flex-shrink-0" />
                        <p className="text-xs text-teal-700">
                          {paymentInfo.product.ecoDescription}
                        </p>
                      </div>
                    </div>
                  )}
              </CardContent>
            </Card>

            {/* 支払い方法カード */}
            <Card className="border border-stone-100 shadow-sm hover:shadow-md transition-shadow duration-200">
              <CardHeader className="pb-3">
                <CardTitle className="text-base font-semibold text-stone-800">
                  支払い方法
                </CardTitle>
              </CardHeader>
              <CardContent>
                <PaymentMethodSelectorContainer
                  methods={mockPaymentMethods}
                  selectedMethod={paymentInfo.selectedPaymentMethod}
                  onMethodChange={setPaymentMethod}
                  paymentAmount={paymentInfo.total}
                />
              </CardContent>
            </Card>

            {/* 環境オプションカード */}
            <Card className="border border-stone-100 shadow-sm hover:shadow-md transition-shadow duration-200">
              <CardHeader className="pb-3">
                <CardTitle className="text-base font-semibold text-stone-800 flex items-center">
                  <Leaf className="h-4 w-4 text-teal-600 mr-2" />
                  環境への貢献
                </CardTitle>
              </CardHeader>
              <CardContent>
                <PaymentOptionsComponent
                  options={paymentInfo.options}
                  onOptionsChange={setPaymentOptions}
                />
              </CardContent>
            </Card>

            {/* 決済サマリーカード */}
            <Card className="border border-stone-100 shadow-sm">
              <CardHeader className="pb-3">
                <CardTitle className="text-base font-semibold text-stone-800">
                  お支払い金額
                </CardTitle>
              </CardHeader>
              <CardContent>
                <PaymentSummary
                  subtotal={paymentInfo.subtotal}
                  donationAmount={paymentInfo.donationAmount}
                  total={paymentInfo.total}
                  showDonation={paymentInfo.options.includeDonation}
                />
              </CardContent>
            </Card>
          </>
        )}

        {/* 決済ボタン */}
        <div className="space-y-3 pt-2">
          <Button
            className="w-full bg-teal-600 hover:bg-teal-700 text-white h-12 text-base font-medium shadow-sm transition-all duration-200"
            onClick={handleConfirmPayment}
            disabled={isProcessing || isSuccess}
          >
            {isProcessing ? (
              <>
                <LoadingSpinner size="sm" light className="mr-2" />
                決済処理中...
              </>
            ) : (
              <>
                決済を確定する
                <span className="ml-2 text-sm font-normal">
                  (¥{paymentInfo?.total.toLocaleString()})
                </span>
              </>
            )}
          </Button>

          {!isSuccess && (
            <p className="text-xs text-center text-stone-500">
              決済を確定すると、売上の1%が環境保護団体に寄付されます
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/transfer/page.tsx">
import { TransferSplitPage } from "@/features/transfer";

export default function TransferPage() {
  return <TransferSplitPage />;
}
</file>

<file path="src/features/transactions/components/TransactionDetail/TransactionDetailContainer.tsx">
"use client";

import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { useEcoImpactStore } from "@/features/eco-impact/store/eco-impact.slice";
import {
  ReceiptItem,
  useTransactionStore,
  getTransactionStyle,
} from "@/features/transactions";
import { Transaction } from "@/shared/types/transaction";
import { useFormattedCurrency } from "@/shared/hooks/useFormattedCurrency";
import { TransactionDetailView } from "./TransactionDetailView";
import { TransactionHeader } from "./TransactionHeader";
import { TransactionInfo } from "./TransactionInfo";
import { TransactionEcoInfo } from "./TransactionEcoInfo";
import { ActionButtons } from "./ActionButtons";
import { ReceiptDialog } from "./ReceiptDialog";

/**
 * トランザクション詳細のコンテナコンポーネント
 *
 * データの取得や状態管理、ビジネスロジックの処理を担当
 */
export function TransactionDetailContainer() {
  const params = useParams();
  const router = useRouter();
  const transactionId = params.id as string;

  // トランザクションストアから取引データを取得
  const getTransactionById = useTransactionStore(
    (state) => state.getTransactionById,
  );

  // 状態管理
  const [transaction, setTransaction] = useState<Transaction | null>(null);
  const [loading, setLoading] = useState(true);
  const [showReceipt, setShowReceipt] = useState(false);

  // 環境貢献データを取得
  const forestArea = useEcoImpactStore((state) => state.forestArea);
  const co2Reduction = useEcoImpactStore((state) => state.co2Reduction);

  // データ取得
  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);

      try {
        // 実際のAPIリクエストの代わりにモックデータを使用
        await new Promise((resolve) => setTimeout(resolve, 500)); // 遅延を追加

        const dataResult = getTransactionById(transactionId);
        if (dataResult.isOk()) {
          setTransaction(dataResult.value);
        }
      } catch (error) {
        console.error("Failed to fetch transaction:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [transactionId, getTransactionById]);

  // スタイルとフォーマットを設定
  const style = getTransactionStyle(
    transaction?.type || "payment",
    transaction?.badges || [],
  );

  const formattedAmount = useFormattedCurrency(transaction?.amount || 0, {
    withPlus: true,
    withSymbol: false,
  });

  // レシートアイテムの生成
  const getReceiptItems = (): ReceiptItem[] => {
    if (transaction?.type === "payment") {
      return [
        {
          name: transaction.description,
          quantity: 1,
          price: Math.abs(transaction.amount),
          isEco: transaction.badges?.includes("環境貢献") || false,
        },
      ];
    }
    return [];
  };

  // イベントハンドラー
  const handleDownloadReceipt = () => {
    console.log("レシートをダウンロード");
  };

  const handleShareReceipt = () => {
    if (navigator.share) {
      navigator
        .share({
          title: `${transaction?.description || "取引"}のレシート`,
          text: `${transaction?.date || ""}の取引レシート`,
          url: window.location.href,
        })
        .catch((err) => {
          // ユーザーがキャンセルした場合は何もしない（正常な動作）
          if (err.name === "AbortError" || err.message === "Share canceled") {
            return;
          }
          // その他のエラーの場合のみログ出力
          console.error("共有に失敗しました:", err);
        });
    } else {
      navigator.clipboard
        .writeText(window.location.href)
        .then(() => console.log("URLをクリップボードにコピーしました"))
        .catch((err) => console.error("コピーに失敗しました:", err));
    }
  };

  const handleBackToHistory = () => {
    router.push("/history");
  };

  const handleShowEcoImpactDetails = () => {
    router.push("/impact");
  };

  // サブコンポーネントのレンダリング関数
  const renderHeader = (
    transaction: Transaction | null,
    style?: ReturnType<typeof getTransactionStyle>,
  ) => {
    if (!transaction) return null;
    return (
      <TransactionHeader
        description={transaction.description}
        date={transaction.date}
        badges={transaction.badges}
        ecoEnabled={transaction.ecoContribution?.enabled}
        style={style}
        onBack={handleBackToHistory}
      />
    );
  };

  const renderInfo = (
    transaction: Transaction | null,
    formattedAmount: string,
    style?: ReturnType<typeof getTransactionStyle>,
  ) => {
    if (!transaction) return null;
    return (
      <TransactionInfo
        transactionId={transactionId}
        type={transaction.type}
        date={transaction.date}
        badges={transaction.badges}
        ecoContribution={transaction.ecoContribution}
        formattedAmount={formattedAmount}
        textColor={style?.textColor || "text-stone-800"}
      />
    );
  };

  const renderActionButtons = () => {
    return (
      <ActionButtons
        onShowReceipt={() => setShowReceipt(true)}
        onShare={handleShareReceipt}
      />
    );
  };

  const renderEcoInfo = (forestArea: number, co2Reduction: number) => {
    return (
      <TransactionEcoInfo
        forestArea={forestArea}
        co2Reduction={co2Reduction}
        onViewDetails={handleShowEcoImpactDetails}
      />
    );
  };

  const renderReceiptDialog = () => {
    if (!transaction) return null;
    return (
      <ReceiptDialog
        open={showReceipt}
        onOpenChange={setShowReceipt}
        transactionId={transactionId}
        date={transaction.date}
        items={getReceiptItems()}
        total={Math.abs(transaction.amount)}
        ecoContribution={transaction.ecoContribution}
        receiptSavings={{
          paperSaved: "約5g",
          co2Reduction: "約10g",
        }}
        onDownload={handleDownloadReceipt}
        onShare={handleShareReceipt}
      />
    );
  };

  return (
    <TransactionDetailView
      transaction={transaction}
      loading={loading}
      showReceipt={showReceipt}
      setShowReceipt={setShowReceipt}
      style={style}
      formattedAmount={formattedAmount}
      forestArea={forestArea}
      co2Reduction={co2Reduction}
      receiptItems={getReceiptItems()}
      transactionId={transactionId}
      onBackToHistory={handleBackToHistory}
      onShowEcoImpactDetails={handleShowEcoImpactDetails}
      onDownloadReceipt={handleDownloadReceipt}
      onShareReceipt={handleShareReceipt}
      // レンダリング関数
      renderHeader={renderHeader}
      renderInfo={renderInfo}
      renderActionButtons={renderActionButtons}
      renderEcoInfo={renderEcoInfo}
      renderReceiptDialog={renderReceiptDialog}
    />
  );
}
</file>

<file path="src/app/history/[id]/page.tsx">
// ブリッジファイル: このファイルは下位互換性のために維持されています
// 新しいバーティカルスライスアーキテクチャのコンポーネントを使用

import { TransactionDetailContainer } from "@/features/transactions";

export default function TransactionDetailPage() {
  return <TransactionDetailContainer />;
}
</file>

<file path="src/app/page.tsx">
"use client";

import Link from "next/link";
import { BalanceCardContainer } from "@/features/balance";
import { EcoImpactDisplay } from "@/features/eco-impact";
import { InviteCard } from "@/features/invite";
import { PageContainer } from "@/features/layout";
import { RecentTransactionsContainer } from "@/features/transactions";
import { recommendedActions } from "@/features/eco-impact/data/recommended-actions-data";
import { FeaturedCampaignSection } from "@/features/campaigns";
import { RecommendedAction } from "@/features/eco-impact";

export default function DashboardPage() {
  const contributionAmount = 1500;

  return (
    <PageContainer>
      {/* ヘッダー部分のグリーティング */}
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-stone-800">こんにちは！</h1>
        <p className="text-sm text-stone-600 mt-1">
          今日も環境に優しい一日を過ごしましょう
        </p>
      </div>

      {/* 残高カード */}
      <div className="mb-6">
        <BalanceCardContainer />
      </div>

      {/* 環境インパクトサマリー */}
      <div className="mb-6 bg-white rounded-lg border border-stone-100 p-4 shadow-sm hover:shadow-md transition-shadow duration-200">
        <EcoImpactDisplay
          contributionAmount={contributionAmount}
          variant="detailed"
          className="border-0 shadow-none"
        />
      </div>

      {/* キャンペーン情報 */}
      <div className="mb-6">
        <FeaturedCampaignSection />
      </div>

      {/* おすすめアクション */}
      {recommendedActions.length > 0 && (
        <div className="mb-6">
          <h2 className="text-lg font-semibold text-stone-800 mb-3">
            今週のおすすめアクション
          </h2>
          <RecommendedAction actionId={recommendedActions[0].id} />
        </div>
      )}

      {/* 友達招待カード */}
      <div className="mb-6">
        <InviteCard />
      </div>

      {/* 最近の取引 */}
      <div className="mb-6">
        <div className="flex justify-between items-center mb-3">
          <h2 className="text-lg font-semibold text-stone-800">最近の取引</h2>
          <Link
            href="/history"
            className="text-sm text-teal-600 hover:text-teal-700 font-medium transition-colors duration-200"
          >
            すべて見る →
          </Link>
        </div>
        <RecentTransactionsContainer />
      </div>
    </PageContainer>
  );
}
</file>

<file path="src/app/donate/[id]/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useParams, useRouter } from "next/navigation";
import { Card } from "@/components/ui/card";
import { PageContainer } from "@/features/layout";
import { DonateConfirm } from "@/features/donation/components/DonateConfirm";
import { DonateComplete } from "@/features/donation/components/DonateComplete";
import { DonateInputContainer } from "@/features/donation/components/DonateInput";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { useBalanceStore } from "@/features/balance/store/balance.slice";
import { useEcoImpactStore } from "@/features/eco-impact/store/eco-impact.slice";
import { useSession } from "next-auth/react";
import { newsAndProjects, ProjectItem } from "@/features/eco-news";
import { convertProjectItemToDonationProject } from "@/features/donation/utils/project-converter";
import { DonationProject } from "@/features/donation/types/donation";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertTriangle } from "lucide-react";
import { AppError } from "@/shared/types/errors";
import { showAppErrorNotification } from "@/shared/stores/app.slice";

type DonateStep = "input" | "confirm" | "complete";

export default function DonateProjectPage() {
  const router = useRouter();
  const params = useParams();
  const projectId = params.id as string;
  const { data: session, update } = useSession();

  const addTransaction = useTransactionStore((state) => state.addTransaction);
  const subtractFromRegularBalance = useBalanceStore(
    (state) => state.subtractFromRegularBalance,
  );
  const addContribution = useEcoImpactStore((state) => state.addContribution);

  // 基本状態
  const [currentStep, setCurrentStep] = useState<DonateStep>("input");
  const [amount, setAmount] = useState<string>("");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<AppError | null>(null);
  const [transactionId, setTransactionId] = useState<string>("");
  const [project, setProject] = useState<DonationProject | null>(null);

  // プロジェクト情報を取得
  useEffect(() => {
    const projectData = newsAndProjects.find(
      (item) => item.id === projectId && item.type === "project",
    ) as ProjectItem | undefined;

    if (projectData) {
      const donationProject = convertProjectItemToDonationProject(projectData);
      setProject(donationProject);
    } else {
      setProject(null);
    }
  }, [projectId]);

  // 入力ステップに戻る
  const handleBackToInput = () => {
    setCurrentStep("input");
  };

  // 寄付処理
  const handleConfirmDonation = async () => {
    if (!project) return;

    setIsLoading(true);
    setError(null);

    try {
      // モック処理として遅延を入れる
      await new Promise((resolve) => setTimeout(resolve, 1500));

      const donationAmount = Number(amount);

      // 1. 新しいトランザクションを作成（donation タイプ）
      const transactionResult = addTransaction({
        type: "donation",
        description: project.title,
        date: new Date()
          .toLocaleDateString("ja-JP", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          })
          .replace(/\//g, "/"),
        amount: -donationAmount,
        ecoContribution: {
          enabled: true,
          amount: donationAmount,
        },
      });

      if (transactionResult.isErr()) {
        throw new Error(transactionResult.error.message);
      }

      setTransactionId(transactionResult.value);

      // 2. ユーザーの残高を更新
      subtractFromRegularBalance(donationAmount);

      // 3. 環境貢献情報を更新
      addContribution({
        amount: donationAmount,
        // プロジェクトタイプに応じた環境貢献データ
        forestArea:
          project.imageType === "mountain"
            ? donationAmount * 0.0007
            : project.imageType === "ocean"
              ? donationAmount * 0.0003
              : donationAmount * 0.0005,
        waterSaved:
          project.imageType === "ocean"
            ? donationAmount * 0.4
            : donationAmount * 0.2,
        co2Reduction: donationAmount * 0.015,
      });

      // 4. セッションの残高を更新 (モック)
      if (session?.user) {
        const newBalance = (session.user.balance || 0) - donationAmount;
        await update({ balance: newBalance });
      }

      setCurrentStep("complete");
    } catch (error) {
      console.error("寄付処理中にエラーが発生しました", error);
      const donationError: AppError = {
        type: "NETWORK_ERROR",
        message:
          "処理中にエラーが発生しました。時間をおいて再度お試しください。",
      };
      setError(donationError);
      showAppErrorNotification(donationError, "寄付エラー");
    } finally {
      setIsLoading(false);
    }
  };

  // プロジェクトが見つからない場合のエラー表示
  if (!project) {
    return (
      <PageContainer title="プロジェクト寄付" activeTab="eco">
        <div className="space-y-6">
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              指定されたプロジェクトが見つかりませんでした。
            </AlertDescription>
          </Alert>
          <Card className="border-0 shadow-md bg-white p-6 text-center">
            <p className="text-sm text-stone-700 mb-4">
              お探しのプロジェクトは存在しないか、削除された可能性があります。
            </p>
            <button
              className="bg-teal-700 hover:bg-teal-800 text-white px-4 py-2 rounded-md text-sm"
              onClick={() => router.push("/eco-news")}
            >
              プロジェクト一覧に戻る
            </button>
          </Card>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer title={`${project.title}への寄付`} activeTab="eco">
      <div className="space-y-6">
        <h2 className="text-xl font-semibold text-stone-800">
          {project.title}への寄付
        </h2>
        <Card className="border-0 shadow-md bg-white">
          {currentStep === "input" && (
            <DonateInputContainer
              project={project}
              onProceed={(donationAmount: number) => {
                setAmount(donationAmount.toString());
                setError(null);
                setCurrentStep("confirm");
              }}
            />
          )}

          {currentStep === "confirm" && (
            <DonateConfirm
              project={project}
              amount={amount}
              session={session}
              isLoading={isLoading}
              error={error}
              handleConfirmDonation={handleConfirmDonation}
              handleBackToInput={handleBackToInput}
            />
          )}

          {currentStep === "complete" && (
            <DonateComplete
              project={project}
              amount={amount}
              session={session}
              transactionId={transactionId}
              router={router}
            />
          )}
        </Card>
      </div>
    </PageContainer>
  );
}
</file>

<file path="docs/architecture/neverthrow-progress.md">
# Neverthrow導入進捗管理

## 📊 進捗ダッシュボード

### 全体進捗

```
進捗: 100% (32/32 タスク完了) 🎉
現在フェーズ: 全フェーズ完了 ✅
最終更新: 2025/05/28 (最終確認完了)
```

### フェーズ別進捗

#### Phase 1: 基盤整備 (8/8 完了) ✅

```
進捗: 100% ██████████
推定工数: 2-3日 → 実績: 1日
```

#### Phase 2: ビジネスロジック層 (12/12 完了) ✅

```
進捗: 100% ██████████
推定工数: 5-7日 → 実績: 1日
```

#### Phase 3: UI層 (12/12 完了) ✅

```
進捗: 100% ██████████
推定工数: 3-5日 → 実績: 2日
```

## 📋 詳細タスク一覧

### Phase 1: 基盤整備 ✅ 完了

#### 1.1 パッケージインストール

- [x] **P1-001**: neverthrowパッケージのインストール
  - コマンド: `pnpm install neverthrow`
  - 確認: package.jsonにneverthrowが追加されていること
  - **完了日**: 2025/05/26

#### 1.2 基盤ファイルの作成

- [x] **P1-002**: エラー型定義ファイルの作成

  - ファイル: `src/shared/types/errors.ts`
  - 内容: ValidationError, ApiError, BusinessError, AppError型定義
  - **完了日**: 2025/05/26

- [x] **P1-003**: エラーハンドリングユーティリティの作成

  - ファイル: `src/lib/utils/error-utils.ts`
  - 内容: getErrorMessage, getErrorSeverity関数
  - **完了日**: 2025/05/26

- [x] **P1-004**: Result型ユーティリティの作成
  - ファイル: `src/lib/utils/result-utils.ts`
  - 内容: 変換関数、デバッグ関数、アダプター関数
  - **完了日**: 2025/05/26

#### 1.3 バリデーション関数の改修

- [x] **P1-005**: validateAmount関数の改修

  - ファイル: `src/lib/utils/validation.ts`
  - 変更: Result<number, ValidationError>を返すよう修正
  - **完了日**: 2025/05/26

- [x] **P1-006**: isValidEmail関数の改修

  - ファイル: `src/lib/utils/validation.ts`
  - 変更: Result<string, ValidationError>を返すよう修正
  - **完了日**: 2025/05/26

- [x] **P1-007**: validatePassword関数の改修
  - ファイル: `src/lib/utils/validation.ts`
  - 変更: Result<string, ValidationError>を返すよう修正
  - **完了日**: 2025/05/26

#### 1.4 テストとドキュメント

- [x] **P1-008**: バリデーション関数のテスト更新
  - 既存テストの修正とResult型対応テストの追加
  - **完了日**: 2025/05/26

### Phase 2: ビジネスロジック層

#### 2.1 API関数の改修

- [x] **P2-001**: API基盤関数の作成

  - ファイル: `src/services/api/base.ts`
  - 内容: 共通のAPI呼び出し関数（ResultAsync対応）
  - **完了日**: 2025/05/26

- [x] **P2-002**: ユーザー関連API関数の改修

  - ファイル: `src/services/api/user.ts`
  - 対象関数: fetchUserProfile, updateUserProfile等
  - **完了日**: 2025/05/26

- [x] **P2-003**: 残高関連API関数の改修

  - ファイル: `src/services/api/balance.ts`
  - 対象関数: fetchBalance, updateBalance等
  - **完了日**: 2025/05/26

- [x] **P2-004**: 取引関連API関数の改修
  - ファイル: `src/services/api/transactions.ts`
  - 対象関数: fetchTransactions, createTransaction等
  - **完了日**: 2025/05/26

#### 2.2 ビジネスロジック関数の改修

- [x] **P2-005**: 決済処理関数の改修

  - ファイル: `src/lib/business/payment.ts`
  - 対象関数: processPayment, validatePayment等
  - **完了日**: 2025/05/26

- [x] **P2-006**: 残高管理関数の改修

  - ファイル: `src/lib/business/balance.ts`
  - 対象関数: calculateBalance, updateBalance等
  - **完了日**: 2025/05/26

- [x] **P2-007**: トランザクション処理関数の改修

  - ファイル: `src/lib/business/transaction.ts`
  - 対象関数: createTransaction, validateTransaction等
  - **完了日**: 2025/05/26

- [x] **P2-008**: 環境貢献計算関数の改修
  - ファイル: `src/lib/business/eco-contribution.ts`
  - 対象関数: calculateEcoContribution等
  - **完了日**: 2025/05/26

#### 2.3 状態管理の改修

- [x] **P2-009**: ユーザー状態管理の改修

  - ファイル: `src/features/auth/store/auth.slice.ts`
  - 対象: 認証関連のZustandストア（Result型対応）
  - **完了日**: 2025/05/26

- [x] **P2-010**: 残高状態管理の改修

  - ファイル: `src/features/balance/store/balance.slice.ts`
  - 対象: 残高関連のZustandストア（Result型対応）
  - **完了日**: 2025/05/26

- [x] **P2-011**: 取引状態管理の改修

  - ファイル: `src/features/transactions/store/transaction.slice.ts`
  - 対象: 取引関連のZustandストア（Result型対応）
  - **完了日**: 2025/05/26

- [x] **P2-012**: 共通状態管理の改修
  - ファイル: `src/shared/stores/app.slice.ts`
  - 対象: 共通状態管理（エラー、ローディング等、Result型対応）
  - **完了日**: 2025/05/26

### Phase 3: UI層

#### 3.1 フォームコンポーネントの改修

- [x] **P3-001**: ChargeInputContainerの改修

  - ファイル: `src/features/charge/components/ChargeInput/ChargeInputContainer.tsx`
  - 変更: Result型を使用したバリデーション
  - **完了日**: 2025/05/27

- [x] **P3-002**: PaymentMethodSelectorの改修

  - ファイル: `src/features/payment/components/PaymentMethodSelector/PaymentMethodSelectorContainer.tsx`
  - 変更: Result型対応コンテナコンポーネント作成、PaymentStore改修
  - **完了日**: 2025/05/27

- [x] **P3-003**: その他フォームコンポーネントの改修
  - 対象: LoginFormの改修完了
  - **完了日**: 2025/05/27

#### 3.2 フォーム統合の継続

- [x] **P3-004**: useTransferFormフックのResult型対応

  - ファイル: `src/features/transfer/hooks/useTransferForm.ts`
  - 内容: useAuthFormパターン適用、Result型バリデーション統合
  - **完了日**: 2025/05/28

- [x] **P3-005**: TransferFormコンポーネントの統合

  - ファイル: `src/features/transfer/components/TransferForm/TransferForm.tsx`
  - 内容: 新しいuseTransferFormとの統合、ErrorDisplay使用
  - **完了日**: 2025/05/28

- [x] **P3-006**: SecurityTabの改修

  - ファイル: `src/features/settings/components/tabs/SecurityTab.tsx`
  - 内容: Result型統合とuseAuthFormパターン完全適用、統一エラーハンドリング実装
  - **完了日**: 2025/05/28

- [x] **P3-007**: ProfileTabの改修

  - ファイル: `src/features/settings/components/tabs/ProfileTab.tsx`
  - 内容: useAuthFormパターン適用、validateProfileForm関数活用、統一エラーハンドリング実装
  - **完了日**: 2025/05/28

- [x] **P3-008**: DonateInputContainerの改修
  - ファイル: `src/features/donation/components/DonateInput/DonateInputContainer.tsx`
  - 内容: useAuthFormパターン適用、validateDonationForm関数活用、INSUFFICIENT_BALANCEエラー型による残高不足チェック、ローディング状態表示実装
  - **完了日**: 2025/05/28

#### 3.3 最終仕上げ（2025/05/28 追加対応）

- [x] **P3-009**: useSplitFormフックのResult型対応

  - ファイル: `src/features/transfer/hooks/useSplitForm.ts`
  - 内容: 割り勘機能のAppError型統合、clearError機能追加
  - **完了日**: 2025/05/28

- [x] **P3-010**: SplitFormコンポーネントの統合

  - ファイル: `src/features/transfer/components/SplitForm/SplitForm.tsx`
  - 内容: ErrorDisplayコンポーネント使用、統一エラーハンドリング
  - **完了日**: 2025/05/28

- [x] **P3-011**: 寄付ページのAppError型対応

  - ファイル: `src/app/donate/[id]/page.tsx`
  - 内容: 従来の`string | null`から`AppError | null`への完全移行
  - **完了日**: 2025/05/28

- [x] **P3-012**: DonateConfirmコンポーネントのAppError型対応
  - ファイル: `src/features/donation/components/DonateConfirm/DonateConfirm.tsx`
  - 内容: AppError型対応、ErrorDisplayコンポーネント統合
  - **完了日**: 2025/05/28

## 📝 作業履歴

### 2025/05/26 - Phase 1 完了 🎉

- **P1-001完了**: neverthrowパッケージのインストール（pnpm使用）
- **P1-002完了**: エラー型定義ファイルの作成
  - ValidationError, ApiError, BusinessError, AppError型定義
  - エラーコンテキストと拡張エラー情報の定義
- **P1-003完了**: エラーハンドリングユーティリティの作成
  - getErrorMessage, getErrorSeverity関数
  - ログ出力、コンテキスト作成関数
  - 36個のテスト（全て合格）
- **P1-004完了**: Result型ユーティリティの作成
  - デバッグ関数、変換関数、アダプター関数
  - fromLegacyValidation, toLegacyValidationによる段階的移行サポート
- **P1-005-007完了**: バリデーション関数の改修
  - 従来版とResult型版の両方を提供（段階的移行）
  - validateEmailResult, validatePasswordResult, validateAmountResult等
  - 包括的なテストカバレッジ
- **P1-008完了**: テスト更新とIn Source Testing導入
  - vitest.config.tsの設定更新
  - tsconfig.jsonにvitest型定義追加
  - 全36テストが合格

### 2025/05/26 - Phase 2 API関数層完了 🚀

- **P2-001完了**: API基盤関数の作成
  - ファイル: `src/services/api/base.ts`
  - 内容: ResultAsync対応の統一APIクライアント基盤
  - 機能: GET/POST/PUT/DELETE/PATCHメソッド、エラーハンドリング、タイムアウト制御
  - 14個のテスト（全て合格）
- **P2-002完了**: ユーザー関連API関数の改修
  - ファイル: `src/services/api/user.ts`
  - 内容: ユーザー認証・プロフィール管理のResultAsync対応
  - 機能: ログイン、登録、プロフィール更新、パスワード変更等
  - 13個のテスト（全て合格）
- **P2-003完了**: 残高関連API関数の改修
  - ファイル: `src/services/api/balance.ts`
  - 内容: 残高管理・決済・送金のResultAsync対応
  - 機能: 残高取得、チャージ、決済、送金、エコ貢献統計等
  - 13個のテスト（全て合格）
- **P2-004完了**: 取引関連API関数の改修
  - ファイル: `src/services/api/transactions.ts`
  - 内容: 取引管理・統計のResultAsync対応
  - 機能: 取引一覧取得、作成、更新、削除、統計取得等
  - 8個のテスト（全て合格）
- **技術的成果**: 48個のテスト全て合格、型安全なAPI基盤確立

### 2025/05/26 - Phase 2 ビジネスロジック層完了 🎯

- **P2-005完了**: 決済処理関数の改修
  - ファイル: `src/lib/business/payment.ts`
  - 内容: Result<T, BusinessError>対応の決済処理ビジネスロジック
  - 機能: processPayment, validatePaymentAmount, calculatePaymentFee, cancelPayment等
  - 包括的バリデーション、手数料計算、決済状態管理機能
- **P2-006完了**: 残高管理関数の改修
  - ファイル: `src/lib/business/balance.ts`
  - 内容: Result<T, BusinessError>対応の残高管理ビジネスロジック
  - 機能: calculateTotalBalance, validateChargeAmount, processCharge, checkSufficientBalance等
  - キャンペーン残高計算、チャージ処理、残高制限チェック機能
- **P2-007完了**: トランザクション処理関数の改修
  - ファイル: `src/lib/business/transaction.ts`
  - 内容: Result<T, BusinessError>対応の取引処理ビジネスロジック
  - 機能: createTransaction, validateTransactionAmount, aggregateTransactions, checkTransactionDuplicate等
  - 取引種別バリデーション、集計処理、重複チェック機能
- **P2-008完了**: 環境貢献計算関数の改修
  - ファイル: `src/lib/business/eco-contribution.ts`
  - 内容: Result<T, BusinessError>対応の環境貢献計算ビジネスロジック
  - 機能: calculateEcoContributionSafe, validateEcoContributionAmount, calculateEcoEfficiency等
  - 環境貢献バリデーション、効率性計算、レポート生成機能
- **技術的成果**: 型安全なビジネスロジック基盤確立、In Source Testing導入、包括的エラーハンドリング

### 2025/05/27 - Phase 3 UI層開始 🎨

- **P3-001完了**: ChargeInputContainerの改修
  - ファイル: `src/features/charge/components/ChargeInput/ChargeInputContainer.tsx`
  - 内容: Result型対応バリデーション、ビジネスロジック層統合、統一エラーハンドリング
  - 機能: 段階的バリデーション（入力→ビジネス→API）、useMemoによる効率的再計算
  - ESLintエラー修正、プロダクションビルド確認完了
- **P3-002完了**: PaymentMethodSelectorの改修
  - ファイル: `src/features/payment/components/PaymentMethodSelector/PaymentMethodSelectorContainer.tsx`
  - 内容: Result型対応コンテナコンテナコンポーネント作成、PaymentStore改修
  - 機能: 決済方法バリデーション、手数料計算、ビジネスロジック層統合
  - PaymentStoreをResult型.match()パターンに移行、統一エラーハンドリング実装
- **P3-003完了**: LoginFormの改修
  - ファイル: `src/features/auth/components/LoginForm/LoginFormContainer.tsx`
  - 内容: Result型対応認証フォーム、コンテナー・ビュー分離実装
  - 機能: 型安全なログイン処理、統一バリデーション、AuthFieldView新規作成
  - 機能: LoginFormView、AuthFieldViewによるUI分離、統一エラーハンドリング実装
- **技術的成果**: P3-001で確立した実装パターンの効率的適用、UI層の型安全性向上、認証フローのResult型統合

### 2025/05/28 - Phase 3 大幅進展 🚀

- **P3-004完了**: useTransferFormフックのResult型対応
  - ファイル: `src/features/transfer/hooks/useTransferForm.ts`
  - 内容: useAuthFormパターンの効率的適用、完全なResult型統合
  - 機能: fieldErrors対応、executeTransfer分離、統一エラーハンドリング
  - 技術的工夫: TransactionStoreのResult型戻り値への適切な対応
- **P3-005完了**: TransferFormコンポーネントの統合
  - ファイル: `src/features/transfer/components/TransferForm/TransferForm.tsx`
  - 内容: 新しいuseTransferFormとの完全統合、ErrorDisplay活用
  - 機能: fieldErrors表示、recipient/amount別エラーハンドリング
  - UI改善: バナー形式でのグローバルエラー表示
- **P3-006開始**: SecurityTabの改修
  - ファイル: `src/features/settings/components/tabs/SecurityTab.tsx`
  - 内容: Result型統合とvalidateChangePasswordForm活用
  - 技術基盤: TypeScriptエラー修正、適切なインポート整理
- **技術的成果**:
  - useAuthFormパターンの再利用効率向上
  - 送金フローの完全なResult型統合
  - ErrorDisplayコンポーネントの活用拡大
  - フォーム処理の一貫性向上

### 2025/01/25

- **初期設定**: neverthrow導入計画の策定
- **ドキュメント作成**:
  - `docs/architecture/neverthrow-migration-guide.md` 作成
  - `docs/architecture/neverthrow-progress.md` 作成
- **現状分析**: 既存エラーハンドリングパターンの調査完了

### 技術的成果

- **型安全性の向上**: 統一されたAppError型による明示的エラーハンドリング
- **互換性の保証**: 段階的移行のためのアダプター関数
- **テスト品質向上**: In Source Testingによる包括的テストカバレッジ
- **開発者体験改善**: デバッグ用ユーティリティと詳細なエラーメッセージ

## 🚀 Phase 2への移行準備

### 次のセッションでの最優先タスク

1. **P2-001**: API基盤関数の作成（ResultAsync対応）
2. **P2-002**: ユーザー関連API関数の改修
3. **P2-003**: 残高関連API関数の改修

### Phase 2の前提条件 ✅

- [x] neverthrowパッケージのインストール
- [x] エラー型定義の完成
- [x] ユーティリティ関数の準備
- [x] バリデーション関数のResult型対応
- [x] テスト環境の整備

### Phase 2での注意事項

- API関数はResultAsync<T, ApiError>を返すよう統一
- 既存のtry/catchパターンからの段階的移行
- モックデータとの整合性確保
- 非同期エラーハンドリングの一貫性

### 期待される成果物（Phase 2）

- 全API関数のResultAsync型対応
- ビジネスロジック関数のResult型統一
- 状態管理でのエラーハンドリング改善
- 非同期処理の堅牢性向上

## 📊 品質指標

### 成功指標（Phase 1） ✅

- [x] 型エラーが0件
- [x] 既存テストが全て通る（36/36テスト合格）
- [x] 新規テストのカバレッジが80%以上
- [x] ビルドエラーが0件

### 成功指標（Phase 2）

- [ ] 全API関数がResultAsync型を返す
- [ ] ビジネスロジック関数のResult型統一
- [ ] 状態管理のエラーハンドリング統一
- [ ] 非同期処理の型安全性確保

### パフォーマンス指標

- [ ] バンドルサイズの増加が5%以下
- [ ] 初期ロード時間に大きな変化なし
- [ ] メモリ使用量の著しい増加なし

## 🔗 関連リンク

- [Neverthrow導入ガイド](./neverthrow-migration-guide.md)
- [プロジェクト概要](./overview.md)
- [開発ガイド](./development-guide.md)
- [Cline開発ガイド](./cline-development-guide.md)
- [neverthrow公式ドキュメント](https://github.com/supermacro/neverthrow)

---

**最終更新**: 2025/05/29 (最終動作確認完了)
**更新者**: Development Team
**Phase 1完了**: 2025/05/26
**Phase 2完了**: 2025/05/26
**Phase 3完了**: 2025/05/28
**プロジェクト完了**: 2025/05/29 ✅
**動作確認**: 2025/05/29 (neverthrow v8.2.0 正常動作確認済み)
</file>

<file path="src/app/history/page.tsx">
"use client";

import { useState, useMemo } from "react";
import {
  parseISO,
  isWithinInterval,
  startOfDay,
  endOfDay,
  startOfMonth,
} from "date-fns";
import { useTransactionStore } from "@/features/transactions/store/transaction.slice";
import { FeaturedCampaignSection } from "@/features/campaigns";
import { BalanceOverview } from "@/features/balance";
import { TransactionFilters, TransactionList } from "@/features/transactions";
import { EcoContributionSummary } from "@/features/eco-impact";
import { ArrowLeft, TrendingUp, Leaf } from "lucide-react";
import Link from "next/link";
import { AppError } from "@/shared/types/errors";
import { ErrorDisplay } from "@/components/ui/error-display";
import { showAppErrorNotification } from "@/shared/stores/app.slice";

export default function TransactionHistoryPage() {
  // タブの選択状態
  const [selectedTab, setSelectedTab] = useState<
    "all" | "in" | "out" | "campaign" | "eco"
  >("all");

  // 期間選択の状態
  const [startDate, setStartDate] = useState<Date>(startOfMonth(new Date()));
  const [endDate, setEndDate] = useState<Date>(new Date());

  // エラーステート管理（Result型対応）
  const [error, setError] = useState<AppError | null>(null);

  // Zustand ストアからデータとメソッドを取得（Result型対応）
  const transactions = useTransactionStore((state) => state.transactions);
  const getTransactionsByType = useTransactionStore(
    (state) => state.getTransactionsByType,
  );
  const getTransactionsWithEcoContribution = useTransactionStore(
    (state) => state.getTransactionsWithEcoContribution,
  );
  const getTotalEcoContribution = useTransactionStore(
    (state) => state.getTotalEcoContribution,
  );

  // エラー再試行ハンドラ（Result型対応）
  const handleRetry = () => {
    setError(null);
    // フィルタリングを再実行（特にAPIアクセスが必要な場合）
    handleTabChange(selectedTab);
  };

  // タブの変更ハンドラ（Result型対応エラーハンドリング）
  const handleTabChange = (
    value: "all" | "in" | "out" | "campaign" | "eco",
  ) => {
    setSelectedTab(value);
    setError(null); // タブ変更時にエラーをクリア

    // 特定のタブでResult型メソッドを活用
    if (value === "eco") {
      const ecoResult = getTransactionsWithEcoContribution();
      ecoResult.match(
        () => {
          // 成功時は特に何もしない（フィルタリングはuseMemoで処理）
        },
        (error) => {
          setError(error);
          showAppErrorNotification(error, "環境貢献取引の取得エラー");
        },
      );
    }
  };

  // フィルタリングされた取引リストを計算（Result型統合）
  const filteredTransactions = useMemo(() => {
    try {
      // タイプでフィルタリング（Result型メソッド活用）
      let result = transactions;

      switch (selectedTab) {
        case "in":
          // 入金: charge と receive タイプの取引
          const chargeResult = getTransactionsByType("charge");
          const receiveResult = getTransactionsByType("receive");

          if (chargeResult.isOk() && receiveResult.isOk()) {
            const chargeTransactions = chargeResult.value;
            const receiveTransactions = receiveResult.value;
            result = [...chargeTransactions, ...receiveTransactions];
          } else {
            // フォールバック: 従来のフィルタリング
            result = result.filter(
              (tx) => tx.type === "charge" || tx.type === "receive",
            );
          }
          break;
        case "out":
          // 支払い: payment タイプの取引
          const paymentResult = getTransactionsByType("payment");
          if (paymentResult.isOk()) {
            result = paymentResult.value;
          } else {
            // フォールバック: 従来のフィルタリング
            result = result.filter((tx) => tx.type === "payment");
          }
          break;
        case "campaign":
          // 特典: 特典バッジを持つ取引
          result = result.filter(
            (tx) => tx.badges && tx.badges.includes("特典"),
          );
          break;
        case "eco":
          // 環境貢献: 環境貢献のある取引（Result型メソッド活用）
          const ecoResult = getTransactionsWithEcoContribution();
          if (ecoResult.isOk()) {
            result = ecoResult.value;
          } else {
            // フォールバック: 従来のフィルタリング
            result = result.filter((tx) => tx.ecoContribution?.enabled);
          }
          break;
        default:
          // "all": すべての取引を表示
          break;
      }

      // 日付でフィルタリング
      result = result.filter((tx) => {
        try {
          // 文字列形式の日付をDateオブジェクトに変換
          // "2025/04/15" 形式か "2025年4月15日" 形式かチェック
          let txDate: Date;

          if (typeof tx.date === "string") {
            if (tx.date.includes("/")) {
              // yyyy/mm/dd 形式
              txDate = parseISO(tx.date.replace(/\//g, "-"));
            } else if (tx.date.includes("年")) {
              // yyyy年mm月dd日 形式
              const matched = tx.date.match(/(\d+)年(\d+)月(\d+)日/);
              if (matched) {
                txDate = new Date(
                  parseInt(matched[1]),
                  parseInt(matched[2]) - 1,
                  parseInt(matched[3]),
                );
              } else {
                txDate = new Date(tx.date);
              }
            } else {
              // その他の形式
              txDate = new Date(tx.date);
            }
          } else if (tx.date && typeof tx.date === "object") {
            // 日付オブジェクトとして扱う
            txDate = new Date(tx.date as Date);
          } else {
            // 日付として解釈できない場合はフィルタから除外しない
            return true;
          }

          // 開始日の00:00:00から終了日の23:59:59までの範囲でフィルタリング
          return isWithinInterval(txDate, {
            start: startOfDay(startDate),
            end: endOfDay(endDate),
          });
        } catch (e) {
          // 日付解析エラーの場合は表示する（フィルタから除外しない）
          console.error("Date parsing error:", e);
          return true;
        }
      });

      return result;
    } catch (error) {
      // フィルタリング処理でエラーが発生した場合
      console.error("Transaction filtering error:", error);
      const appError: AppError = {
        type: "NETWORK_ERROR",
        message: "取引データの処理中にエラーが発生しました",
      };
      setError(appError);
      showAppErrorNotification(appError, "取引履歴エラー");
      return []; // 空の配列を返してアプリケーションの継続を許可
    }
  }, [
    transactions,
    selectedTab,
    startDate,
    endDate,
    getTransactionsByType,
    getTransactionsWithEcoContribution,
  ]);

  // 統計情報の計算（Result型対応）
  const statistics = useMemo(() => {
    try {
      const totalIncome = filteredTransactions
        .filter((tx) => tx.amount > 0)
        .reduce((sum, tx) => sum + tx.amount, 0);

      const totalExpense = filteredTransactions
        .filter((tx) => tx.amount < 0)
        .reduce((sum, tx) => sum + Math.abs(tx.amount), 0);

      // 環境貢献合計をResult型メソッドで計算
      const ecoContributionResult = getTotalEcoContribution();
      let totalEcoContribution = 0;

      if (ecoContributionResult.isOk()) {
        totalEcoContribution = ecoContributionResult.value;
      } else {
        // フォールバック: 従来の計算方法
        totalEcoContribution = filteredTransactions
          .filter((tx) => tx.ecoContribution?.enabled)
          .reduce((sum, tx) => sum + (tx.ecoContribution?.amount || 0), 0);
      }

      return {
        totalIncome,
        totalExpense,
        totalEcoContribution,
      };
    } catch (error) {
      console.error("Statistics calculation error:", error);
      return {
        totalIncome: 0,
        totalExpense: 0,
        totalEcoContribution: 0,
      };
    }
  }, [filteredTransactions, getTotalEcoContribution]);

  return (
    <div className="min-h-screen bg-stone-50">
      {/* ヘッダー */}
      <header className="bg-white border-b border-stone-200 sticky top-0 z-10">
        <div className="max-w-md mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <Link
              href="/"
              className="flex items-center gap-2 text-stone-600 hover:text-teal-700 transition-colors"
            >
              <ArrowLeft className="h-5 w-5" />
              <span className="text-xs font-medium">ホーム</span>
            </Link>
            <h1 className="text-lg font-semibold text-stone-900">取引履歴</h1>
            <div className="w-16" /> {/* スペーサー */}
          </div>
        </div>
      </header>

      <div className="max-w-md mx-auto px-4 py-6 space-y-6">
        {/* エラー表示（Result型対応） */}
        {error && (
          <ErrorDisplay error={error} onRetry={handleRetry} className="mb-4" />
        )}

        {/* 統計サマリー */}
        <div className="bg-white rounded-xl p-4 shadow-sm border border-stone-100">
          <div className="grid grid-cols-3 gap-4">
            <div className="text-center">
              <p className="text-xs text-stone-500 mb-1">入金合計</p>
              <p className="text-lg font-semibold text-blue-600">
                ¥{statistics.totalIncome.toLocaleString()}
              </p>
            </div>
            <div className="text-center border-x border-stone-100">
              <p className="text-xs text-stone-500 mb-1">支払合計</p>
              <p className="text-lg font-semibold text-stone-700">
                ¥{statistics.totalExpense.toLocaleString()}
              </p>
            </div>
            <div className="text-center">
              <p className="text-xs text-stone-500 mb-1">環境貢献</p>
              <p className="text-lg font-semibold text-teal-600">
                ¥{statistics.totalEcoContribution.toLocaleString()}
              </p>
            </div>
          </div>
        </div>

        {/* 残高情報 */}
        <div className="bg-white rounded-xl shadow-sm border border-stone-100 overflow-hidden">
          <div className="px-4 py-3 border-b border-stone-100">
            <h2 className="text-sm font-medium text-stone-700">残高情報</h2>
          </div>
          <BalanceOverview />
        </div>

        {/* フィルター */}
        <div>
          <TransactionFilters
            selectedTab={selectedTab}
            onTabChange={handleTabChange}
            startDate={startDate}
            setStartDate={setStartDate}
            endDate={endDate}
            setEndDate={setEndDate}
          />
        </div>

        {/* 取引リスト */}
        <div>
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-sm font-medium text-stone-700">
              取引一覧
              <span className="ml-2 text-xs text-stone-500">
                ({filteredTransactions.length}件)
              </span>
            </h3>
            {filteredTransactions.length > 0 && (
              <TrendingUp className="h-4 w-4 text-stone-400" />
            )}
          </div>
          <TransactionList
            transactions={filteredTransactions}
            initialLimit={10}
          />
        </div>

        {/* キャンペーン情報 */}
        <div className="pt-2">
          <FeaturedCampaignSection />
        </div>

        {/* 環境貢献サマリー */}
        <div className="bg-teal-50 rounded-xl p-4 border border-teal-200">
          <div className="flex items-center gap-2 mb-3">
            <div className="w-8 h-8 bg-teal-100 rounded-full flex items-center justify-center">
              <Leaf className="h-4 w-4 text-teal-700" />
            </div>
            <h3 className="text-sm font-medium text-teal-800">
              あなたの環境への貢献
            </h3>
          </div>
          <EcoContributionSummary />
        </div>

        {/* フッターメッセージ */}
        <div className="text-center py-6">
          <p className="text-xs text-stone-500">
            お客様の購入ごとに、売上の1%を
            <br />
            環境保護団体に寄付しています
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

</files>
